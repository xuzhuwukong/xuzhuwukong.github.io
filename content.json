{"meta":{"title":"Hexo","subtitle":null,"description":"记录为了更好的成长","author":"David","url":"http://yoursite.com","root":"/"},"pages":[{"title":"关于我","date":"2019-04-16T07:37:26.000Z","updated":"2019-04-16T07:37:43.315Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-03-15T20:50:13.000Z","updated":"2019-04-16T08:13:20.114Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-03-15T20:48:46.000Z","updated":"2019-04-16T08:14:01.050Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"python 类和对象","slug":"python-类和对象","date":"2019-05-20T04:32:36.000Z","updated":"2019-06-13T14:12:31.136Z","comments":true,"path":"2019/05/20/python-类和对象/","link":"","permalink":"http://yoursite.com/2019/05/20/python-类和对象/","excerpt":"","text":"面向对象面向过程，流程化，设计简单，不容易扩展，扩展需要改动大，比如登录接口，用户，密码，增加email字段面向对象，对象是一个实例，有属性，特征，有方法。比如孙悟空，属性，72变。优点，扩展性强。缺点，编程复杂度高，过度设计。应用于用户需求经常变化，经常改参数，企业内部应用，办公系统。 类和对象站在不同的角度，得到不同的分类. class Student(object): school=&apos;school&apos; #数据属性 def learn(self): #函数属性 print(&quot;is learning&quot;) 查看print(Student.__dict__) # 查看类的名称空间 print(Student.__dict__[&apos;school&apos;]) print(Student.school) 增加Student.country = &quot;China&quot; 删除del 改Student.school = &apos;School&apos; 创造对象stu1 = Student() 构造方法init 和 析构方法del __init__个性化定制属性,独有特征 def __init__(self,name,age): self.name = name self.age = age 调用过程，先产生一个空对象，stu1 调用__init__方法，__init__(stu1,name,age) 属性查找Stuendt.learn(stu1) 对象---》 类 ---》父类 不会到全局去找，没找到报错 装饰器绑定方法和非绑定方法封装继承和派生多态和多态性组合抽象类反射内置方法new、initnew方法是真正的类构造方法，用于产生实例化对象（空属性）。重写new方法可以控制对象的产生过程。init方法是初始化方法，负责对实例化对象进行属性值初始化，此方法必须返回None，new方法必须返回一个对象。重写init方法可以控制对象的初始化过程。123456789101112131415161718# 使用new来处理单例模式class Student: __instance = None def __new__(cls, *args, **kwargs): if not cls.__instance: cls.__instance = object.__new__(cls) return cls.__instance def sleep(self): print(&apos;sleeping...&apos;)stu1 = Student()stu2 = Student()print(id(stu1), id(stu2)) # 两者输出相同print(stu1 is stu2) # True str、repr两者的目的都是为了显式的显示对象的一些必要信息，方便查看和调试。str被print默认调用，repr被控制台输出时默认调用。即，使用str控制用户展示，使用repr控制调试展示。123456789101112131415# 自定义str来控制print的显示内容，str函数必须return一个字符串对象# 使用repr = str来偷懒控制台和print的显示一致class Student: def __init__(self, name, age): self.name = name self.age = age def __str__(self): return f&apos;&#123;self.__class__&#125;, &#123;self.name&#125;, &#123;self.age&#125;&apos; __repr__ = __str__stu = Student(&apos;zlw&apos;, 26)print(stu) # &lt;class &apos;__main__.Student&apos;&gt;, zlw, 26 callcall方法提供给对象可以被执行的能力，就像函数那样，而本质上，函数就是对象，函数就是一个拥有call方法的对象。拥有call方法的对象，使用callable可以得到True的结果，可以使用（）执行，执行时，可以传入参数，也可以返回值。所以我们可以使用call方法来实现实例化对象作为装饰器：123456789101112131415161718192021# 检查一个函数的输入参数个数, 如果调用此函数时提供的参数个数不符合预定义，则无法调用。# 单纯函数版本装饰器def args_num_require(require_num): def outer(func): def inner(*args, **kw): if len(args) != require_num: print(&apos;函数参数个数不符合预定义，无法执行函数&apos;) return None return func(*args, **kw) return inner return outer@args_num_require(2)def show(*args): print(&apos;show函数成功执行!&apos;)show(1) # 函数参数个数不符合预定义，无法执行函数show(1,2) # show函数成功执行!show(1,2,3) # 函数参数个数不符合预定义，无法执行函数 1234567891011121314151617181920212223242526# 检查一个函数的输入参数个数,# 如果调用此函数时提供的参数个数不符合预定义，则无法调用。# 实例对象版本装饰器class Checker: def __init__(self, require_num): self.require_num = require_num def __call__(self, func): self.func = func def inner(*args, **kw): if len(args) != self.require_num: print(&apos;函数参数个数不符合预定义，无法执行函数&apos;) return None return self.func(*args, **kw) return inner@Checker(2)def show(*args): print(&apos;show函数成功执行!&apos;)show(1) # 函数参数个数不符合预定义，无法执行函数show(1,2) # show函数成功执行!show(1,2,3) # 函数参数个数不符合预定义，无法执行函数 deldel用于当对象的引用计数为0时自动调用。del一般出现在两个地方：1、手工使用del减少对象引用计数至0，被垃圾回收处理时调用。2、程序结束时调用。del一般用于需要声明在对象被删除前需要处理的资源回收操作123456789101112# 手工调用del 可以将对象引用计数减一，如果减到0，将会触发垃圾回收class Student: def __del__(self): print(&apos;调用对象的del方法，此方法将会回收此对象内存地址&apos;)stu = Student() # 调用对象的__del__方法回收此对象内存地址del stuprint(&apos;下面还有程序其他代码&apos;) iter、next这2个方法用于将一个对象模拟成序列。内置类型如列表、元组都可以被迭代，文件对象也可以被迭代获取每一行内容。重写这两个方法就可以实现自定义的迭代对象。1234567891011121314151617181920# 定义一个指定范围的自然数类，并可以提供迭代class Num: def __init__(self, max_num): self.max_num = max_num self.count = 0 def __iter__(self): return self def __next__(self): if self.count &lt; self.max_num: self.count += 1 return self.count else: raise StopIteration(&apos;已经到达临界&apos;) num = Num(10)for i in num: print(i) # 循环打印1---10 getitem、setitem、delitem重写此系列方法可以模拟对象成列表或者是字典，即可以使用key-value的类型。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class StudentManager: li = [] dic = &#123;&#125; def add(self, obj): self.li.append(obj) self.dic[obj.name] = obj def __getitem__(self, item): if isinstance(item, int): # 通过下标得到对象 return self.li[item] elif isinstance(item, slice): # 通过切片得到一串对象 start = item.start stop = item.stop return [student for student in self.li[start:stop]] elif isinstance(item, str): # 通过名字得到对象 return self.dic.get(item, None) else: # 给定的key类型错误 raise TypeError(&apos;你输入的key类型错误!&apos;)class Student: manager = StudentManager() def __init__(self, name): self.name = name self.manager.add(self) def __str__(self): return f&apos;学生: &#123;self.name&#125;&apos; __repr__ = __str__stu1 = Student(&apos;小明&apos;)stu2 = Student(&apos;大白&apos;)stu3 = Student(&apos;小红&apos;)stu4 = Student(&apos;胖虎&apos;)# 当做列表使用print(Student.manager[0]) # 学生: 小明print(Student.manager[-1]) # 学生: 胖虎print(Student.manager[1:3]) # [学生: 大白, 学生: 小红]# 当做字典使用print(Student.manager[&apos;胖虎&apos;]) # 学生: 胖虎 getattr、setattr、delattr当使用obj.x = y的时候触发对象的setattr方法，当del obj.x的时候触发对象的delattr方法。当尝试访问对象的一个不存在的属性时 obj.noexist 会触发getattr方法，getattr方法是属性查找中优先级最低的。可以重写这3个方法来控制对象属性的访问、设置和删除。特别注意：如果定义了getattr，而没有任何代码（即只有pass），则所有不存在的属性值都是None而不会报错,可以使用super().getattr()方法来处理12345678910111213141516171819class Student: def __getattr__(self, item): print(&apos;访问一个不存在的属性时候触发&apos;) return &apos;不存在&apos; def __setattr__(self, key, value): print(&apos;设置一个属性值的时候触发&apos;) # self.key = value # 这样会无限循环 self.__dict__[key] = value def __delattr__(self, item): print(&apos;删除一个属性的时候触发&apos;) if self.__dict__.get(item, None): del self.__dict__[item]stu = Student()stu.name = &apos;zlw&apos; # 设置一个属性值的时候触发print(stu.noexit) # 访问一个不存在的属性时候触发 , 返回&apos;不存在&apos;del stu.name # 删除一个属性的时候触发 getatrribute这是一个属性访问截断器，即，在你访问属性时，这个方法会把你的访问行为截断，并优先执行此方法中的代码，此方法应该是属性查找顺序中优先级最高的。属性查找顺序：实例的getattribute–&gt;实例对象字典–&gt;实例所在类字典–&gt;实例所在类的父类(MRO顺序）字典–&gt;实例所在类的getattr–&gt;报错1234567891011121314151617181920class People: a = 200class Student(People): a = 100 def __init__(self, a): self.a = a def __getattr__(self, item): print(&apos;没有找到:&apos;, item) def __getattribute__(self, item): print(&apos;属性访问截断器&apos;) if item == &apos;a&apos;: return 1 return super().__getattribute__(item)stu = Student(1)print(stu.a) # 1 enter、exit这两个方法的重写可以让我们对一个对象使用with方法来处理工作前的准备，以及工作之后的清扫行为123456789101112131415161718192021222324class MySQL: def connect(self): print(&apos;启动数据库连接，申请系统资源&apos;) def execute(self): print(&apos;执行sql命令，操作数据&apos;) def finish(self): print(&apos;数据库连接关闭，清理系统资源&apos;) def __enter__(self): # with的时候触发，并赋给as变量 self.connect() return self def __exit__(self, exc_type, exc_val, exc_tb): # 离开with语句块时触发 self.finish()with MySQL() as mysql: mysql.execute() # 结果:# 启动数据库连接，申请系统资源# 执行sql命令，操作数据# 数据库连接关闭，清理系统资源 get、set、delete、描述符(研究中，待补充）1234567891011121314151617181920212223242526272829#描述符类(相当于代理)#定义为了数据描述符：定义了_set_ 和_get_方法的对象class Foo(): def __get__(self, instance, owner): print(&quot;执行Foo get方法&quot;) def __set__(self, instance, value): print(&quot;执行Foo set方法&quot;) def __delete__(self): print(&quot;执行Foo del方法&quot;)#主要运行的类:class Test(): #类的x属性被Foo代理,所以属性访问优先级也被修改: #类属性 &gt; 数据描述符 &gt; 实例属性 &gt; 非实例属性 &gt; __getattr__() x = Foo() def __init__(self,num): self.x = num#因为x类属性被Foo代理,触发Foo的set方法,而set方法只是打印了,没有做数据操作,abc = Test(100)abc.xprint(abc.__dict__)# print输出:-----------# 执行Foo set方法# 执行Foo get方法# &#123;&#125;# 执行Foo del方法# print输出:----------- 双下划线默认情况下，Python中的成员函数和成员变量都是公开的(相当于java中的public，或者OC中定义在.h文件中的公开成员变量)。在python中没有public,private等关键词来修饰成员函数和成员变量。为了区分，用下划线来体现。 (1)_xxx“单下划线 “ 开始的成员变量相当于私有变量，也叫做保护变量，意思是只有类实例和子类实例能访问到这些变量，需通过类提供的接口进行访问（可以定义有点像java中的getter、setter方法，借助方法访问，而不是直接对变量动刀子）；不能用’from module import *’导入。其实，Python并没有真正的私有化支持，用下划线得到的是伪私有，也就是说如果你强行要用也是可以的，但不符合python的规范。我们应该尽量避免重新定义以下划线开头的变量。 (2)末尾单下划线：var_在开发过种中，一个最合适的变量名称已经被一个关键字占用。因此像class、def这样的名称不能用作python中的变量名称。在这样的情况下，你可以使用在关键字未尾附加一个下划线来解决命名冲突问题。同样在PEP8中也对此约定进行了解释。 (3)单下划线：_python中单下划线和其它语言一样用来表示这个变量是临时的或无关紧要的，抛弃掉这个值。如在循环处理中，我们不需要列表中的索引值，就可以使用“_”抛弃掉此值。for _ in range(10):又如 在拆分元组为单独变量时候， 我们可以把不需要的值使用 _ 作为占位符变量进行抛弃。除了用作临时变量之外，“_”是大多数Python REPL中的一个特殊变量，它表示由解释器评估的最近一个表达式的结果。你可以在一个解释器会话中访问先前计算的结果，或者，你是在动态构建多个对象并与它们交互，无需事先给这些对象分配名字。 (4)__xxx双下划线：类中的私有变量/方法名 （Python的函数也是对象，所以成员方法称为成员变量也行得通）。” 双下划线 “ 开始的是私有成员，意思是只有类对象自己能访问，连子类对象也不能访问到这个数据。 (5)xxx系统定义名字，前后均有一个“双下划线” 代表python里特殊方法专用的标识，如 init（）代表类的构造函数。类似xxx这样的变量是特殊变量，可以被直接引用，但是有特殊用途，比如一个模块的author，name就是特殊变量，模块定义的文档注释（就是模块开头的字符串）也可以用特殊变量doc访问，我们自己的变量一般不要用这种变量名。 元类（选学）socket粘包异常处理主动触发异常123456789101112131415161718&gt;&gt;&gt; class ListNode(object):... def __init__(self,value):... self.val = value... self.next = None...&gt;&gt;&gt;&gt;&gt;&gt; a = ListNode(1)a.val&gt;&gt;&gt; class Li(ListNode):... a = 3... def __init__(self,value,a):... ListNode.__init__(self,value)... self.a = a...&gt;&gt;&gt;Li.a https://www.cnblogs.com/magicking/p/8971740.htmlhttps://www.cnblogs.com/zzzlw/p/9286828.html","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"类","slug":"类","permalink":"http://yoursite.com/tags/类/"}]},{"title":"python 网络通信","slug":"python-网络通信","date":"2019-05-18T04:32:36.000Z","updated":"2019-05-26T05:01:51.816Z","comments":true,"path":"2019/05/18/python-网络通信/","link":"","permalink":"http://yoursite.com/2019/05/18/python-网络通信/","excerpt":"","text":"网络编程中有两个主要的问题： 如何准确的定位网络上一台或多台主机 找到主机后如何可靠高效的进行数据传输 TCP/IP 套接字 创建套接字socket.socket([family[, type[, proto]]]) family: 套接字家族可以使AF_UNIX或者AF_INET type: 套接字类型可以根据是面向连接的还是非连接分为SOCK_STREAM（基于TCP）或SOCK_DGRAM（基于UDP） protocol: 一般不填默认为0. 常用函数sk.bind(address) s.bind(address) 将套接字绑定到地址。address地址的格式取决于地址族。在AF_INET下，以元组（host,port）的形式表示地址。 sk.listen(backlog) 开始监听传入连接。backlog指定在拒绝连接之前，可以挂起的最大连接数量。 backlog等于5，表示内核已经接到了连接请求，但服务器还没有调用accept进行处理的连接个数最大为5 这个值不能无限大，因为要在内核中维护连接队列 sk.accept() 接受连接并返回（conn,address）,其中conn是新的套接字对象，可以用来接收和发送数据。address是连接客户端的地址。 接收TCP 客户的连接（阻塞式）等待连接的到来 sk.connect(address) 连接到address处的套接字。一般，address的格式为元组（hostname,port）,如果连接出错，返回socket.error错误。 sk.close() 关闭套接字 sk.recv(bufsize[,flag]) 接受套接字的数据。数据以字符串形式返回，bufsize指定最多可以接收的数量。flag提供有关消息的其他信息，通常可以忽略。 sk.send(string[,flag]) 将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。即：可能未将指定内容全部发送。 struct模块有的时候需要用python处理二进制数据，比如，存取文件，socket操作时.这时候，可以使用python的struct模块来完成.可以用 struct来处理c语言中的结构体.一个字节 = 2个十六进制struct模块中最重要的三个函数是pack(), unpack(), calcsize() pack(fmt, v1, v2, …) 按照给定的格式(fmt)，把数据封装成字符串(实际上是类似于c结构体的字节流) unpack(fmt, string) 按照给定的格式(fmt)解析字节流string，返回解析出来的tuple calcsize(fmt) 计算给定的格式(fmt)占用多少字节的内存 struct中支持的格式如下表： Format C Type Python 字节数 x pad byte no value 1 c char string of length 1 1 b signed char integer 1 B unsigned char integer 1 ? _Bool bool 1 h short integer 2 H unsigned short integer 2 i int string of length 1 1 I unsigned int string of length 1 1 l long integer 4 L unsigned long long 4 q long long long 8 Q unsigned long long long 8 f float float 4 d double float 8 s char[] string 1 p char[] string 1 P void * long ? 注1.q和Q只在机器支持64位操作时有意思 注2.每个格式前可以有一个数字，表示个数 注3.s格式表示一定长度的字符串，4s表示长度为4的字符串，但是p表示的是pascal字符串 注4.P用来转换一个指针，其长度和机器字长相关 注5.最后一个可以用来表示指针类型的，占4个字节 为了同c中的结构体交换数据，还要考虑有的c或c++编译器使用了字节对齐，通常是以4个字节为单位的32位系统，故而struct根据本地机器字节顺序转换.可以用格式中的第一个字符来改变对齐方式.定义如下： Character Byte order Size and alignment @ native native 凑够4个字节 = native standard 按原字节数 &lt; little-endian standard 按原字节数 &gt; big-endian standard 按原字节数 ! network (= big-endian) standard 按原字节数 示例1234567&gt;&gt;&gt; import struct&gt;&gt;&gt; struct.pack(&apos;&lt;HH&apos;, 1,2)b&apos;\\x01\\x00\\x02\\x00&apos;&gt;&gt;&gt; struct.unpack(&apos;&lt;hh&apos;, bytes(b&apos;\\x01\\x00\\x00\\x00&apos;))(1, 0)&gt;&gt;&gt; struct.unpack(&apos;&lt;h&apos;, bytes(b&apos;\\x03\\x00&apos;))(3,) 示例一： 比如有一个结构体 struct Header { unsigned short id; char[4] tag; unsigned int version; unsigned int count; } 通过socket.recv接收到了一个上面的结构体数据，存在字符串s中，现在需要把它解析出来，可以使用unpack()函数. import struct id, tag, version, count = struct.unpack(“!H4s2I”, s) 上面的格式字符串中，!表示我们要使用网络字节顺序解析，因为我们的数据是从网络中接收到的，在网络上传送的时候它是网络字节顺序的.后面的H表示 一个unsigned short的id,4s表示4字节长的字符串，2I表示有两个unsigned int类型的数据. 就通过一个unpack，现在id, tag, version, count里已经保存好我们的信息了. 同样，也可以很方便的把本地数据再pack成struct格式. ss = struct.pack(“!H4s2I”, id, tag, version, count); pack函数就把id, tag, version, count按照指定的格式转换成了结构体Header，ss现在是一个字符串(实际上是类似于c结构体的字节流)，可以通过 socket.send(ss)把这个字符串发送出去. 示例二： import struct a=12.34 #将a变为二进制 bytes=struct.pack(‘i’,a) 此时bytes就是一个string字符串，字符串按字节同a的二进制存储内容相同。 再进行反操作 现有二进制数据bytes，（其实就是字符串），将它反过来转换成python的数据类型： a,=struct.unpack(‘i’,bytes) 注意，unpack返回的是tuple 所以如果只有一个变量的话： bytes=struct.pack(‘i’,a) 那么，解码的时候需要这样 a,=struct.unpack(‘i’,bytes) 或者 (a,)=struct.unpack(‘i’,bytes) 如果直接用a=struct.unpack(‘i’,bytes)，那么 a=(12.34,) ，是一个tuple而不是原来的浮点数了。 如果是由多个数据构成的，可以这样： a=’hello’ b=’world!’ c=2 d=45.123 bytes=struct.pack(‘5s6sif’,a,b,c,d) 此时的bytes就是二进制形式的数据了，可以直接写入文件比如 binfile.write(bytes) 然后，当我们需要时可以再读出来，bytes=binfile.read() 再通过struct.unpack()解码成python变量 a,b,c,d=struct.unpack(‘5s6sif’,bytes) ‘5s6sif’这个叫做fmt，就是格式化字符串，由数字加字符构成，5s表示占5个字符的字符串，2i，表示2个整数等等，下面是可用的字符及类型，ctype表示可以与python中的类型一一对应。 注意：二进制文件处理时会碰到的问题 我们使用处理二进制文件时，需要用如下方法 binfile=open(filepath,’rb’) 读二进制文件 binfile=open(filepath,’wb’) 写二进制文件 那么和binfile=open(filepath,’r’)的结果到底有何不同呢？ 不同之处有两个地方： 第一，使用’r’的时候如果碰到’0x1A’，就会视为文件结束，这就是EOF。使用’rb’则不存在这个问题。即，如果你用二进制写入再用文本读出的话，如果其中存在’0X1A’，就只会读出文件的一部分。使用’rb’的时候会一直读到文件末尾。 第二，对于字符串x=’abc\\ndef’，我们可用len(x)得到它的长度为7，\\n我们称之为换行符，实际上是’0X0A’。当我们用’w’即文本方式写的时候，在windows平台上会自动将’0X0A’变成两个字符’0X0D’，’0X0A’，即文件长度实际上变成8.。当用’r’文本方式读取时，又自动的转换成原来的换行符。如果换成’wb’二进制方式来写的话，则会保持一个字符不变，读取时也是原样读取。所以如果用文本方式写入，用二进制方式读取的话，就要考虑这多出的一个字节了。’0X0D’又称回车符。linux下不会变。因为linux只使用’0X0A’来表示换行。 大小端以及字节序的问题网络字节顺序NBO（Network Byte Order）：按从高到低的顺序存储，在网络上使用统一的网络字节顺序，可以避免兼容性问题。 The order in which the bytes of a multi-byte number are transmitted on a network - most significant byte first (as in “big-endian” storage). 主机字节顺序（HBO，Host Byte Order）：不同的机器HBO不相同，与CPU设计有关计算机数据存储有两种字节优先顺序：高位字节优先和低位字节优先。 [struct] (https://docs.python.org/3/library/struct.html)[关于int，unsigned int , short的关系与跨平台应用及char,int,float等类型在不同平台下所占字节数] (https://blog.csdn.net/bzhxuexi/article/details/19551979) 单线程通信 该实例中，只能 client 发一句， server回一句（先启动server，后启动client） 1234567891011121314151617181920#!/usr/bin/env python# -*- coding:utf-8 -*-import socketif __name__ == &apos;__main__&apos;: sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) #ipv4, TCP sock.bind((&apos;0.0.0.0&apos;,5000)) #元组,相当于一个参数 sock.listen(10) #同时保持是十个人的连接 conn, addr = sock.accept() while True: data = conn.recv(1024) #最多1K的数据 print(data) if data == &apos;bye&apos;: break else: msg = raw_input(&quot;&gt;&gt;&quot;) conn.send(msg) sock.close() print(&apos;Bye!!&apos;) Client1234567891011121314151617#!/usr/bin/env python# -*- coding:utf-8 -*-import socket, timeif __name__ == &apos;__main__&apos;: sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) sock.connect((&apos;localhost&apos;,5000)) while True: msg = raw_input(&quot;&gt;&gt;&quot;) if msg == &quot;bye&quot;: sock.send(msg) sock.close() break else: sock.send(msg) data = sock.recv(1024) 多线程通信 在该实例中可以自由发送和接收信息（先启动server，后启动client） 利用threading，多线程进行接受消息和发送消息 callback_recv函数负责接受信息的功能 callback_send函数负责发送信息的功能 123456789101112131415161718192021222324252627282930313233343536373839#!/usr/bin/env python# -*- coding:utf-8 -*-import socket, threading, sysdef callback_send(conn): &apos;&apos;&apos; :param sq: :return: &apos;&apos;&apos; while True: #为了维持持续的发送 msg = raw_input(&quot;&gt;&gt;&quot;) conn.send(msg)def callback_recv(conn): &apos;&apos;&apos; :param sock: :return: &apos;&apos;&apos; while True: #为了维持持续的接收 data = conn.recv(1024) print(data)if __name__ == &apos;__main__&apos;: sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) sock.bind((&apos;0.0.0.0&apos;,5000)) #元组,相当于一个参数 sock.listen(10) #同时保持是十个人的连接 conn, addr = sock.accept() thread_send = threading.Thread(target=callback_send, args=(conn, )) thread_recv = threading.Thread(target=callback_recv, args=(conn, )) thread_send.start() thread_recv.start() sock.close() client 12345678910111213141516171819202122232425262728293031323334353637383940414243#!/usr/bin/env python# -*- coding:utf-8 -*-import socket, time, threading, sysdef callback_send(sock): &apos;&apos;&apos; :param sq: :return: &apos;&apos;&apos; while True: msg = raw_input(&quot;&gt;&gt;&quot;) sock.send(msg) # if msg in [&apos;bye&apos;, &apos;quit&apos;]: # sock.close # breakdef callback_recv(sock): &apos;&apos;&apos; :param sock: :return: &apos;&apos;&apos; while True: data = sock.recv(1024) print(data)if __name__ == &apos;__main__&apos;: sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) sock.connect((&apos;localhost&apos;,5000)) thread_send = threading.Thread(target=callback_send, args=(sock, )) thread_recv = threading.Thread(target=callback_recv, args=(sock, )) thread_send.start() thread_recv.start() while True: pass sock.close() UDP 123456789101112131415161718192021222324252627282930313233343536373839404142434445import socketdef send_msg(udp_socket): # 获取输入 msg = input(&quot;请输入要发送的数据：&quot;) # 输入对方IP dest_ip = input(&quot;请输入对方ip：&quot;) # 输入对方port dest_port = int(input(&quot;请输入对方端口：&quot;)) # 编码 udp_b = msg.encode(&apos;utf-8&apos;) # 发送数据 udp_socket.sendto(udp_b,(dest_ip,dest_port))def recv_msg(udp_socket): recv_msg = udp_socket.recvfrom(1024) # 解码 # udp_j = recv_msg.decode(&apos;utf-8&apos;) # 显示 recv_msg = recv_msg[0].decode(&apos;utf-8&apos;) print(recv_msg)def main(): # 创建套接字 udp_socket = socket.socket(socket.AF_INET,socket.SOCK_DGRAM) # 绑定本地信息 udp_socket.bind((&quot;&quot;,7789)) while True: print(&quot;=&quot; * 30) print(&quot;1.发送消息&quot;) print(&quot;2.接收消息&quot;) print(&quot;0.退出聊天&quot;) op_num = input(&quot;请输入要操作的功能：&quot;) if op_num == &quot;1&quot;: send_msg(udp_socket) elif op_num == &quot;2&quot;: recv_msg(udp_socket) elif op_num == &quot;0&quot;: break else: print(&quot;输入有误，请重新输入&quot;) udp_socket.close()if __name__== main(): main() HTTP int与IP转换123456789101112131415&gt;&gt;&gt; import socket,struct&gt;&gt;&gt; int_ip = 123456789&gt;&gt;&gt; socket.inet_ntoa(struct.pack(‘I’,socket.htonl(int_ip)))#整数转换为ip地址’7.91.205.21′&gt;&gt;&gt; str(socket.ntohl(struct.unpack(“I”,socket.inet_aton(“255.255.255.255″))[0]))#ip地址转换为整数’4294967295′实际上也就是进制数的转换用lambda的方式，int2ip一行代码搞定&gt;&gt;&gt; int2ip = lambda x: &apos;.&apos;.join([str(x/(256**i)%256) for i in range(3,-1,-1)])&gt;&gt;&gt; int2ip(123456789)’7.91.205.21′用lambda的方式，ip2int&gt;&gt;&gt; ip2int = lambda x:sum([256**j*int(i) for j,i in enumerate(x.split(&apos;.&apos;)[::-1])])&gt;&gt;&gt; ip2int(&apos;7.91.205.21&apos;)123456789 request模块requests模块是python的一个第三方模块，它是基于python自带的urllib模块封装的，用来发送http请求和获取返回的结果，操作很简单。需要自己安装 pip install requests 1234567891011121314151617181920 pa = &#123;&apos;query&apos;:&apos;&apos;&apos;&#123;... id... name... age... isKid... &#125;... &apos;&apos;&apos;&#125;&gt;&gt;&gt; res = requests.post(url=url, params=pa)&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; res.contentb&apos;&#123;&quot;data&quot;:&#123;&quot;id&quot;:123,&quot;name&quot;:&quot;jack&quot;,&quot;age&quot;:10,&quot;isKid&quot;:true&#125;&#125;&apos;&gt;&gt;&gt; res.cookies&lt;RequestsCookieJar[]&gt;&gt;&gt;&gt; res.json&lt;bound method Response.json of &lt;Response [200]&gt;&gt;&gt;&gt;&gt; res.json()&#123;&apos;data&apos;: &#123;&apos;age&apos;: 10, &apos;id&apos;: 123, &apos;isKid&apos;: True, &apos;name&apos;: &apos;jack&apos;&#125;&#125;&gt;&gt;&gt;","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"Python 网络通信","slug":"Python-网络通信","permalink":"http://yoursite.com/tags/Python-网络通信/"}]},{"title":"python 线程","slug":"python-线程","date":"2019-05-18T04:32:36.000Z","updated":"2019-05-28T16:17:39.599Z","comments":true,"path":"2019/05/18/python-线程/","link":"","permalink":"http://yoursite.com/2019/05/18/python-线程/","excerpt":"","text":"子线程强制终止子线程的强制性终止是我们实际应用时经常需要用到的，然而python官方并没有给出相关的函数来处理这种情况。http://stackoverflow.com/questions/323972/is-there-any-way-to-kill-a-thread-in-python1234567891011121314151617def _async_raise(tid, exctype): &quot;&quot;&quot;raises the exception, performs cleanup if needed&quot;&quot;&quot; tid = ctypes.c_long(tid) if not inspect.isclass(exctype): exctype = type(exctype) res = ctypes.pythonapi.PyThreadState_SetAsyncExc(tid, ctypes.py_object(exctype)) if res == 0: raise ValueError(&quot;invalid thread id&quot;) elif res != 1: # &quot;&quot;&quot;if it returns a number greater than one, you&apos;re in trouble, # and you should call it again with exc=NULL to revert the effect&quot;&quot;&quot; ctypes.pythonapi.PyThreadState_SetAsyncExc(tid, None) raise SystemError(&quot;PyThreadState_SetAsyncExc failed&quot;)def stop_thread(thread): _async_raise(thread.ident, SystemExit) 线程的暂停, 恢复, 退出我们都知道python中可以是threading模块实现多线程, 但是模块并没有提供暂停, 恢复和停止线程的方法, 一旦线程对象调用start方法后, 只能等到对应的方法函数运行完毕.也就是说一旦start后, 线程就属于失控状态. 不过, 我们可以自己实现这些. 一般的方法就是循环地判断一个标志位, 一旦标志位到达到预定的值, 就退出循环. 这样就能做到退出线程了.但暂停和恢复线程就有点难了, 我一直也不清除有什么好的方法, 直到我看到threading中Event对象的wait方法的描述时. Block until the internal flag is true. If the internal flag is true on entry, return immediately. Otherwise, block until another thread calls set() to set the flag to true, or until the optional timeout occurs. 阻塞, 直到内部的标志位为True时. 如果在内部的标志位在进入时为True时, 立即返回. 否则, 阻塞直到其他线程调用set()方法将标准位设为True, 或者到达了可选的timeout时间. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). 当给定了timeout参数且不为None, 它应该是一个浮点数，以秒为单位指定操作的超时（或是分数）。 This method returns the internal flag on exit, so it will always return True except if a timeout is given and the operation times out. 此方法在退出时返回内部标志，因此除非给定了超时且操作超时，否则它将始终返回True。 Changed in version 2.7: Previously, the method always returned None. 2.7版本以前, 这个方法总会返回None. 利用wait的阻塞机制, 就能够实现暂停和恢复了, 再配合循环判断标识位, 就能实现退出了, 下面是代码示例: 1234567891011121314151617181920212223242526272829303132333435363738import threadingimport timeclass Job(threading.Thread): def __init__(self, *args, **kwargs): super(Job, self).__init__(*args, **kwargs) self.__flag = threading.Event() # 用于暂停线程的标识 self.__flag.set() # 设置为True self.__running = threading.Event() # 用于停止线程的标识 self.__running.set() # 将running设置为True def run(self): while self.__running.isSet(): self.__flag.wait() # 为True时立即返回, 为False时阻塞直到内部的标识位为True后返回 print(time.time()) time.sleep(1) def pause(self): self.__flag.clear() # 设置为False, 让线程阻塞 def resume(self): self.__flag.set() # 设置为True, 让线程停止阻塞 def stop(self): self.__flag.set() # 将线程从暂停状态恢复, 如何已经暂停的话 self.__running.clear() # 设置为Falsea.start()time.sleep(3)a.pause()time.sleep(3)a.resume()time.sleep(3)a.pause()time.sleep(2)a.stop() 协程Callback早就有Twisted，新生代也有Tornado，Coroutine有Gevent，Actor有Pulsar，VM方面要稳妥CPython，要性能PYPY，要并发Stackless，AIO神马的的选择太多。cyclone在Python中，一个异步的函数我们通常叫它协程。之前我们在讲解yield的时候也已经讲过yield语法在协程中的基本使用了，这次同样是协程，但却是不同的语法。1234567891011121314#在Python 3.4中, 创建一个协程我们用asyncio.coroutine装饰器:async def double(x): return x * 2# 这是个协程对象&gt;&gt;&gt; double(6)&gt;&gt;&gt;&lt;coroutine object double at 0x115b59d58&gt;# 既然是协程，我们像之前yield协程那样，预激活一下(注意这里用next(double(6)预激活会报错)&gt;&gt;&gt; double(6).send(None)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;StopIteration: 12# 好像差不多。 asyncio的几个重要结构 event loop: An event loop essentially manages and distributes the execution of different tasks. It registers them and handles distributing the flow of control between them. Coroutines Coroutines are special functions that work similarly Python generators that on await they release the flow of control back to the event loop. A coroutine needs to be scheduled to run using the event loop, to do this we create a Task, which is a type of Future.Futures： Futures are objects that represent the result of a task that may or may not have been executed. This result may be an exception. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import asyncioimport timestart = time.time()def tic(): return &apos;at %1.1f seconds&apos; % (time.time() - start)async def gr1(): # Busy waits for a second, but we don&apos;t want to stick around... print(&apos;gr1 started work: &#123;&#125;&apos;.format(tic())) # 暂停两秒，但不阻塞时间循环，下同 await asyncio.sleep(2) print(&apos;gr1 ended work: &#123;&#125;&apos;.format(tic()))async def gr2(): # Busy waits for a second, but we don&apos;t want to stick around... print(&apos;gr2 started work: &#123;&#125;&apos;.format(tic())) await asyncio.sleep(2) print(&apos;gr2 Ended work: &#123;&#125;&apos;.format(tic()))async def gr3(): print(&quot;Let&apos;s do some stuff while the coroutines are blocked, &#123;&#125;&quot;.format(tic())) await asyncio.sleep(1) print(&quot;Done!&quot;)# 事件循环ioloop = asyncio.get_event_loop()# tasks中也可以使用asyncio.ensure_future(gr1())..tasks = [ ioloop.create_task(gr1()), ioloop.create_task(gr2()), ioloop.create_task(gr3())]ioloop.run_until_complete(asyncio.wait(tasks))ioloop.close()output： gr1 started work: at 0.0 seconds gr2 started work: at 0.0 seconds Let&apos;s do some stuff while the coroutines are blocked, at 0.0 seconds Done! gr2 Ended work: at 2.0 seconds gr1 ended work: at 2.0 seconds event loop 流程图","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"Python 线程","slug":"Python-线程","permalink":"http://yoursite.com/tags/Python-线程/"}]},{"title":"python pstuil","slug":"python-常用模块psutil","date":"2019-05-18T04:32:36.000Z","updated":"2019-05-23T03:21:39.685Z","comments":true,"path":"2019/05/18/python-常用模块psutil/","link":"","permalink":"http://yoursite.com/2019/05/18/python-常用模块psutil/","excerpt":"","text":"psutil模块介绍psutil是一个跨平台库（http://code.google.com/p/psutil/），能够轻松实现获取系统运行的进程和系统利用率（包括CPU、内存、磁盘、网络等）信息。它主要应用于系统监控，分析和限制系统资源及进程的管理。它实现了同等命令行工具提供的功能，如ps、top、lsof、netstat、ifconfig、who、df、kill、free、nice、ionice、iostat、iotop、uptime、pidof、tty、taskset、pmap等。目前支持32位和64位的Linux、Windows、OS X、FreeBSD和Sun Solaris等操作系统。 安装wget https://pypi.python.org/packages/source/p/psutil/psutil-2.0.0.tar.gz tar -xzvf psutil-2.0.0.tar.gz cd psutil-2.0.0 python setup.py install 使用获取系统性能信息（CPU,内存，磁盘，网络） CPU相关查看cpu信息 import Psutil查看cpu所有信息 psutil.cpu_times()scputimes(user=11677.09, nice=57.93, system=148675.58, idle=2167147.79, iowait=260828.48, irq=7876.28, softirq=0.0, steal=3694.59, guest=0.0, guest_nice=0.0)显示cpu所有逻辑信息 psutil.cpu_times(percpu=True)[scputimes(user=11684.17, nice=57.93, system=148683.01, idle=2168982.08, iowait=260833.18, irq=7882.35, softirq=0.0, steal=3697.3, guest=0.0, guest_nice=0.0)]查看用户的cpu时间比 psutil.cpu_times().user11684.4查看cpu逻辑个数 psutil.cpu_count()1查看cpu物理个数 psutil.cpu_count(logical=False)1 查看系统内存 import psutilmem = psutil.virtual_memory()mem 系统内存的所有信息svmem(total=1040662528, available=175054848, percent=83.2, used=965718016, free=74944512, active=566755328, inactive=59457536, buffers=9342976, cached=90767360)系统总计内存 mem.total1040662528系统已经使用内存 mem.used965718016系统空闲内存 mem.free112779264获取swap内存信息 psutil.swap_memory()sswap(total=0, used=0, free=0, percent=0, sin=0, sout=0) 读取磁盘参数磁盘利用率使用psutil.disk_usage方法获取， 磁盘IO信息包括read_count(读IO数)，write_count(写IO数)read_bytes(IO写字节数)，read_time(磁盘读时间)，write_time(磁盘写时间),这些IO信息用 psutil.disk_io_counters()获取磁盘的完整信息 psutil.disk_partitions()获取分区表的参数 psutil.disk_usage(‘/‘) #获取/分区的状态获取硬盘IO总个数 psutil.disk_io_counters()获取单个分区IO个数 psutil.disk_io_counters(perdisk=True) #perdisk=True参数获取单个分区IO个数 读取网络信息网络信息与磁盘IO信息类似,涉及到几个关键点，包括byes_sent(发送字节数),byte_recv=xxx(接受字节数),pack-ets_sent=xxx(发送数据包数),pack-ets_recv=xxx(接收数据包数)。 获取网络总IO信息 psutil.net_io_counters()输出网络每个接口信息 psutil.net_io_counters(pernic=True) #pernic=True获取当前系统用户登录信息 psutil.users()获取开机时间 psutil.boot_time() #以linux时间格式返回 datetime.datetime.fromtimestamp(psutil.boot_time ()).strftime(“%Y-%m-%d %H: %M: %S”) #转换成自然时间格式 系统进程管理获取当前系统的进程信息,获取当前程序的运行状态,包括进程的启动时间,查看设置CPU亲和度,内存使用率,IO信息socket连接,线程数等获取进程信息 查看系统全部进程 psutil.pids()查看单个进程 p = psutil.Process(2423)p.name() #进程名p.exe() #进程的bin路径p.cwd() #进程的工作目录绝对路径p.status() #进程状态p.create_time() #进程创建时间p.uids() #进程uid信息p.gids() #进程的gid信息p.cpu_times() #进程的cpu时间信息,包括user,system两个cpu信息p.cpu_affinity() #get进程cpu亲和度,如果要设置cpu亲和度,将cpu号作为参考就好p.memory_percent() #进程内存利用率p.memory_info() #进程内存rss,vms信息p.io_counters() #进程的IO信息,包括读写IO数字及参数p.connectios() #返回进程列表p.num_threads() #进程开启的线程数听过psutil的Popen方法启动应用程序，可以跟踪程序的相关信息from subprocess import PIPEp = psutil.Popen([“/usr/bin/python”, “-c”, “print(‘hello’)”],stdout=PIPE)p.name()p.username()","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"Python psutil","slug":"Python-psutil","permalink":"http://yoursite.com/tags/Python-psutil/"}]},{"title":"python 数学函数","slug":"python-数学函数","date":"2019-05-18T04:32:36.000Z","updated":"2019-05-27T13:29:53.451Z","comments":true,"path":"2019/05/18/python-数学函数/","link":"","permalink":"http://yoursite.com/2019/05/18/python-数学函数/","excerpt":"","text":"四舍五入round(4.54,1) 向上取整import math math.ceil(4.1) = 5 向下取整math.floor(4.9) = 4 忽略小数点int(3.215)","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"数学函数","slug":"数学函数","permalink":"http://yoursite.com/tags/数学函数/"}]},{"title":"挣值分析","slug":"项目管理-挣值分析","date":"2019-04-19T04:08:36.000Z","updated":"2019-04-22T05:46:34.653Z","comments":true,"path":"2019/04/19/项目管理-挣值分析/","link":"","permalink":"http://yoursite.com/2019/04/19/项目管理-挣值分析/","excerpt":"","text":"挣值分析挣值分析的三个基本参数包括: 计划值（PV）、实际成本（AC）、和挣值（EV）。四个评价指标包括:进度偏差（SV）、成本偏差（CV）、成本执行指标(CPI)和进度执行指标（SPI）。 基本参数1、 计划价值（Plan Value）。又叫（BCWS,Budgeted Cost for work scheduled)计划工作量的预算费用。是指项目实施过程中某阶段计划要求完成的工作量所需的预算工时（或费用）。 计算公式 PV = BCWS = 计划工作量 计划单价。 PV的总和有时被称为绩效测量基准（PMB）。项目的总计划价值又被称为完工预算（BAC）2、 实际成本（Actual Cost）。又叫（ACWP, Actual Cost for Work Performed）。是指项目实施过程中某阶段实际完成的工作量所消耗的工时（或费用）。 AC = ACWP = 已完成工作量 实际单价3、 挣值（EV，Earned Value），又叫（BCWP，Budgeted Cost for Work Performed）已完成工作量的预算成本。 EV = BCWP = 已完成工作量 * 计划单价 评价指标挣值分析法的四个评价指标：进度偏差（SV）、成本偏差（CV）、成本执行指标（CPI）和进度执行指标（SPI）：1、进度偏差（SV，Schedule Variance）SV是指检查日期EV和PV之间的差异：SV=EV-PV=BCWP-BCWS当SV为正值时，表示进度提前；当SV等于零时，表示实际与计划相符。当SV为负值时，表示进度延误。2、成本偏差（CV，Cost Variance）。CV是指检查期间EV和AC之间的差异：CV=EV-AC=BCWP-ACWP当CV为正值时，表示实际消耗的人工（或费用）低于预算值，即有结余或效率高；当CV等于零时，表示实际消耗的人工（或费用）等于预算值；当CV为负值时，表示实际消耗的人工（或费用）超出预算值或超支。3、成本执行指标（CPI，Cost Performed Index）。指项目挣值与实际费用之比（或工时值之比）：CPI=EV/AC=BCWP/ACWP当CPI&gt;1时，表示低于预算，即实际费用低于预算费用；当CPI=1时，表示实际费用与预算费用吻合；当CPI&lt;1时，表示超出预算，即实际费用高于预算费用；4、进度绩效指标（Schedule Performed Index）。指项目挣值与计划值之比：SPI=EV/PV=BCWP/BCWS当SPI&gt;1时，表示进度超前当SPI=1时，表示实际进度与计划进度相同当SPI&lt;1时，表示进度延误挣值管理是项目管理的一种方法，主要用于项目成本和进度的监控挣值通过项目开始时的计划与所完成的工作进行比较，给出了一个项目何时完工的估算，通过从项目已经完工的部分进行推算，项目经理可以估计出项目完工的时候，将会花费多少资源。这项技术基于关键路径的概念。另一个项目绩效测量和管理技术是关键链，它使用的是缓冲管理。原因是挣值管理方法不能区别基于项目约束（例如：项目的关键链）的进度和基于非约束（例如：项目路径网络中的其他路径）的进度，这在某些时候会造成项目经理为了追求更好的挣值测量，而以关键任务成本来急于完成非关键的任务，导致项目完工的推延。这是一个局部最优的例子，问题在于缺乏局部测量与整体测量的从属关系。为了在项目中应用挣值方法，项目经理需要下列首要数据：工作分解结构 (WBS): 以层次化分解的所有任务的列表。项目主进度计划(PMS): 关于那些任务将完成以及谁完成的甘特图计划完成的工作的预计成本(计划值): 每一个周期预计当前完成的工作的预算。实际完成的工作的预计成本(挣值): 每一个周期当前实际完成的工作的预算。实际完成的工作的实际成本(实际成本): 每一个周期工作的实际成本。项目总预算(BAC): 预计用于完成项目所花费的总预算。","categories":[{"name":"项目管理","slug":"项目管理","permalink":"http://yoursite.com/categories/项目管理/"}],"tags":[{"name":"挣值分析","slug":"挣值分析","permalink":"http://yoursite.com/tags/挣值分析/"}]},{"title":"项目整合管理","slug":"项目管理-过程组和知识领域","date":"2019-04-19T04:08:36.000Z","updated":"2019-04-19T05:20:55.973Z","comments":true,"path":"2019/04/19/项目管理-过程组和知识领域/","link":"","permalink":"http://yoursite.com/2019/04/19/项目管理-过程组和知识领域/","excerpt":"","text":"知识领域 项目管理过程组 启动过程组 规划过程组 执行过程组 监控过程组 收尾过程组 项目整合管理 制定项目章程 制定项目管理计划 指导与管理项目工作 管理项目知识 监控项目工作 实施整体变更控制 结束项目或阶段 项目范围管理 规划范围管理 收集需求 定义范围 创建WBS 确认范围 控制范围 项目进度管理 规划进度管理 定义活动 排列活动次序 估算活动持续时间 制定进度计划 控制进度 项目成本管理 规划成本管理 估算成本 制定预算 控制成本 项目质量管理 规划质量管理 管理质量 控制质量 项目资源管理 规划资源管理 估算活动资源 获取资源 建设团队 管理团队 控制资源 项目沟通管理 规划沟通管理 管理沟通 监督沟通 项目风险管理 规划风险管理 识别风险 实施定性风险分析 实施定量风险分析 规划风险应对 实施风险应对 监督风险 项目采购管理 规划采购管理 实施采购 控制采购 项目相关方管理 识别相关方 规划相关方参与 管理相关方参与 监督相关方参与","categories":[{"name":"项目管理","slug":"项目管理","permalink":"http://yoursite.com/categories/项目管理/"}],"tags":[{"name":"过程组","slug":"过程组","permalink":"http://yoursite.com/tags/过程组/"},{"name":"知识领域","slug":"知识领域","permalink":"http://yoursite.com/tags/知识领域/"}]},{"title":"项目管理计划","slug":"项目管理-项目管理计划","date":"2019-04-19T04:08:36.000Z","updated":"2019-04-25T08:00:40.586Z","comments":true,"path":"2019/04/19/项目管理-项目管理计划/","link":"","permalink":"http://yoursite.com/2019/04/19/项目管理-项目管理计划/","excerpt":"","text":"项目管理计划","categories":[{"name":"项目管理","slug":"项目管理","permalink":"http://yoursite.com/categories/项目管理/"}],"tags":[{"name":"项目管理计划","slug":"项目管理计划","permalink":"http://yoursite.com/tags/项目管理计划/"}]},{"title":"python 项目目录","slug":"python-项目目录","date":"2019-03-22T10:32:36.000Z","updated":"2019-04-30T04:05:07.443Z","comments":true,"path":"2019/03/22/python-项目目录/","link":"","permalink":"http://yoursite.com/2019/03/22/python-项目目录/","excerpt":"","text":"一般项目的目录结构project_name log conf project_name #core libs/modules docs README install python3 setup.py install setup.py bin/ start_project.py requirements.txt #pip install requirements pip freeze #列出所有的模块","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"项目目录","slug":"项目目录","permalink":"http://yoursite.com/tags/项目目录/"}]},{"title":"python 高阶函数的使用","slug":"python-高阶函数的应用","date":"2019-03-22T10:32:36.000Z","updated":"2019-05-01T00:09:47.375Z","comments":true,"path":"2019/03/22/python-高阶函数的应用/","link":"","permalink":"http://yoursite.com/2019/03/22/python-高阶函数的应用/","excerpt":"","text":"zip,map,filter,reduce,sorted，列表推导式。 12345678910111213141516171819columns = [&apos;id&apos;,&apos;name&apos;,&apos;age&apos;,&apos;phone&apos;,&apos;dept&apos;,&apos;enrolled_date&apos;]with open(r&apos;staff_db.txt&apos;,&apos;r&apos;,encoding=&apos;utf-8&apos;) as fp: staff_list = [line.strip().split(&apos;,&apos;) for line in fp] # 列表结构形式员工信息data = dict(zip(columns, map(list, zip(*staff_list)))) # 将员工信息存到如下结构中data=&#123;&apos;id&apos;: [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;],&apos;name&apos;: [&apos;Li&apos;, &apos;Wang&apos;, &apos;Rain&apos;],&apos;age&apos;: [&apos;22&apos;, &apos;28&apos;, &apos;21&apos;],&apos;phone&apos;: [&apos;13651054608&apos;, &apos;13451024608&apos;, &apos;13451054608&apos;],&apos;dept&apos;: [&apos;IT&apos;, &apos;HR&apos;, &apos;IT&apos;],&apos;enrolled_date&apos;: [&apos;2013-04-01&apos;, &apos;2015-01-07&apos;, &apos;2017-04-01&apos;]&#125;info=list(zip(data[&apos;age&apos;],data[&apos;phone&apos;],data[&apos;dept&apos;],data[&apos;enrolled_date&apos;],data[&apos;name&apos;],data[&apos;id&apos;]))res=(&apos; &apos;.join(info[0])) 字典的查询速度是比较快的","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"高阶函数","slug":"高阶函数","permalink":"http://yoursite.com/tags/高阶函数/"}]},{"title":"python 多分支判断","slug":"python-多分支判断","date":"2019-03-22T10:32:36.000Z","updated":"2019-04-30T23:44:43.446Z","comments":true,"path":"2019/03/22/python-多分支判断/","link":"","permalink":"http://yoursite.com/2019/03/22/python-多分支判断/","excerpt":"","text":"python中没有switch语句，可以考虑字典的映射关系来实现多分支判断。 123456789101112131415swtich_dic=&#123;&quot;add&quot;:add_info,&quot;del&quot;:del_info,&quot;find&quot;:find_info,&quot;update&quot;:update_info&#125;while True: cmd=input(&apos;&gt;&gt;：&apos;).strip().lower().split() if not cmd:continue if cmd in func_dic: func = switch_dic.get(cmd) func() 实现功能以后,可以用极限法看看代码有没有优化的地方,就比如这个分支判断，如果用极限法放大分支数量,就会发现用字典的优势了,还有数据,如果数据量比较大的话,也是一样的","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"多分支判断","slug":"多分支判断","permalink":"http://yoursite.com/tags/多分支判断/"}]},{"title":"python 增删改查操作","slug":"python-增删改查","date":"2019-03-22T10:32:36.000Z","updated":"2019-04-30T04:12:51.113Z","comments":true,"path":"2019/03/22/python-增删改查/","link":"","permalink":"http://yoursite.com/2019/03/22/python-增删改查/","excerpt":"","text":"字符串查找find替换replacestrip()eval列表查找增加更新删除字典查找增加更新删除集合查找增加更新删除文件查找增加更新删除Json","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"增删改查","slug":"增删改查","permalink":"http://yoursite.com/tags/增删改查/"}]},{"title":"python 常用模块","slug":"python-常用模块","date":"2019-03-21T10:32:36.000Z","updated":"2019-05-04T11:48:42.877Z","comments":true,"path":"2019/03/21/python-常用模块/","link":"","permalink":"http://yoursite.com/2019/03/21/python-常用模块/","excerpt":"","text":"模块python中，一个py文件就是一个模块 避免函数名和变量名冲突。提高代码可维护性，可重用 模块分类模块分三种 内置标准模块（又称标准库）执行help(‘modules’)查看所有python自带模块列表 第三方开源模块，可通过pip install 模块名 安装 自定义模块 模块一旦被调用，执行了文件里的程序模块安装 模块路径 sys.path 卸载模块 pip3 uninstall modules 国内源安装 pip3 install -i http://pypi.douban.com/simple/ modules –trusted-host pypi.douban.com 模块导入执行文件的目录为当前目录 python2中文件夹中增加__init__.py,将文件夹变成包 导入路径，动态识别当前路径12345678910111213import sys,osprint(dir())print(__file__)#相对路径#BASE_DIR = os.path.dirname(os.path.dirname(__file__))#sys.path.append()#绝对路径os.path.abspath(__file__)BASE_DIR = os.path.dirname(os.path.abspath(__file__))sys.path.append(BASE_DIR)#相对路径 # from . import models# 相对导入不能存在程序主入口 time与datetime模块在python中，通常3种时间的表示 时间戳(timestamp)：通常来说，时间戳表示的是从1970年1月1日00:00:00开始按秒计算的偏移量。我们运行“type(time.time())”，返回的是float类型。 格式化的时间字符串(Format String) 结构化的时间(struct_time)：struct_time元组共有9个元素共九个元素:(年，月，日，时，分，秒，一年中第几周，一年中第几天，夏令时) 123456789101112131415161718192021222324252627282930import timeprint(time.time())# 时间戳:1546273960.5988934 print(time.localtime())#本地时区的struct_time time.struct_time(tm_year=2019, tm_mon=1, tm_mday=1, tm_hour=0, tm_min=32, tm_sec=40, tm_wday=1, tm_yday=1, tm_isdst=0)print(time.localtime(1546273960.5988934))#time.struct_time(tm_year=2019, tm_mon=1, tm_mday=1, tm_hour=0, tm_min=32, tm_sec=40, tm_wday=1, tm_yday=1, tm_isdst=0) print(time.gmtime())#UTC时区的struct_time time.struct_time(tm_year=2018, tm_mon=12, tm_mday=31, tm_hour=16, tm_min=32, tm_sec=40, tm_wday=0, tm_yday=365, tm_isdst=0)print(time.gmtime(1546273960.5988934))#UTC时区的struct_time time.struct_time(tm_year=2018, tm_mon=12, tm_mday=31, tm_hour=16, tm_min=32, tm_sec=40, tm_wday=0, tm_yday=365, tm_isdst=0) print(time.mktime(time.localtime()))#将一个结构化struct_time转化为时间戳。#1546274313.0 print(time.strftime(&quot;%Y-%m-%d %X&quot;))#格式化的时间字符串:&apos;2019-01-01 00:32:40&apos;print(time.strftime(&quot;%Y-%m-%d %X&quot;, time.localtime()))#格式化的时间字符串:&apos;2019-01-01 00:32:40&apos; print(time.strptime(&apos;2018-08-08 16:37:06&apos;, &apos;%Y-%m-%d %X&apos;))#把一个格式化时间字符串转化为struct_time。实际上它和strftime()是逆操作。 time.struct_time(tm_year=2018, tm_mon=8, tm_mday=8, tm_hour=16, tm_min=37, tm_sec=6, tm_wday=2, tm_yday=220, tm_isdst=-1)#%z#%Z#%w#%U#%ptime.sleep(5)#线程推迟指定的时间运行，单位为秒。 asctime/ctime 123456import timeprint(time.asctime())#Tue Jan 1 00:53:00 2019print(time.asctime(time.localtime()))#Tue Jan 1 00:55:00 2019 print(time.ctime()) # Tue Jan 1 00:53:00 2019print(time.ctime(time.time())) # Tue Jan 1 00:53:00 2019 时间加减123456789101112import datetime,time print(datetime.datetime.now()) #返回 2019-01-01 00:56:58.771296print(datetime.date.fromtimestamp(time.time()) ) # 时间戳直接转成日期格式 2019-01-01 print(datetime.datetime.now() + datetime.timedelta(3)) #当前时间+3天 2019-01-04 00:56:58.771296print(datetime.datetime.now() + datetime.timedelta(-3)) #当前时间-3天 2018-12-29 00:56:58.771296print(datetime.datetime.now() + datetime.timedelta(hours=3)) #当前时间+3小时 2019-01-01 03:56:58.771296print(datetime.datetime.now() + datetime.timedelta(minutes=30)) #当前时间+30分 2019-01-01 01:26:58.771296 c_time = datetime.datetime.now()print(c_time.replace(minute=3,hour=2)) #时间替换 2019-01-01 02:03:58.771296 random模块1234567import randomprint(random.random()) # (0,1)----float 大于0且小于1之间的小数print(random.randint(1, 3)) # [1,3] 大于等于1且小于等于3之间的整数print(random.randrange(1, 3)) # [1,3) 大于等于1且小于3之间的整数print(random.choice([1, &apos;23&apos;, [4, 5]])) # 1或者23或者[4,5]print(random.sample([1, &apos;23&apos;, [4, 5]], 2)) # 列表元素任意2个组合print(random.uniform(1, 3)) # 大于1小于3的小数，如1.927109612082716 12345678910import randomdef make_code(n): res=&apos;&apos; for i in range(n): alf=chr(random.randint(65,90)) num=str(random.randint(0,9)) res+=random.choice([alf,num]) return res print(make_code(6)) os模块os模块是与操作系统交互的一个接口123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960os.getcwd() 获取当前工作目录，即当前python脚本工作的目录路径os.chdir(&quot;dirname&quot;) 改变当前脚本工作目录；相当于shell下cdos.curdir 返回当前目录: (&apos;.&apos;)os.pardir 获取当前目录的父目录字符串名：(&apos;..&apos;)os.makedirs(&apos;dirname1/dirname2&apos;) 可生成多层递归目录os.removedirs(&apos;dirname1&apos;) 若目录为空，则删除，并递归到上一级目录，如若也为空，则删除，依此类推os.mkdir(&apos;dirname&apos;) 生成单级目录；相当于shell中mkdir dirname ，默认权限777os.rmdir(&apos;dirname&apos;) 删除单级空目录，若目录不为空则无法删除，报错；相当于shell中rmdir dirnameos.listdir(&apos;dirname&apos;) 列出指定目录下的所有文件和子目录，包括隐藏文件，并以列表方式打印os.remove() 删除一个文件os.rename(&quot;oldname&quot;,&quot;newname&quot;) 重命名文件/目录， 无返回值os.stat(&apos;path/filename&apos;) 获取文件/目录信息os.sep 输出操作系统特定的路径分隔符，win下为&quot;\\\\&quot;,Linux下为&quot;/&quot;os.linesep 输出当前平台使用的行终止符，win下为&quot;\\t\\n&quot;,Linux下为&quot;\\n&quot;os.pathsep 输出用于分割文件路径的字符串 win下为;,Linux下为:os.name 输出字符串指示当前使用平台。win-&gt;&apos;nt&apos;; Linux-&gt;&apos;posix&apos;os.system(&quot;bash command&quot;) 运行shell命令，直接显示os.environ 获取系统环境变量os.path.abspath(path) 返回path规范化的绝对路径os.path.split(path) 将path分割成目录和文件名二元组返回os.path.dirname(path) 返回path的目录。其实就是os.path.split(path)的第一个元素os.path.basename(path) 返回path最后的文件名。如何path以／或\\结尾，那么就会返回空值。即os.path.split(path)的第二个元素os.path.exists(path) 如果path存在，返回True；如果path不存在，返回Falseos.path.isabs(path) 如果path是绝对路径，返回Trueos.path.isfile(path) 如果path是一个存在的文件，返回True。否则返回Falseos.path.isdir(path) 如果path是一个存在的目录，则返回True。否则返回Falseos.path.join(path1[, path2[, ...]]) 将多个路径组合后返回，第一个绝对路径之前的参数将被忽略print(os.path.join(&quot;D:\\\\python\\\\wwww&quot;,&quot;aaa&quot;)) #做路径拼接用的 #D:\\python\\wwww\\aaaprint(os.path.join(r&quot;D:\\python\\wwww&quot;,&quot;aaa&quot;)) #做路径拼接用的 #D:\\python\\wwww\\aaaos.path.getatime(path) 返回path所指向的文件或者目录的最后存取时间os.path.getmtime(path) 返回path所指向的文件或者目录的最后修改时间os.path.getsize(path) 返回path的大小在Linux和Mac平台上，该函数会原样返回path，在windows平台上会将路径中所有字符转换为小写，并将所有斜杠转换为饭斜杠。&gt;&gt;&gt; os.path.normcase(&apos;c:/windows\\\\system32\\\\&apos;) &apos;c:\\\\windows\\\\system32\\\\&apos; 规范化路径，如..和/&gt;&gt;&gt; os.path.normpath(&apos;c://windows\\\\System32\\\\../Temp/&apos;) &apos;c:\\\\windows\\\\Temp&apos; &gt;&gt;&gt; a=&apos;/Users/jieli/test1/\\\\\\a1/\\\\\\\\aa.py/../..&apos;&gt;&gt;&gt; print(os.path.normpath(a))/Users/jieli/test1os路径处理#方式一：推荐使用import os#具体应用import os,syspossible_topdir = os.path.normpath(os.path.join( os.path.abspath(__file__), os.pardir, #上一级 os.pardir, os.pardir))sys.path.insert(0,possible_topdir) #方式二：不推荐使用os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))) sys模块1234567891011import syssys.versionsys.maxsizesys.pathsys.platformsys.stdout.write(&apos;hey world&apos;)val = sys.stdin.readline()[:-1]sys.getrecursionlimit()sys.setrecursionlimit(2000)sys.getdefaultencoding()sys.getfilesystemencoding() #文件的默认编码 shutil模块高级的 文件、文件夹、压缩包 处理模块12345import shutil&quot;&quot;&quot;高级的 文件、文件夹、压缩包 处理模块shutil.copyfileobj(fsrc, fdst[, length])将文件内容拷贝到另一个文件中,可以指定部分长度内容copy,直到结束 import shutilf1 = open(“source.py”,’r’)f2 = open(“new.py”,’w’)shutil.copyfileobj(f1,f2)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889shutil.copyfile(src, dst)拷贝文件, shutil.copymode(src, dst)仅拷贝权限。内容、组、用户均不变 shutil.copystat(src, dst)仅拷贝状态的信息，包括：mode bits, atime创建时间, mtime修改时间, flags shutil.copy(src, dst)拷贝文件和权限 shutil.copy2(src, dst)拷贝文件和状态信息 shutil.ignore_patterns(*patterns)shutil.copytree(src, dst, symlinks=False, ignore=None)递归的去拷贝文件夹 shutil.move(src, dst)递归的去移动文件，它类似mv命令，其实就是重命名。&quot;&quot;&quot; shutil.copyfileobj(open(&apos;xmltest.xml&apos;,&apos;r&apos;), open(&apos;new.xml&apos;, &apos;w&apos;))shutil.copyfile(&apos;b.txt&apos;, &apos;bnew.txt&apos;)#目标文件无需存在shutil.copymode(&apos;f1.log&apos;, &apos;f2.log&apos;) #目标文件必须存在shutil.copystat(&apos;f1.log&apos;, &apos;f2.log&apos;) #目标文件必须存在shutil.copy(&apos;f1.log&apos;, &apos;f2.log&apos;)shutil.copy2(&apos;f1.log&apos;, &apos;f2.log&apos;)shutil.copytree(&apos;folder1&apos;, &apos;folder2&apos;, ignore=shutil.ignore_patterns(&apos;*.pyc&apos;, &apos;tmp*&apos;)) #目标目录不能存在，注意对folder2目录父级目录要有可写权限，ignore的意思是排除 &apos;&apos;&apos;通常的拷贝都把软连接拷贝成硬链接，即对待软连接来说，创建新的文件&apos;&apos;&apos;#拷贝软连接shutil.copytree(&apos;f1&apos;, &apos;f2&apos;, symlinks=True, ignore=shutil.ignore_patterns(&apos;*.pyc&apos;, &apos;tmp*&apos;)) shutil.move(&apos;folder1&apos;, &apos;folder3&apos;) &quot;&quot;&quot;shutil.make_archive(base_name, format,...)创建压缩包并返回文件路径，例如：zip、tarbase_name： 压缩包的文件名，也可以是压缩包的路径。只是文件名时，则保存至当前目录，否则保存至指定路径，如 data_bak =&gt;保存至当前路径如：/tmp/data_bak =&gt;保存至/tmp/format： 压缩包种类，“zip”, “tar”, “bztar”，“gztar”root_dir： 要压缩的文件夹路径（默认当前目录）owner： 用户，默认当前用户group： 组，默认当前组logger： 用于记录日志，通常是logging.Logger对象&quot;&quot;&quot; # 将 /data 下的文件打包放置当前程序目录import shutilret = shutil.make_archive(&quot;data_bak&quot;, &apos;gztar&apos;, root_dir=&apos;/data&apos;)# 将 /data下的文件打包放置 /tmp/目录import shutilret = shutil.make_archive(&quot;/tmp/data_bak&quot;, &apos;gztar&apos;, root_dir=&apos;/data&apos;) #shutil 对压缩包的处理是调用 ZipFile 和 TarFile 两个模块来进行的，详细： #zipfile压缩解压缩import zipfile# 压缩z = zipfile.ZipFile(&apos;laxi.zip&apos;, &apos;w&apos;)z.write(&apos;a.log&apos;)z.write(&apos;data.data&apos;)z.close() # 解压z = zipfile.ZipFile(&apos;laxi.zip&apos;, &apos;r&apos;)z.extractall(path=&apos;.&apos;)z.close() #tarfile压缩解压缩import tarfile # 压缩t=tarfile.open(&apos;/tmp/egon.tar&apos;,&apos;w&apos;)t.add(&apos;/test1/a.py&apos;,arcname=&apos;a.bak&apos;)t.add(&apos;/test1/b.py&apos;,arcname=&apos;b.bak&apos;)t.close() # 解压t=tarfile.open(&apos;/tmp/egon.tar&apos;,&apos;r&apos;)t.extractall(&apos;/egon&apos;)t.close() 序列化模块 什么是序列化 内存里的数据转成字符串，存到硬盘或者网络传输。我们把对象(变量)从内存中变成可存储或传输的过程称之为序列化，在Python中叫pickling，在其他语言中也被称之为serialization，marshalling，flattening等等，都是一个意思。 为什么要序列化 dict等对象无法保存到硬盘上 持久保持状态 跨平台数据交互 什么是反序列化把变量字符内容从序列化的对象重新读到内存里称之为反序列化 123456789101112data = &#123;&apos;students&apos;:[ &#123;&apos;name&apos;:&apos;zhangsan,&apos;age&apos;:20&#125; &#123;&apos;name&apos;:&apos;lisi&apos;,&apos;age&apos;:25&#125; ]&#125;f = open(&quot;school&quot;,&quot;w&quot;)f.write(str(data))f.close()f = open(&quot;school&quot;,&apos;r&apos;)d = f.read()d = eval(d)print(d[&apos;roles&apos;]) eval内置方法可以将一个字符串转成python对象，不过，eval方法是有局限性的，对于普通的数据类型，json.loads和eval都能用，但遇到特殊类型的时候，eval就不管用了,所以eval的重点还是通常用来执行一个字符串表达式，并返回表达式的值。 如果我们要在不同的编程语言之间传递对象，就必须把对象序列化为标准格式，比如XML，但更好的方法是序列化为JSON，因为JSON表示出来就是一个字符串，可以被所有语言读取，也可以方便地存储到磁盘或者通过网络传输。 JSON不仅是标准格式，并且比XML更快，而且可以直接在Web页面中读取，非常方便。 json模块 JSON表示的对象就是标准的JavaScript语言的对象，JSON和Python内置的数据类型对应如下： json类型 python类型 {} dict [] list () tuple “string” str 1234.56 int or float true/false True/False null None json.dumps(data) json.loads#转换成字符串到内存中 把你的内存数据 通过网络 共享给远程其它人跨平台、跨语言共享数据 转换成字符存储到文件中 f = file.open(“data.json”,”w”)json.dump(data,f) 读取文件的数据 f = open(“data.json”,”r”)data = json.load(f) 12345678910111213141516171819202122232425262728293031&quot;&quot;&quot;dumps,loads&quot;&quot;&quot;import json dic = &#123;&apos;name&apos;: &apos;tom&apos;, &apos;age&apos;: 18, &apos;sex&apos;: &apos;male&apos;&#125;print(type(dic)) # &lt;class &apos;dict&apos;&gt; j = json.dumps(dic)print(type(j)) # &lt;class &apos;str&apos;&gt; f = open(&apos;序列化对象&apos;, &apos;w&apos;)f.write(j) #等价于json.dump(dic,f)f.close()#反序列化import jsonf = open(&apos;序列化对象&apos;)data = json.loads(f.read()) # 等价于data=json.load(f) &quot;&quot;&quot;无论数据是怎样创建的，只要满足json格式，就可以json.loads出来,不一定非要dumps的数据才能loads&quot;&quot;&quot;import jsondct=&quot;&#123;&apos;1&apos;:111&#125;&quot;#报错,json 不认单引号dct=str(&#123;&quot;1&quot;:&quot;111&quot;&#125;)#报错,因为生成的数据还是单引号:&#123;&apos;1&apos;: &apos;111&apos;&#125;print(dct) #&#123;&apos;1&apos;: &apos;111&apos;&#125; dct=str(&apos;&#123;&quot;1&quot;:&quot;111&quot;&#125;&apos;)#正确写法dct=&apos;&#123;&quot;1&quot;:&quot;111&quot;&#125;&apos;#正确写法print(json.loads(dct)) json模块只能序列化int,str,list,dict,tuple五种类型 ensure_ascii参数还是比较常用的，当该参数的值 为True（默认值）时，输出中的所有非ASCII字符（比如中文）都会被转义成&apos;\\uXXXX&apos;组成的序 列，所以设置为Flase就可以保留中文字符。 sort_keys参数表示序列化时是否对dict的key进行排序 indent参数可以设置数据存储的格式 separators参数也可以优化数据存储格式，重新指定分隔符，从而去除无用的空白字符 picklePickle的问题和所有其他编程语言特有的序列化问题一样，就是它只能用于Python，支持python所有的数据类型，有可能不同版本的Python彼此都不兼容，因此，只能用Pickle保存那些不重要的数据，不能成功地反序列化也没关系。可序列化所有类型1234567891011121314151617import pickledic = &#123;&apos;name&apos;: &apos;tom&apos;, &apos;age&apos;: 23, &apos;sex&apos;: &apos;male&apos;&#125;print(type(dic)) # &lt;class &apos;dict&apos;&gt; j = pickle.dumps(dic)print(type(j)) # &lt;class &apos;bytes&apos;&gt; f = open(&apos;序列化对象_pickle&apos;, &apos;wb&apos;) # 注意是w是写入str,wb是写入bytes,j是&apos;bytes&apos;f.write(j) #-等价于pickle.dump(dic,f) f.close() # 反序列化import picklef = open(&apos;序列化对象_pickle&apos;, &apos;rb&apos;)data = pickle.loads(f.read()) # 等价于data=pickle.load(f)print(data[&apos;age&apos;]) shelve模块shelve模块比pickle模块简单，只有一个open函数，返回类似字典的对象，可读可写;key必须为字符串，而值可以是python所支持的数据类型支持多次序列化12345678import shelvef=shelve.open(r&apos;sheve.txt&apos;)#存# f[&apos;stu1_info&apos;]=&#123;&apos;name&apos;:&apos;rose&apos;,&apos;age&apos;:18,&apos;hobby&apos;:[&apos;sing&apos;,&apos;talk&apos;,&apos;swim&apos;]&#125;# f[&apos;stu2_info&apos;]=&#123;&apos;name&apos;:&apos;tom&apos;,&apos;age&apos;:53&#125;#取print(f[&apos;stu1_info&apos;][&apos;hobby&apos;])f.close() xml模块xml是实现不同语言或程序之间进行数据交换的协议，跟json差不多，但json使用起来更简单，不过，古时候，在json还没诞生的黑暗年代，大家只能选择用xml呀，至今很多传统公司如金融行业的很多系统的接口还主要是xml。 &lt;?xml version=”1.0”?&gt; 2 2008 141100 5 2011 59900 69 2011 13600 解析方式12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#!/usr/bin/env python# -*- coding:utf-8 -*- import xml.etree.ElementTree as ET &quot;&quot;&quot;############ 解析方式一 ############str_xml = open(&apos;xmltest.xml&apos;, &apos;r&apos;).read()# 打开文件，读取XML内容root = ET.XML(str_xml)# 将字符串解析成xml特殊对象，root代指xml文件的根节点print(root.tag)#获取根节点的标签名&quot;&quot;&quot;############ 解析方式二 ############tree = ET.parse(&quot;xmltest.xml&quot;)# 直接解析xml文件root = tree.getroot()# 获取xml文件的根节点print(root.tag)#获取根节点的标签名 # 遍历xml文档for child in root: print(&apos;========&gt;&apos;, child.tag, child.attrib, child.attrib[&apos;name&apos;]) for i in child: print(i.tag, i.attrib, i.text) #标签 属性 文本 # 只遍历year 节点for node in root.iter(&apos;year&apos;): print(node.tag, node.text)# --------------------------------------- import xml.etree.ElementTree as ET tree = ET.parse(&quot;xmltest.xml&quot;)root = tree.getroot() # 修改for node in root.iter(&apos;year&apos;): new_year = int(node.text) + 1 node.text = str(new_year) node.set(&apos;updated&apos;, &apos;yes&apos;) node.set(&apos;version&apos;, &apos;1.0&apos;)tree.write(&apos;test.xml&apos;) # 删除nodefor country in root.findall(&apos;country&apos;): rank = int(country.find(&apos;rank&apos;).text) if rank &gt; 50: root.remove(country) tree.write(&apos;output.xml&apos;) &quot;&quot;&quot;#在country内添加（append）节点year2&quot;&quot;&quot; import xml.etree.ElementTree as ETtree = ET.parse(&quot;xmltest.xml&quot;)root=tree.getroot()for country in root.findall(&apos;country&apos;): for year in country.findall(&apos;year&apos;): if int(year.text) &gt; 2000: year2=ET.Element(&apos;year2&apos;) year2.text=&apos;新年&apos; year2.attrib=&#123;&apos;update&apos;:&apos;yes&apos;&#125; country.append(year2) #往country节点下添加子节点 tree.write(&apos;a.xml.swap&apos;) &quot;&quot;&quot;#自己创建xml文档&quot;&quot;&quot; import xml.etree.ElementTree as ET new_xml = ET.Element(&quot;namelist&quot;)name = ET.SubElement(new_xml, &quot;name&quot;, attrib=&#123;&quot;enrolled&quot;: &quot;yes&quot;&#125;)age = ET.SubElement(name, &quot;age&quot;, attrib=&#123;&quot;checked&quot;: &quot;no&quot;&#125;)sex = ET.SubElement(name, &quot;sex&quot;)sex.text = &apos;33&apos;name2 = ET.SubElement(new_xml, &quot;name&quot;, attrib=&#123;&quot;enrolled&quot;: &quot;no&quot;&#125;)age = ET.SubElement(name2, &quot;age&quot;)age.text = &apos;19&apos; et = ET.ElementTree(new_xml) # 生成文档对象et.write(&quot;test.xml&quot;, encoding=&quot;utf-8&quot;, xml_declaration=True) ET.dump(new_xml) # 打印生成的格式 xml的语法功能123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337class Element: &quot;&quot;&quot;An XML element. This class is the reference implementation of the Element interface. An element&apos;s length is its number of subelements. That means if you want to check if an element is truly empty, you should check BOTH its length AND its text attribute. The element tag, attribute names, and attribute values can be either bytes or strings. *tag* is the element name. *attrib* is an optional dictionary containing element attributes. *extra* are additional element attributes given as keyword arguments. Example form: &lt;tag attrib&gt;text&lt;child/&gt;...&lt;/tag&gt;tail &quot;&quot;&quot; 当前节点的标签名 tag = None &quot;&quot;&quot;The element&apos;s name.&quot;&quot;&quot; 当前节点的属性 attrib = None &quot;&quot;&quot;Dictionary of the element&apos;s attributes.&quot;&quot;&quot; 当前节点的内容 text = None &quot;&quot;&quot; Text before first subelement. This is either a string or the value None. Note that if there is no text, this attribute may be either None or the empty string, depending on the parser. &quot;&quot;&quot; tail = None &quot;&quot;&quot; Text after this element&apos;s end tag, but before the next sibling element&apos;s start tag. This is either a string or the value None. Note that if there was no text, this attribute may be either None or an empty string, depending on the parser. &quot;&quot;&quot; def __init__(self, tag, attrib=&#123;&#125;, **extra): if not isinstance(attrib, dict): raise TypeError(&quot;attrib must be dict, not %s&quot; % ( attrib.__class__.__name__,)) attrib = attrib.copy() attrib.update(extra) self.tag = tag self.attrib = attrib self._children = [] def __repr__(self): return &quot;&lt;%s %r at %#x&gt;&quot; % (self.__class__.__name__, self.tag, id(self)) def makeelement(self, tag, attrib): 创建一个新节点 &quot;&quot;&quot;Create a new element with the same type. *tag* is a string containing the element name. *attrib* is a dictionary containing the element attributes. Do not call this method, use the SubElement factory function instead. &quot;&quot;&quot; return self.__class__(tag, attrib) def copy(self): &quot;&quot;&quot;Return copy of current element. This creates a shallow copy. Subelements will be shared with the original tree. &quot;&quot;&quot; elem = self.makeelement(self.tag, self.attrib) elem.text = self.text elem.tail = self.tail elem[:] = self return elem def __len__(self): return len(self._children) def __bool__(self): warnings.warn( &quot;The behavior of this method will change in future versions. &quot; &quot;Use specific &apos;len(elem)&apos; or &apos;elem is not None&apos; test instead.&quot;, FutureWarning, stacklevel=2 ) return len(self._children) != 0 # emulate old behaviour, for now def __getitem__(self, index): return self._children[index] def __setitem__(self, index, element): # if isinstance(index, slice): # for elt in element: # assert iselement(elt) # else: # assert iselement(element) self._children[index] = element def __delitem__(self, index): del self._children[index] def append(self, subelement): 为当前节点追加一个子节点 &quot;&quot;&quot;Add *subelement* to the end of this element. The new element will appear in document order after the last existing subelement (or directly after the text, if it&apos;s the first subelement), but before the end tag for this element. &quot;&quot;&quot; self._assert_is_element(subelement) self._children.append(subelement) def extend(self, elements): 为当前节点扩展 n 个子节点 &quot;&quot;&quot;Append subelements from a sequence. *elements* is a sequence with zero or more elements. &quot;&quot;&quot; for element in elements: self._assert_is_element(element) self._children.extend(elements) def insert(self, index, subelement): 在当前节点的子节点中插入某个节点，即：为当前节点创建子节点，然后插入指定位置 &quot;&quot;&quot;Insert *subelement* at position *index*.&quot;&quot;&quot; self._assert_is_element(subelement) self._children.insert(index, subelement) def _assert_is_element(self, e): # Need to refer to the actual Python implementation, not the # shadowing C implementation. if not isinstance(e, _Element_Py): raise TypeError(&apos;expected an Element, not %s&apos; % type(e).__name__) def remove(self, subelement): 在当前节点在子节点中删除某个节点 &quot;&quot;&quot;Remove matching subelement. Unlike the find methods, this method compares elements based on identity, NOT ON tag value or contents. To remove subelements by other means, the easiest way is to use a list comprehension to select what elements to keep, and then use slice assignment to update the parent element. ValueError is raised if a matching element could not be found. &quot;&quot;&quot; # assert iselement(element) self._children.remove(subelement) def getchildren(self): 获取所有的子节点（废弃） &quot;&quot;&quot;(Deprecated) Return all subelements. Elements are returned in document order. &quot;&quot;&quot; warnings.warn( &quot;This method will be removed in future versions. &quot; &quot;Use &apos;list(elem)&apos; or iteration over elem instead.&quot;, DeprecationWarning, stacklevel=2 ) return self._children def find(self, path, namespaces=None): 获取第一个寻找到的子节点 &quot;&quot;&quot;Find first matching element by tag name or path. *path* is a string having either an element tag or an XPath, *namespaces* is an optional mapping from namespace prefix to full name. Return the first matching element, or None if no element was found. &quot;&quot;&quot; return ElementPath.find(self, path, namespaces) def findtext(self, path, default=None, namespaces=None): 获取第一个寻找到的子节点的内容 &quot;&quot;&quot;Find text for first matching element by tag name or path. *path* is a string having either an element tag or an XPath, *default* is the value to return if the element was not found, *namespaces* is an optional mapping from namespace prefix to full name. Return text content of first matching element, or default value if none was found. Note that if an element is found having no text content, the empty string is returned. &quot;&quot;&quot; return ElementPath.findtext(self, path, default, namespaces) def findall(self, path, namespaces=None): 获取所有的子节点 &quot;&quot;&quot;Find all matching subelements by tag name or path. *path* is a string having either an element tag or an XPath, *namespaces* is an optional mapping from namespace prefix to full name. Returns list containing all matching elements in document order. &quot;&quot;&quot; return ElementPath.findall(self, path, namespaces) def iterfind(self, path, namespaces=None): 获取所有指定的节点，并创建一个迭代器（可以被for循环） &quot;&quot;&quot;Find all matching subelements by tag name or path. *path* is a string having either an element tag or an XPath, *namespaces* is an optional mapping from namespace prefix to full name. Return an iterable yielding all matching elements in document order. &quot;&quot;&quot; return ElementPath.iterfind(self, path, namespaces) def clear(self): 清空节点 &quot;&quot;&quot;Reset element. This function removes all subelements, clears all attributes, and sets the text and tail attributes to None. &quot;&quot;&quot; self.attrib.clear() self._children = [] self.text = self.tail = None def get(self, key, default=None): 获取当前节点的属性值 &quot;&quot;&quot;Get element attribute. Equivalent to attrib.get, but some implementations may handle this a bit more efficiently. *key* is what attribute to look for, and *default* is what to return if the attribute was not found. Returns a string containing the attribute value, or the default if attribute was not found. &quot;&quot;&quot; return self.attrib.get(key, default) def set(self, key, value): 为当前节点设置属性值 &quot;&quot;&quot;Set element attribute. Equivalent to attrib[key] = value, but some implementations may handle this a bit more efficiently. *key* is what attribute to set, and *value* is the attribute value to set it to. &quot;&quot;&quot; self.attrib[key] = value def keys(self): 获取当前节点的所有属性的 key &quot;&quot;&quot;Get list of attribute names. Names are returned in an arbitrary order, just like an ordinary Python dict. Equivalent to attrib.keys() &quot;&quot;&quot; return self.attrib.keys() def items(self): 获取当前节点的所有属性值，每个属性都是一个键值对 &quot;&quot;&quot;Get element attributes as a sequence. The attributes are returned in arbitrary order. Equivalent to attrib.items(). Return a list of (name, value) tuples. &quot;&quot;&quot; return self.attrib.items() def iter(self, tag=None): 在当前节点的子孙中根据节点名称寻找所有指定的节点，并返回一个迭代器（可以被for循环）。 &quot;&quot;&quot;Create tree iterator. The iterator loops over the element and all subelements in document order, returning all elements with a matching tag. If the tree structure is modified during iteration, new or removed elements may or may not be included. To get a stable set, use the list() function on the iterator, and loop over the resulting list. *tag* is what tags to look for (default is to return all elements) Return an iterator containing all the matching elements. &quot;&quot;&quot; if tag == &quot;*&quot;: tag = None if tag is None or self.tag == tag: yield self for e in self._children: yield from e.iter(tag) # compatibility def getiterator(self, tag=None): # Change for a DeprecationWarning in 1.4 warnings.warn( &quot;This method will be removed in future versions. &quot; &quot;Use &apos;elem.iter()&apos; or &apos;list(elem.iter())&apos; instead.&quot;, PendingDeprecationWarning, stacklevel=2 ) return list(self.iter(tag)) def itertext(self): 在当前节点的子孙中根据节点名称寻找所有指定的节点的内容，并返回一个迭代器（可以被for循环）。 &quot;&quot;&quot;Create text iterator. The iterator loops over the element and all subelements in document order, returning all inner text. &quot;&quot;&quot; tag = self.tag if not isinstance(tag, str) and tag is not None: return if self.text: yield self.text for e in self: yield from e.itertext() if e.tail: yield e.tail #configparser模块configparser用于处理特定格式的文件，本质上是利用open来操作文件,主要用于配置文件分析用的 配置文件如下 # 注释1 ; 注释2 [section1] k1 = v1 k2:v2 user=egon age=18 is_admin=true salary=31 [section2] k1 = v1 读 写 改 查1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&quot;&quot;&quot;读取&quot;&quot;&quot;import configparser config=configparser.ConfigParser()config.read(&apos;a.cfg&apos;) #查看所有的标题res=config.sections() #[&apos;section1&apos;, &apos;section2&apos;]print(res) #查看标题section1下所有key=value的keyoptions=config.options(&apos;section1&apos;)print(options) #[&apos;k1&apos;, &apos;k2&apos;, &apos;user&apos;, &apos;age&apos;, &apos;is_admin&apos;, &apos;salary&apos;] #查看标题section1下所有key=value的(key,value)格式item_list=config.items(&apos;section1&apos;)print(item_list) #[(&apos;k1&apos;, &apos;v1&apos;), (&apos;k2&apos;, &apos;v2&apos;), (&apos;user&apos;, &apos;egon&apos;), (&apos;age&apos;, &apos;18&apos;), (&apos;is_admin&apos;, &apos;true&apos;), (&apos;salary&apos;, &apos;31&apos;)] #查看标题section1下user的值=&gt;字符串格式val=config.get(&apos;section1&apos;,&apos;user&apos;)print(val) #egon #查看标题section1下age的值=&gt;整数格式val1=config.getint(&apos;section1&apos;,&apos;age&apos;)print(val1) #18 #查看标题section1下is_admin的值=&gt;布尔值格式val2=config.getboolean(&apos;section1&apos;,&apos;is_admin&apos;)print(val2) #True #查看标题section1下salary的值=&gt;浮点型格式val3=config.getfloat(&apos;section1&apos;,&apos;salary&apos;)print(val3) #31.0&quot;&quot;&quot;改写&quot;&quot;&quot;import configparser config=configparser.ConfigParser()config.read(&apos;a.cfg&apos;,encoding=&apos;utf-8&apos;) #删除整个标题section2config.remove_section(&apos;section2&apos;) #删除标题section1下的某个k1和k2config.remove_option(&apos;section1&apos;,&apos;k1&apos;)config.remove_option(&apos;section1&apos;,&apos;k2&apos;) #判断是否存在某个标题print(config.has_section(&apos;section1&apos;)) #判断标题section1下是否有userprint(config.has_option(&apos;section1&apos;,&apos;&apos;)) #添加一个标题config.add_section(&apos;egon&apos;) #在标题egon下添加name=egon,age=18的配置config.set(&apos;egon&apos;,&apos;name&apos;,&apos;egon&apos;)# config.set(&apos;egon&apos;,&apos;age&apos;,18) #报错,必须是字符串 #最后将修改的内容写入文件,完成最终的修改config.write(open(&apos;a.cfg&apos;,&apos;w&apos;)) hashlibhash是一种算法（3.x里代替了md5模块和sha模块，主要提供 SHA1, SHA224, SHA256, SHA384, SHA512 ，MD5 算法），该算法接受传入的内容，经过运算得到一串hash值 hash值的特点是只要传入的内容一样，得到的hash值必然一样 不能由hash值返解成内容，不应该在网络传输明文密码 只要使用的hash算法不变，无论校验的内容有多大，得到的hash值长度是固定 123456789101112&apos;&apos;&apos;注意：把一段很长的数据update多次，与一次update这段长数据，得到的结果一样&apos;&apos;&apos;import hashlibm = hashlib.md5() # m=hashlib.sha256()m.update(&apos;hello&apos;.encode(&apos;utf8&apos;))print(m.hexdigest()) # 5d41402abc4b2a76b9719d911017c592m.update(&apos;world&apos;.encode(&apos;utf8&apos;))print(m.hexdigest()) # fc5e038d38a57032085441e7fe7010b0m2 = hashlib.md5()m2.update(&apos;helloworld&apos;.encode(&apos;utf8&apos;))print(m2.hexdigest()) # fc5e038d38a57032085441e7fe7010b0 添加自定义key(加盐)以上加密算法虽然依然非常厉害，但时候存在缺陷，即：通过撞库可以反解。所以，有必要对加密算法中添加自定义key再来做加密。 1234567&quot;&quot;&quot;对加密算法中添加自定义key再来做加密&quot;&quot;&quot;import hashlibhash = hashlib.sha256(&apos;898oaFs09f&apos;.encode(&apos;utf8&apos;))hash.update(&apos;alvin&apos;.encode(&apos;utf8&apos;))print(hash.hexdigest()) # e79e68f070cdedcfe63eaf1a2e92c83b4cfb1b5c6bc452d214c1b7e77cdfd1c7 123456789101112131415161718192021222324252627&quot;&quot;&quot;模拟撞库破解密码&quot;&quot;&quot;import hashlibpasswds=[ &apos;tom3714&apos;, &apos;tom1313&apos;, &apos;tom94139413&apos;, &apos;tom123456&apos;, &apos;1234567890&apos;, &apos;a123sdsdsa&apos;, ]def make_passwd_dic(passwds): dic=&#123;&#125; for passwd in passwds: m=hashlib.md5() m.update(passwd.encode(&apos;utf-8&apos;)) dic[passwd]=m.hexdigest() return dic def break_code(cryptograph,passwd_dic): for k,v in passwd_dic.items(): if v == cryptograph: print(&apos;密码是===&gt;\\033[46m%s\\033[0m&apos; %k) cryptograph=&apos;f19b50d5e3433e65e6879d0e66632664&apos;break_code(cryptograph,make_passwd_dic(passwds)) suprocess模块123456789101112131415161718192021222324252627282930313233343536373839import subprocess&quot;&quot;&quot;Linux下:&quot;&quot;&quot;# obj = subprocess.Popen(&apos;ls&apos;, shell=True,# stdout=subprocess.PIPE,# stderr=subprocess.PIPE)# stdout = obj.stdout.read()# stderr = obj.stderr.read()## #=========================# res1=subprocess.Popen(&apos;ls&apos;,shell=True,stdout=subprocess.PIPE)# res=subprocess.Popen(&apos;grep txt$&apos;,shell=True,stdin=res1.stdout,# stdout=subprocess.PIPE)# print(res.stdout.read().decode(&apos;utf-8&apos;))## #等同于上面,但是上面的优势在于,一个数据流可以和另外一个数据流交互,可以通过爬虫得到结果然后交给grep# res1=subprocess.Popen(&apos;ls |grep txt$&apos;,shell=True,stdout=subprocess.PIPE)# print(res1.stdout.read().decode(&apos;utf-8&apos;))a = subprocess.Popen(&apos;for i in $(seq 1 100);do sleep 1;echo $i &gt;&gt;/tmp/sleep.log;done&apos;,shell=True,stdout=subprocess.a.pida.terminate()a.kill()a.communicate(b&apos;5&apos;)a.stdouta.stdout.read()a.send_signal(signal.SIGKILL)&quot;&quot;&quot;windows下:# dir | findstr &apos;App*&apos;# dir | findstr &apos;App$&apos;&quot;&quot;&quot;#Popen发起一个新进程import subprocessres1=subprocess.Popen(r&apos;dir C:\\Windows&apos;,shell=True,stdout=subprocess.PIPE)res=subprocess.Popen(&apos;findstr App*&apos;,shell=True,stdin=res1.stdout, stdout=subprocess.PIPE) print(res.stdout.read().decode(&apos;gbk&apos;)) #subprocess使用当前系统默认编码，得到结果为bytes类型，在windows下需要用gbk解码 logging模块Python的logging模块提供了通用的日志系统，可以方便第三方模块或者是应用使用。这个模块提供不同的日志级别，并可以采用不同的方式记录日志，比如文件，HTTP GET/POST，SMTP，Socket等，甚至可以自己实现具体的日志记录方式logging模块可帮助更容易的记录日志。logging的日志可以分为debug(),info(),warning(),error()和crictical()5个级别。 日志级别 级别 数值 使用 CRITICAL 50 严重错误，表示程序不能继续运行 FATAL=CRITICAL ERROR 40 错误，表示程序不能运行某一个功能 WARNING 30 报警，表示程序出现意外情况，或者未来的问题。 软件仍然继续正常运行,WARN = WARNING INFO 20 表示程序正常运行 DEBUG 10 详细信息，主要用于诊断问题 NOTSET 0 简单用法12345678import logginglogging.basicConfig(filename=&apos;log_test.log&apos;, level=logging.DEBUG, format=&apos;%(asctime)s %(message)s&apos;, datefmt=&apos;%m/%d/%Y %I:%M:%S %p&apos;)logging.debug(&apos;DEBUG: This message should go to the log file&apos;)logging.warning(&quot;WARNING: user [david] tried to log in&quot;)logging.critical(&quot;CRITICAL: server is down&quot;) logging模块定义的格式字符串字段 字段/属性名称 使用格式 描述 asctime %(asctime)s 日志事件发生的时间–人类可读时间，如：2003-07-08 16:49:45,896 created %(created)f 日志事件发生的时间–时间戳，就是当时调用time.time()函数返回的值 relativeCreated %(relativeCreated)d 日志事件发生的时间相对于logging模块加载时间的相对毫秒数 msecs %(msecs)d 日志事件发生事件的毫秒部分 levelname %(levelname)s 该日志记录的文字形式的日志级别（’DEBUG’, ‘INFO’, ‘WARNING’, ‘ERROR’, ‘CRITICAL’） levelno %(levelno)s 志记录的数字形式的日志级别（10, 20, 30, 40, 50） name %(name)s 所使用的日志器名称，默认是’root’，因为默认使用的是 rootLogger message %(message)s 日志记录的文本内容，通过 msg % args计算得到的 pathname %(pathname)s 调用日志记录函数的源码文件的全路径 filename %(filename)s pathname的文件名部分，包含文件后缀 module %(module)s filename的名称部分，不包含后缀 lineno %(lineno)d 调用日志记录函数的源代码所在的行号 funcName %(funcName)s 调用日志记录函数的函数名 process %(process)d 进程ID processName %(processName)s 进程名称，Python 3.1新增 thread %(thread)d 线程ID threadName %(thread)s 线程名称 #日志同时输出到屏幕和文件如果同时把log打印在屏幕和文件，Python使用logging模块记录日志设计四个主要类，使用官方文档中的概括： logger提供了应用程序可以直接调用的接口。与调用logging是相同的handler将（logger创建的）日志记录发送到合适的目的输出.一个handler对象只能绑定一个formatter对象，若执行多次setFormatter方法，则之前的 绑定都会被覆盖。filter输出哪条日志记录，哪条不输出formater决定了日志的记录的最终输出格式logger对象可以绑定handler和filter，也可以进行添加和删除操作。 每个组件的主要功能logger可以绑定handler和filters123Logger.setLevel(lev) #指定最低的日志级别Logger.addFilter(filt)、Logger.removeFilter(filt) #添加或删除指定的filterLogger.addHandler(hdlr)、Logger.removeHandler(hdlr) #添加或删除指定的handler Logger.debug()、Logger.info()、Logger.warning()、Logger.error()、Logger.critical()可设置日志级别 handlerhandler负责发送相关的信息到指定的目的。如控制台、文件或网络上。还可以编写自己的Handler，通过addHandler()添加多个handler123Handler.setLevel(lev) #低于lev级别的信息将被忽略Handler.setFormatter() #屏幕输出格式Handler.addFilter(filt)、Handler.remove(filt) logging.StreamHandler logging.handlers.RotatingFileHandler 123456789101112131415161718import logging# 1.生成 logger 对象logger = logging.getLogger（&quot;mylog&quot;)# 2.生成 handler 对象ch = logging.StreamHandler()fh = logging.FileHandler()# 3.把handler对象绑定到loggerlogger.addHandler(ch)logger.addHandler(fh)# 4. 生成formatter对象file_f = logging.Formatter(&apos;%(ascctime)s - %(name)s&apos;)console_f = logging.Formatter(&apos;%(asctime)s - %(levelname)s&apos;)ch.setFormater(console_f)fh.setFormater(file_f)logger.debug(&quot;test log&quot;) #不设置日志级别，默认为warninglogger.info(&quot;test log&quot;)# 2. 为logging模块指定全局配置，针对所有logger有效，控制打印到文件中1234567891011import logginglogging.basicConfig(filename=&apos;access.log&apos;, format=&apos;%(asctime)s - %(name)s - %(levelname)s -%(module)s: %(message)s&apos;, datefmt=&apos;%Y-%m-%d %H:%M:%S %p&apos;, level=10) logging.debug(&apos;调试debug&apos;)logging.info(&apos;消息info&apos;)logging.warning(&apos;警告warn&apos;)logging.error(&apos;错误error&apos;)logging.critical(&apos;严重critical&apos;) Logger与Handler的级别(logger是第一级过滤，然后才能到handler)12345678910111213141516171819import loggingform=logging.Formatter(&apos;%(asctime)s - %(name)s - %(levelname)s -%(module)s: %(message)s&apos;, datefmt=&apos;%Y-%m-%d %H:%M:%S %p&apos;,) ch=logging.StreamHandler()ch.setFormatter(form)# ch.setLevel(10)ch.setLevel(20) log1=logging.getLogger(&apos;root&apos;)# log1.setLevel(20)log1.setLevel(40)log1.addHandler(ch) log1.debug(&apos;log1 debug&apos;)log1.info(&apos;log1 info&apos;)log1.warning(&apos;log1 warning&apos;)log1.error(&apos;log1 error&apos;)log1.critical(&apos;log1 critical&apos;) 实例代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#core/logger.pyimport osimport loggingfrom conf import settings def logger(log_type): logger = logging.getLogger(log_type) logger.setLevel(settings.LOG_LEVEL) ch = logging.StreamHandler() #屏幕 ch.setLevel(settings.LOG_LEVEL) log_dir = &quot;%s/log&quot; % (settings.BASE_DIR) if not os.path.exists(log_dir): os.makedirs(log_dir) log_file = &quot;%s/log/%s&quot; %(settings.BASE_DIR, settings.LOG_TYPES[log_type]) fh = logging.FileHandler(log_file) #文件 fh.setLevel(settings.LOG_LEVEL) formatter = logging.Formatter(&apos;%(asctime)s - %(name)s - %(levelname)s - %(message)s&apos;) ch.setFormatter(formatter) fh.setFormatter(formatter) logger.addHandler(ch) logger.addHandler(fh) return logger #core/main.py 调用from core import loggertrans_logger = logger.logger(&apos;transaction&apos;)access_logger = logger.logger(&apos;access&apos;) def run(): trans_logger.debug(&apos;trans_logger debug&apos;) trans_logger.info(&apos;trans_logger info&apos;) trans_logger.warning(&apos;trans_logger warning&apos;) trans_logger.error(&apos;trans_logger error&apos;) trans_logger.critical(&apos;trans_logger critical&apos;) access_logger.debug(&apos;access_logger debug&apos;) access_logger.info(&apos;access_logger info&apos;) access_logger.warning(&apos;access_logger warning&apos;) access_logger.error(&apos;access_logger error&apos;) access_logger.critical(&apos;access_logger critical&apos;)run() #conf/setting.pyimport osimport loggingBASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) LOG_LEVEL = logging.INFOLOG_TYPES = &#123; &apos;transaction&apos;: &apos;transactions.log&apos;, &apos;access&apos;: &apos;access.log&apos;,&#125; 全局级别默认为warning，全局设置为漏斗，其它handler级别高于全局设置将不生效 filter 组件1234567import loggingclass BacFilter(logging.Filter): ##忽略带db的日志 def filter(self, record): return &quot;db&quot; not in record.getMessage()logger.addFilter(BacFilter())logger.debug(&quot;test log db&quot;) 日志的截断 logging.handlers.RotatingFileHandler 管理文件大小，达到一定大小后，另存文件1234from logging import handlersf = handlers.RotatingFileHandler(&quot;test.log&quot;, maxBytes=10, backupCount=3)&gt; logging.handlers.TimeRotatingFileHandler(filename [,when [,interval [,backupCount]]]) 管理文件大小，达到一定大小后，另存文件 logging.handlers.TimeRotatingFileHandler re模块re的匹配函数 方法 作用 re.match 从字符传开头匹配 re.search 全局查找，找到第一个返回 re.findall 查找所有的匹配，当做列表返回 re.split 按数字分割（把数字去掉），[maxsplit = 0]当做列表返回 re.sub 匹配字符并替换 re.fullmatch 全部匹配 re.fullmatch(‘\\w+@\\w+.(com&#124;cn&#124;edu)’,&#39;david@163.com‘) re.compile 匹配字符并替换 pattern = re.compile(‘\\w+@\\w+.(com&#124;cn&#124;edu)’),pattern.fullmatch(&#39;david@163.com‘) 123match_res = re.search(&apos;[0]&apos;,s)if match_res: match_res.group() 1234567import ress = &apos;abcdei23aa45&apos;re.match(&apos;[0-9]&apos;,ss)#返回Nonere.match(&apos;[0-9]&apos;,ss)#全局查找，找到就返回re.search(&apos;[0-9]&apos;,ss) 常用的匹配 符号 作用 ‘.’ 匹配任意字符 ‘^’ 匹配开头 ‘$’ 匹配结尾 ‘*’ 匹配*前面的字符0次或多次 ‘+’ 匹配+前面的字符1次或多次 ‘?’ 匹配？前面的字符0次或1次 ‘{m}’ 匹配前面的字符m次 ‘{n,m}’ 匹配前面的字符n-m次 ‘[0-9a-z]’ 任意一个字符 ‘&#124;’ 匹配左或右的字符 ‘(…)’ 分组匹配re.search(“(abc){2}a(123 45).group ‘\\A’ 从字符串开头字符,同^ ‘\\Z’ 从字符串开头字符,同$ ‘\\d’ 匹配数字0-9 ‘\\D’ 匹配非数字 ‘\\w’ 匹配[A-Za-z0-9] ‘\\W’ 匹配非[A-Za-z0-9],即特殊字符 ‘\\s’ 匹配空白字符，\\t,\\r,\\n ‘(?P…’ 分组匹配，re.search(“(?P[0-9]{4})) 分组匹配12import rere.search(&apos;([a-z]+)([[0-9]+])&apos;,&apos;alex123&apos;).groups 123s = &apos;130704200005250613&apos;res = re.search(&apos;(?P&lt;province&gt;\\d&#123;3&#125;)(?P&lt;city&gt;\\d&#123;3&#125;)&apos;)res.groupdict() 转义特殊字符需要转义匹配|, ‘|‘匹配\\, ‘\\\\‘ Flags标识符 re.I 忽略大小写re.M 多行模式re.S 使用re.S参数以后，正则表达式会将这个字符串作为一个整体，在整体中进行匹配re.X 可以在表达式中写注释` re.search(&#39;foo.$&#39;,&#39;foo1\\nfoo2\\n&#39;,re.M)","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"},{"name":"模块","slug":"Python/模块","permalink":"http://yoursite.com/categories/Python/模块/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"Ch2","slug":"Ch2","permalink":"http://yoursite.com/tags/Ch2/"},{"name":"常用模块","slug":"常用模块","permalink":"http://yoursite.com/tags/常用模块/"}]},{"title":"python 函数","slug":"python-函数","date":"2019-03-21T10:32:36.000Z","updated":"2019-04-26T01:56:26.372Z","comments":true,"path":"2019/03/21/python-函数/","link":"","permalink":"http://yoursite.com/2019/03/21/python-函数/","excerpt":"","text":"实参形参形参只在函数内部有效 默认参数(放在参数后面)12def hello_world(sex,age, name=&quot;david&quot;): print(name) 关键参数（实参输入时，不想按顺序传参，必须放在位置参数后面）1hello_world(&apos;m&apos;,age=22) 非固定参数 打包数据为元组 1234567def send_alert(msg,*args): for u in args: print(&apos;send alert to:&apos; u)send_alert(&apos;cpu&apos;,&apos;alex&apos;)send_alert(&apos;memory&apos;,&apos;alex&apos;,&apos;david&apos;)#如果想传列表中的元素，send_alert(&apos;hard_disk&apos;, *[&apos;alex&apos;,&apos;david&apos;]) 打包数据为字典(未定义的关键字参数) 12345def send_alert(msg,*args,**kwargs): print(name,args,kwargs) for u in args: print(&apos;send alert to:&apos; u)send_alert(&apos;cpu&apos;,&apos;alex&apos;,22,addr=&apos;山东&apos;,num=110) 函数返回值return #返回结果，一个函数的终止 局部变量定义在函数内部的变量 函数内部可调用外部变量，不可以修改全局变量 全局变量一级代码的变量 函数里修改全局变量global name = &quot;change to david&quot; 一般不使用global 嵌套函数12345678910def func1(): print(&apos;david&apos;) def func2(): print(&apos;eric&apos;) func2# 1. func1()# 函数内部可定义函数# 函数需要被调用才执行# 从内到外一级一级找变量 作用域一个函数就是一个作用域 123456789def func1(): age = 18 def func2(): print(age) return func2 #return func2()val = func1val()#函数名可以作为返回值 匿名函数 匿名函数的关键字为lambda，冒号前面是行参 冒号后面是返回值123func = lambda x,y:x*y if x &lt; y else x/y# 声明一个匿名函数(最多三元运算),用一次就不用了data = [i for i in range(10)]list(map(lambda x:x*x, data)) 匿名函数的默认参数1234# 匿名函数的默认参数(y=2)f = lambda x,y=2:x**yprint(f(3))print(f(2,4)) ##如果传值则默认参数值不生效 匿名函数的可变参数： *args（可接收多个值）12f = lambda *args:sum(args)print(f(1,2,3,45,6)) 匿名函数的关键字参数：参数为字典12f = lambda **kwargs:kwargs.values()print(f(name=&apos;fentiao&apos;,age=10)) 高阶函数函数作为参数, 返回一个函数 1234567def func(x,y) return x*ydef calc(x): #pass return xf = cal(func)print(f(5,9) 递归函数import sys sys.getrecursionlimit() sys.setrecursionlimit(1500) 123def recursion(n): print(n) recursion(n+1) 每执行一次函数，变量压到栈里，栈溢出 1234567def cal(n): v = int(n / 2) print(v) if v == 0: return &quot;done&quot; cal(v) print(v) 1. 必须有明确的结束条件 2. 进入更深一层递归，问题规模比上一次递归应减少 3. 效率不高，会导致溢出 尾递归优化123456def cal1(n): #n += 1 print(n) if n &lt; 10: return(cal1(n+1)) #返回函数本身，下一层递归跟上一层没有关系# print(n) 内置方法 abs() dict() help() min() setattr() all() dir() hex() next() slice() any() divmod() id() object() sorted() ascii() enumerate() input() oct() staticmethod() bin() dir() hex() next() slice() bool() exec() isinstance() ord() sum() bytearray() filter() issubclass() pow() super() bytes() float() iter() print() tuple() callable() format() len() property() type() chr() frozenset() list() range() vars() classmethod() getattr() locals() repr() zip() compile() globals() map() reversed() import() complex() hasattr() max() round() delattr() has() memoryview() set() 12345d= &#123;&#125;for i in range(20): d[i] = i-50d.items()sorted(d.items(),key = lambda x:x[1]) eval #处理单行代码 12f = &quot;1+3/2&quot;eval(f) exec #可执行多行代码 1code = if x = 20: print(x) 1exec(code) callable() 判断变量是否是函数 vars() 打印所有变量 locals() 打印局部变量 globals() repr() 显示为字符串 命名空间 locals：包括局部变量和形参 globals： 全局变量 builtin：dir(builtins)内置模块的名字空间 局部范围： 临时存活，局部有效作用域 LEGB 代表名字查找顺序：locals -&gt; enclosing function -&gt; globals -&gt; builtins L: locals是函数内的名字空间，包括局部变量和形参 E: enclosing 外部嵌套函数的名字空间 G: globals 全局变量，函数定义所在模块的名字空间 B： builtins 内置模块的名字空间闭包 内嵌子函数，返回子函数对象，该外层函数优先使用外层函数的作用域，但参数，内部变量并不释放。123456789def func(): n = 10 def func2(): print(&quot;func2:&quot;, n) return func2f = func()print(f)f() 装饰器开放：对现有的功能的扩展开放 封闭：对以实现的功能代码块不应该被修改 12345678910user_status = Falsedef login(): passdef home(): print(&quot;首页&quot;)def america(): login() #更改了函数，违反了“开放-封闭”原则 print(&quot;美国&quot;)def japan(): print(&quot;---日本---&quot;) 把要执行的函数作为参数传递 1234def login(func): func() #改变了调用方式 passlogin(america) 匿名函数 1234567def login(func): func() #改变了调用方式 passamerica = login(america)#用户调用时america()#还是会触发执行login 嵌套函数 123456789101112def login(func): def inner(): pass return inneramerica = login(america) # inneramerica()# 更简单的方法@login#def home():# print(&quot;首页&quot;)#@longin#def america():# print(&quot;美国&quot;) 带参数的装饰器(不固定参数) 1234def login(): def inner(*args,**kwargs): pass return inner(*args,*kwargs) login带参数login(auth_type) 123456789def login(auth_type): def outer(func): def inner(*args,*kwargs): pass return inner(*args,*kwargs) return outer()@login(&apos;qq)def japan(): print(&quot;---日本---&quot;) @wraps()将被装饰函数的name以及doc等属性绑定到了原函数的上面 123456789101112131415from functools import wrapsdef wrapper(func): print(&quot;this is a wrapper&quot;) @wraps(func) def inner(): print(func.__name__) return func() return inner@wrapperdef work(): return 123print(work.__name__) # 显示work，去掉wrap显示innerwork() # 显示work 生成器 列表生成式 需求：列表[0, 1, 2, 3, 4, 5],每个值都加1 12a = [0, 1, 2, 3, 4, 5]a = [i+1 for i in a] 生成器 生成器是一个公式, 可支持复杂的算法 1234a2 = (i for i in range(100))next(a2)for i in a2: #不会报错 print(i) Fibonacci 1,1,2,3,5,8,13,21,34,… 1234567891011def fib(max): n, a, b = 0, 0, 1 while n &lt; max: yield b #把函数执行过程冻结在这一步， 并且把b的值返回 a, b = b, a + b n = n + 1 return &apos;done&apos;f = fib(15)next(f)for i in f: print(i) 函数有了yield之后，函数就得到了一个生成器 return在生成器中，代表生成器的终止，直接报错 生成器终止 send 唤醒并继续执行，发送一个信息到生成器内部，send(None)1234sign = yield countif sign == &apos;stop&apos;: breakfunc.send(&apos;stop&apos;) 迭代器 Iterable 可以直接用于for循环的情形有以下几种 字符串 str 集合数据类型， 如 list、tuple、dict、set generator，包括生成器和带yield的generator function 这些统称为可迭代对象：Iterable 可以使用isinstance()是否是Iterable对象： 12form collections import Iterableisinstance(1,Iterable) Iterator 可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator 123from collections import Iteratorisinstance((x for x in range(10), Iterator)isinstance([], Iterator) 把list、dict、str变成迭代器 1iter(&apos;abc&apos;) 迭代器是一个数据流，没有终止，不能提前知道序列的长度，是惰性的计算，通过next()计算下一个数据。","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"},{"name":"函数","slug":"Python/函数","permalink":"http://yoursite.com/categories/Python/函数/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"Ch2","slug":"Ch2","permalink":"http://yoursite.com/tags/Ch2/"},{"name":"函数","slug":"函数","permalink":"http://yoursite.com/tags/函数/"}]},{"title":"你的问题","slug":"你的问题","date":"2019-03-21T10:32:36.000Z","updated":"2019-04-24T03:17:34.813Z","comments":true,"path":"2019/03/21/你的问题/","link":"","permalink":"http://yoursite.com/2019/03/21/你的问题/","excerpt":"","text":"你的问题是想法太多读书太少战术上的勤奋掩盖不了战略上的错误 个人的成长 公司的成长 反思","categories":[{"name":"人生","slug":"人生","permalink":"http://yoursite.com/categories/人生/"}],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://yoursite.com/tags/杂谈/"}]},{"title":"python 总结2","slug":"python-总结2","date":"2019-03-21T10:32:36.000Z","updated":"2019-06-05T01:06:54.377Z","comments":true,"path":"2019/03/21/python-总结2/","link":"","permalink":"http://yoursite.com/2019/03/21/python-总结2/","excerpt":"","text":"函数定义方式函数名，形参，实参，返回值 函数调用方式第一种：参数按顺序从第一个参数往后排#标准调用1234567# -*- coding: UTF-8 -*- def normal_invoke(x, y): print &quot;--normal_invoke:--&quot; print &quot;x is %d&quot; %x print &quot;y is %d&quot; %y #标准调用 normal_invoke(1, 2) 第二种：#关键字调用12345678def keyword_invoke(x, y): print &quot;--keyword_invoke--:&quot; print &quot;x is %d&quot; % x print &quot;y is %d&quot; % y #关键字调用 keyword_invoke(y=1, x=2) 注意：关键调用从哪开始的，从哪以后都必须使用关键字调用除了‘*’收集参数。不能写成这样的：keyword_invoke(y=1, 2)，这样就会报错。 第三种：#非关键字可变长参数(tuple)12345678def normal_tuple_invoke(x, y=2, *values): print &quot;--normal_tuple_invoke--&quot; print &quot;x is %d&quot; % x print &quot;y is %d&quot; % y for value in values: print &quot;tuple&apos;s value has&quot;, value#非关键字可变长参数(tuple) normal_tuple_invoke(1, 3, &apos;xyz&apos;, 123.4) 第四种：#关键字可变长参数(dict)12345678910def keyword_dict_invoke(x, y=2, **value_dict): print &quot;--keyword_dict_invoke--&quot; print &quot;x is %d&quot; % x print &quot;y is %d&quot; % y for key in value_dict: print &quot;key is &quot;, key print &quot;value is &quot;, value_dict[key] #关键字可变长参数(dict) keyword_dict_invoke(y=1, x=2, arg2=&apos;def&apos;, arg1=&apos;put at the last&apos;) 第五种：整个函数为参数传回来函数参数类型函数的参数类型可分为：必须参数、默认参数、可变参数（不定长参数）、关键字参数、组合参数，总共5种。 函数返回值它有一个隐含的 return 语句，返回值是 None，类型也是 &apos;NoneType&apos;。 函数作用域 LEGBPython中变量作用域分4种情况： L: local，局部作用域，即函数中定义的变量。E: enclosing,父级函数的局部作用域，即此函数的上级函数的局部作用域。G: globa,全局变量B: build-in,系统模块，如:int,max函数等优先级顺序为：局部作用域(L)&gt;父级函数作用域(E)&gt;全局作用域(G)&gt;系统模块(B)从内到外一级一级找变量 函数的嵌套 在一个函数中定义了另外一个函数 def outer(): def inner(): print(‘inner’) print(‘outer’) inner()outer() 闭包函数 在一个外函数中定义了一个内函数，内函数里运用了外函数的临时变量，并且外函数的返回值是内函数的引用。这样就构成了一个闭包。 一般情况下，在我们认知当中，如果一个函数结束，函数的内部所有东西都会释放掉，还给内存，局部变量都会消失。但是闭包是一种特殊情况，如果外函数在结束的时候发现有自己的临时变量将来会在内部函数中用到，就把这个临时变量绑定给了内部函数，然后自己再结束。12345678910111213141516171819202122#闭包函数的实例# outer是外部函数 a和b都是外函数的临时变量def outer( a ): b = 10 # inner是内函数 def inner(): #在内函数中 用到了外函数的临时变量 print(a+b) # 外函数的返回值是内函数的引用 return innerif __name__ == &apos;__main__&apos;: # 在这里我们调用外函数传入参数5 #此时外函数两个临时变量 a是5 b是10 ，并创建了内函数，然后把内函数的引用返回存给了demo # 外函数结束的时候发现内部函数将会用到自己的临时变量，这两个临时变量就不会释放，会绑定给这个内部函数 demo = outer(5) # 我们调用内部函数，看一看内部函数是不是能使用外部函数的临时变量 # demo存了外函数的返回值，也就是inner函数的引用，这里相当于执行inner函数 demo() # 15 demo2 = outer(7) demo2()#17 递归函数递归函数就是函数在内部调用自身。 必须有一个明确的递归结束条件，称为递归出口。 注意： 切勿忘记递归出口，避免函数无限调用。12345def fact(n): if n == 1: return 1 else: return n * fact( n-1 ) 高阶函数函数本身可以赋值给变量；func = math.sqrt允许将函数本身作为参数传入另一个函数；允许返回一个函数 内置函数mapmap(fun, lst)，将传入的函数变量func作用到lst变量的每个元素中，并将结果组成新的列表返回 123456# li = [1,2,3,5,5,6,7,8,9,9,8,3] 利用生成器功能，写一个所有数值乘以2的功能。list(map(lambda x:x*2,li))def odd(x): return x%2 ==1filter(odd,li)list(filter(lambda x:x&gt;7,li)) filterfilter（func, lst），将func作用于lst的每个元素，然后根据返回值是True或False判断是保留还是丢弃该元素。 sortedsorted() 函数对所有可迭代的对象进行排序操作。 sorted 语法： sorted(iterable[, cmp[, key[, reverse]]]) 参数说明： iterable – 可迭代对象。cmp – 比较的函数，这个具有两个参数，参数的值都是从可迭代对象中取出，此函数必须遵守的规则为，大于则返回1，小于则返回-1，等于则返回0。key – 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。reverse – 排序规则，reverse = True 降序 ， reverse = False 升序（默认）。 L=[(‘b’,2),(‘a’,1),(‘c’,3),(‘d’,4)] sorted(L, cmp=lambda x,y:cmp(x[1],y[1])) # 利用cmp函数 reducereduce（func（x,y），lst），其中func必须有两个参数。每次func计算的结果继续和序列的下一个元素做累积计算。 zip匿名函数sorted 常用， map reduce 建议用列表推导式lambda函数的语法只包含一个语句，如下： lambda [arg1 [,arg2,…..argn]]:expressionlambda 表达式与 def 的主要不同点: 可以立刻传递(无需变量)在内部只能包含一行代码自动返回结果既没有文档字符串, 也没有名称使用了不同且不常见的语法 如下实例：12345#!/usr/bin/python# -*- coding: UTF-8 -*- # 可写函数说明sum = lambda arg1, arg2: arg1 + arg2; 三元运算res = “真大王” if name == “alex” else “假大王”非python： 判断条件（返回布尔值）？为真时的结果：为假时的结果 列表推导式列表推导式，使用一句表达式构造一个新列表，可包含过滤、转换等操作。 语法：[exp for item in collection if codition] 生成器表达式相比列表表达式，只不过将[]换成了()，更加省内存。生成器表达式并不真正的创建数字列表，而是返回一个生成器对象，此对象在每次计算出一个条目后，把这个条目”产生”(yield)出来。生成器表达式使用了”惰性计算”或称作”延时求值”的机制。g=l=(‘egg%s’ %i for i in range(10000))print(next(g)) 1234567#取出单价&gt;10000with open(&apos;b.txt&apos;) as f: res=(line.split() for line in f) # print(res) dic_g=(&#123;&apos;name&apos;:i[0],&apos;price&apos;:i[1],&apos;count&apos;:i[2]&#125; for i in res if float(i[1]) &gt; 10000) print(dic_g)&lt;br&gt;----&gt; &lt;generator object &lt;genexpr&gt; at 0x0000000001E05888&gt; print(list(dic_g))&lt;br&gt;----&gt; [&#123;&apos;name&apos;: &apos;tesla&apos;, &apos;price&apos;: &apos;1000000&apos;, &apos;count&apos;: &apos;1&apos;&#125;, &#123;&apos;name&apos;: &apos;lenovo&apos;, &apos;price&apos;: &apos;30000&apos;, &apos;count&apos;: &apos;3&apos;&#125;] 生成器函数当生成器执行到最后时，它就产生一个 StopIteration 异常，然后就停止了，当生成器函数中有return时， 这个异常的值就是return的值，如果没有return，异常的值为空； 生成器 相关操作迭代器一个实现了iter方法的对象时可迭代的，一个实现next方法的对象是迭代器 可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。 可以使用isinstance()判断一个对象是否是Iterator对象： from collections import Iteratorisinstance((x for x in range(10)), Iterator)Trueisinstance([], Iterator)Falseisinstance({}, Iterator)Falseisinstance(‘abc’, Iterator)False 生成器都是Iterator对象，但list、dict、str虽然是Iterable（可迭代对象），却不是Iterator（迭代器）。 把list、dict、str等Iterable变成Iterator可以使用iter()函数： 1234567891011121314151617s=&apos;hello&apos; #字符串是可迭代对象，但不是迭代器l=[1,2,3,4] #列表是可迭代对象，但不是迭代器t=(1,2,3) #元组是可迭代对象，但不是迭代器d=&#123;&apos;a&apos;:1&#125; #字典是可迭代对象，但不是迭代器set=&#123;1,2,3&#125; #集合是可迭代对象，但不是迭代器# *************************************f=open(&apos;test.txt&apos;) #文件是可迭代对象，是迭代器 #如何判断是可迭代对象，只有__iter__方法，执行该方法得到的迭代器对象。# 及可迭代对象通过__iter__转成迭代器对象from collections import Iterator #迭代器from collections import Iterable #可迭代对象 print(isinstance(s,Iterator)) #判断是不是迭代器print(isinstance(s,Iterable)) #判断是不是可迭代对象 #把可迭代对象转换为迭代器 协程函数在使用装饰器时，在碰到yield时，停止执行，并返回yield的返回值。协程函数可以对yield的返回值进行赋值， 装饰器使用send()函数。def test(name): print(‘%s welcome’ %name) while True: age=yield print(‘%s is %s’ %(name,age)) t=test(‘andy’) 初始化，必须先进行初始化，否则会报错next(t) 使用send() 给yield传值,yield将得到的值赋值给ageprint(t.send(‘22’))print(‘=========’)print(t.send(‘33’)) 12345678910# 首先获得Iterator对象:it = iter([1, 2, 3, 4, 5])# 循环:while True: try: # 获得下一个值: x = next(it) except StopIteration: # 遇到StopIteration就退出循环 break 装饰器12345678910#### 编写装饰器，为每个函数加上统计运行时间的功能 提示：在函数开始执行时加上start=time.time()就可纪录当前执行的时间戳，函数执行结束后在time.time() - start就可以拿到执行所用时间import timedef time_decorator(func): def inner(*args,**kwargs): start = time.time() res = func(*args,**kwargs): end = time.time() return res return inner 常用模块timedatetimerandomossysjsonpickleshelvexmlhashlibloggingreshutilhttps://www.cnblogs.com/wj-1314/p/8490822.html 文件操作python中的文件对象：文件对象不仅可以用来访问普通的磁盘文件, 而且也可以访问任何其它类型抽象层面上的”文件”. 一旦设置了合适的”钩子”, 你就可以访问具有文件类型接口的其它对象, 就好像访问的是普通文件一样. 123open(&apos;filename&apos;)with open(&apos;filename&apos;) as f: pass open函数使用一个文件名作为唯一的强制参数，然后返回一个文件对象。模式和缓冲参数都是可选的，默认为只读模式打开文件。使用with即使发生错误可以关闭文件，下面列出文件对象的访问的模式： 12345678910111213141516171819202122232425262728文件模式 操作r 以只读方式打开rU 或 Ua 以读方式打开, 同时提供通用换行符支持 (PEP 278)w 以写方式打开 (必要时清空)a 以追加模式打开 (从 EOF 开始, 必要时创建新文件)r+ 以读写模式打开w+ 以读写模式打开 (参见 w )a+ 以读写模式打开 (参见 a )rb 以二进制读模式打开wb 以二进制写模式打开 (参见 w )ab 以二进制追加模式打开 (参见 a )rb+ 以二进制读写模式打开 (参见 r+ )wb+ 以二进制读写模式打开 (参见 w+ )ab+ 以二进制读写模式打开 (参见 a+ )x 如果文件存在报错，不存在则创建***加b模式打开，不可以在指定encoding，切写入时也需要转换为字节写入文件下面是一些打开文件的例子:f = open(&apos;/etc/motd&apos;) # 以读方式打开f = open(&apos;test&apos;, &apos;w&apos;) # 以写方式打开f = open(&apos;data&apos;, &apos;r+&apos;) # 以读写方式打开f = open(&apos;io.sys&apos;, &apos;rb&apos;) # 以二进制读模式打开bytes 字符串转换字节类型n=bytes(李杰,encoding=&apos;utf-8&apos;)[转换的字符，可以是变量，转换后的编码]字节转换为字符串str(bytes(李杰,encoding=&apos;utf-8&apos;),encoding=&apos;utf-8)文件操作 文件方法可以分为四类: 输入, 输出, 文件内移动, 以及杂项操作.读readreadlinereadlines 写write 移动seektruncatetell 12345678import os with open(&apos;a.txt&apos;,&apos;r&apos;,encoding=&apos;utf-8&apos;) as f_r,open(&apos;b.txt&apos;,&apos;w&apos;,encoding=&apos;utf-8&apos;) as f_w: for line in f_r: if &apos;不要回答&apos; in line: line = line.replace(&apos;不要回答&apos;,&apos;绝对不能回复&apos;) f_w.write(line) os.remove(&apos;a.txt&apos;) os.rename(&apos;b.txt&apos;,&apos;a.txt&apos;) 其它1234567891011121314151617181920212223文件对象的方法 操作file.close() 关闭文件file.fileno() 返回文件的描述符(file descriptor ,FD, 整数值)file.flush() 刷新文件的内部缓冲区file.isatty() 判断 file 是否是一个类 tty 设备file.nexta() 返回文件的下一行(类似于 file.readline() ), 或在没有其它行时引发 StopIteration 异常file.read(size=-1) 从文件读取 size 个字节, 当未给定 size 或给定负值的时候, 读取剩余的所有字节, 然后作为字符串返回.如果打开模式无b,则read按字符读取，否则按字节读取file.readline(size=-1) 从文件中读取并返回一行(包括行结束符), 或返回最大 sizefile=open(&apos;test&apos;,&apos;ab&apos;)file.write(bytes(&apos;hehe&apos;,encoding=&apos;utf-8&apos;)) 向文件写入字符串 (会覆盖原有数据，坑file.close() 关闭文件file.tell获取当前指针的位置file.read()如果打开模式无b,则read按字符读取，否则按字节读取file.fileno文件描述符file.truncat 截断数据，清除文件指针之后的数据file.seek(off, whence=0) 在文件中移动文件指针, 从 whence ( 0 代表文件其始, 1代表当前位置, 2 代表文件末尾)偏移 off 字节,不论是否有中文，都以字节为单位file.truncate(size=file.tell()) 截取文件到最大 size 字节, 默认为当前文件位置file.writelines(seq) 向文件写入字符串序列 seq ; seq 应该是一个返回字符串的可迭代对象file.readlines(sizhint=0) 读取文件的所有行并作为一个列表返回(包含所有的行结束符); 文件系统访问os 模块的文件/目录访问函数 文件处理12345678mkfifo()/mknod()a 创建命名管道/创建文件系统节点remove()/unlink() Delete file 删除文件rename()/renames()b 重命名文件*statc() 返回文件信息symlink() 创建符号链接utime() 更新时间戳tmpfile() 创建并打开(&apos;w+b&apos;)一个新的临时文件walk()a 生成一个目录树下的所有文件名 目录文件夹1234561 chdir()/fchdir()a 改变当前工作目录/通过一个文件描述符改变当前工作目录2 chroot()d 改变当前进程的根目录3 listdir() 列出指定目录的文件4 getcwd()/getcwdu()a返回当前工作目录/功能相同, 但返回一个 Unicode 对象5 mkdir()/makedirs() 创建目录/创建多层目录6 rmdir()/removedirs() 删除目录/删除多层目录 访问/权限12341 access() 检验权限模式2 chmod() 改变权限模式3 chown()/lchown()a 改变 owner 和 group ID/功能相同, 但不会跟踪链接4 umask() 设置默认权限模式 文件描述符操作1231 open() 底层的操作系统 open (对于文件, 使用标准的内建 open() 函数)2 read()/write() 根据文件描述符读取/写入数据3 dup()/dup2() 复制文件描述符号/功能相同, 但是是复制到另一个文件描述符 设备号121 makedev()a 从 major 和 minor 设备号创建一个原始设备号2 major()a /minor()a 从原始设备号获得 major/minor 设备号 路径名的操作os.path 可以完成一些针对路径名的操作. 它提供的函数可以完成管理和操作文件路径名中的各个部分, 获取文件或子目录信息, 文件路径查询等操作os.path 模块中的路径名访问函数 分割1234561 basename() 去掉目录路径, 返回文件名2 dirname() 去掉文件名, 返回目录路径3 join() 将分离的各部分组合成一个路径名4 split() 返回 (dirname(), basename()) 元组5 splitdrive() 返回 (drivename, pathname) 元组6 splitext() 返回 (filename, extension) 元组 信息12341 getatime() 返回最近访问时间2 getctime() 返回文件创建时间3 getmtime() 返回最近文件修改时间4 getsize() 返回文件大小(以字节为单位) 查询1234567exists() 指定路径(文件或目录)是否存在isabs() 指定路径是否为绝对路径isdir() 指定路径是否存在且为一个目录isfile() 指定路径是否存在且为一个文件islink() 指定路径是否存在且为一个符号链接ismount() 指定路径是否存在且为一个挂载点samefile() 两个路径名是否指向同个文件 其它模块123456789101112131415base64 提供二进制字符串和文本字符串间的编码/解码操作binascii 提供二进制和 ASCII 编码的二进制字符串间的编码/解码操作bz2a 访问 BZ2 格式的压缩文件csv 访问 csv 文件(逗号分隔文件)filecmpb 用于比较目录和文件fileinput 提供多个文本文件的行迭代器getopt/optparsea 提供了命令行参数的解析/处理glob/fnmatch 提供 Unix 样式的通配符匹配的功能gzip/zlib 读写 GNU zip( gzip) 文件(压缩需要 zlib 模块)shutil 提供高级文件访问功能c/StringIO 对字符串对象提供类文件接口tarfilea 读写 TAR 归档文件, 支持压缩文件tempfile 创建一个临时文件(名)uu 格式的编码和解码zipfilec 用于读取 ZIP 归档文件的工具 12345678with open(&apos;db1&apos;, &apos;r&apos;, encoding=&quot;utf-8&quot;) as f1, open(&quot;db2&quot;, &apos;w&apos;,encoding=&quot;utf-8&quot;) as f2: times = 0 for line in f1: times += 1 if times &lt;=10: f2.write(line) else: break","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"},{"name":"函数","slug":"Python/函数","permalink":"http://yoursite.com/categories/Python/函数/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"函数模块","slug":"函数模块","permalink":"http://yoursite.com/tags/函数模块/"},{"name":"总结","slug":"总结","permalink":"http://yoursite.com/tags/总结/"}]},{"title":"python 文件处理","slug":"python文件读写","date":"2019-03-21T10:32:36.000Z","updated":"2019-04-23T07:25:58.318Z","comments":true,"path":"2019/03/21/python文件读写/","link":"","permalink":"http://yoursite.com/2019/03/21/python文件读写/","excerpt":"","text":"三元运算123a = 2b = 3val = a if a &lt; b else b 读文件123f = open(file=&apos;d:/hello.txt&apos;,mode=&apos;r,encoding=&apos;utf-8&apos;)data = f.read()f.close 二进制模式 mode = b 智能检测编码 chardet1234567import chardetf = open(&apos;log&apos;,mode=&apos;rb&apos;)data = f.read()f.close()result = chardet.detect(data)print(result)data.decode(&quot;gb2312&quot;) 安装 pip3 install chardet大文件处理 1234f = open(&quot;log&quot;,&apos;r&apos;,encoding=&quot;gbk&quot;)for line in f: print(line)f.close() 写文件(创建新文件，清空数据)123f = open(&apos;log&apos;,&apos;w&apos;,encoding=&apos;gbk&apos;)f.write(&quot;helow&quot;)f.close() 二进制写 123f = open(&apos;log&apos;,&apos;wb&apos;)f.write(&quot;helow&quot;,encoding=&apos;gbk&apos;)f.close() 追加文件123f = open(&apos;log&apos;,&apos;ab&apos;)f.write(&quot;hellow&quot;,encoding=&apos;gbk&apos;)f.close 混合读写 读写模式 123f = open(&apos;log&apos;, &apos;r+&apos;)f.read()f.write(&quot;hello&quot;) 写读模式（清空原文件），几乎无用 123f = open(&apos;log&apos;, &apos;w+&apos;)f.read()f.write(&quot;hello&quot;) 常用函数flush #强制把内存刷新到硬盘read #按字符读tell #当前文件光标位置，按字节来度seek #改变光标位置，按字节读truncate #按当前位置截断文件（3,6） 6-&gt;从头开始截取6个 文件修改（占内存或占硬盘） 占硬盘f1 = “log.txt”f_new = “log_new.txt”old_str = “alex”new_str = “david”f = open(f1,”r”,encoding=”utf-8”)f_new = open(f_new,”w”,encoding=”utf-8”)for line in f: if old_str in line: line = line.replace(old_str,new_str) f_new.write(line)f.close()f_new.close()os.rename(f_new,f1) 占内存","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"文件","slug":"文件","permalink":"http://yoursite.com/tags/文件/"},{"name":"Ch2","slug":"Ch2","permalink":"http://yoursite.com/tags/Ch2/"}]},{"title":"python的两种注释方式","slug":"python注释","date":"2019-03-20T10:32:36.000Z","updated":"2019-04-18T06:11:30.168Z","comments":true,"path":"2019/03/20/python注释/","link":"","permalink":"http://yoursite.com/2019/03/20/python注释/","excerpt":"","text":"为程序添加注释可以用来解释程序某些部分的作用和功能，提高程序的可读性。除此之外，注释也是调试程序的重要方式。在某些时候，我们不希望编译、执行程序中的某些代码，这时就可以将这些代码注释掉。Python 语言允许在任何地方插入空字符或注释，但不能插入到标识符和字符串中间。Python 源代码的注释有两种形式，分别是单行注释和多行注释： 单行注释Python 使用井号（＃）表示单行注释的开始，跟在“＃”号后面直到这行结束为止的代码都将被解释器忽略。单行注释就是在程序中注释一行代码，在Python 程序中将井号（＃）放在需要注释的内容之前就可以了。 多行注释多行注释是指一次性将程序中的多行代码注释掉，在 Python 程序中使用三个单引号或三个双引号将注释的内容括起来。 1234567891011#这是一行简单的注释print (&quot;Hello World!&quot;)&apos;&apos;&apos;这里面的内容全部是多行注释Python语言真的很简单&apos;&apos;&apos;# print(&quot;这行代码被注释了，将不会被编译、执行！&quot;)&quot;&quot;&quot;这是用三个双引号括起来的多行注释Python 同样是允许的&quot;&quot;&quot;","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"Python 注释","slug":"Python-注释","permalink":"http://yoursite.com/tags/Python-注释/"}]},{"title":"python 元组","slug":"python元组","date":"2019-03-20T10:32:36.000Z","updated":"2019-04-18T06:11:30.189Z","comments":true,"path":"2019/03/20/python元组/","link":"","permalink":"http://yoursite.com/2019/03/20/python元组/","excerpt":"","text":"元组是有序的不可变 切片1(1,2,3,4)[2:5]","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"Python 元组","slug":"Python-元组","permalink":"http://yoursite.com/tags/Python-元组/"}]},{"title":"python 字符串函数","slug":"python字符串","date":"2019-03-20T10:32:36.000Z","updated":"2019-04-18T21:08:07.948Z","comments":true,"path":"2019/03/20/python字符串/","link":"","permalink":"http://yoursite.com/2019/03/20/python字符串/","excerpt":"","text":"字符串是有序的字符集合 有序 不可变 判断是否是数字12&apos;3&apos;.isdigit()&apos;33.3&apos;.isdecimal() 全部小写1&apos;aB&apos;.casefold() 查找1&apos;aB&apos;.find(&apos;o&apos;) 格式化12a = &quot; hello &#123;name&#125;&quot;a.format(name=&apos;david&apos;) 返回索引1234a = &quot; hello world&quot;a.index(&apos;o&apos;,5,6)#不存在索引，则报错a.index(&apos;x&apos;) 合法变量12a = &quot; hello&quot;a.isidentifier() 列表字符串拼接12a = [&apos;1&apos;,&apos;2&apos;,&apos;3&apos;]&apos;+&apos;.join(a) 居中12a = &quot;hello&quot;a.center(20,&quot;*&quot;) 大小写123a = &quot;hello&quot;a.lower()a.upper() 去掉转义字符空格12a = &quot;hello /r/n&quot;a.strip() maketrans&amp;translate1234a = &quot;hello8888&quot;b = &quot;ddid##@@@&quot;table = str.maketrans(a,b)a.translate(table) 替换123a = &quot;hello&quot;a.replace(&apos;h&apos;,&apos;H&apos;)a.replace(&apos;l&apos;,&apos;o&apos;,2) 分割123a = &quot;hello&quot;a.split(&apos;l&apos;,1)a.rsplit(&apos;l&apos;,1)","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"Python 字符串","slug":"Python-字符串","permalink":"http://yoursite.com/tags/Python-字符串/"}]},{"title":"python 字典列表字符串转换","slug":"python字典列表字符串转换","date":"2019-03-20T10:32:36.000Z","updated":"2019-04-19T03:08:12.384Z","comments":true,"path":"2019/03/20/python字典列表字符串转换/","link":"","permalink":"http://yoursite.com/2019/03/20/python字典列表字符串转换/","excerpt":"","text":"字典dic = {&apos;name&apos;: &apos;Zara&apos;, &apos;age&apos;: 7, &apos;class&apos;: &apos;First&apos;} 字典转为字符串str(dic) 返回：&lt;type &apos;str&apos;&gt; {&apos;age&apos;: 7, &apos;name&apos;: &apos;Zara&apos;, &apos;class&apos;: &apos;First&apos;} 字典可以转为元组tuple(dict) 返回：(&apos;age&apos;, &apos;name&apos;, &apos;class&apos;) tuple(dict.values()) 返回：(7, &apos;Zara&apos;, &apos;First&apos;) 字典转为列表list(dict) 返回：[&apos;age&apos;, &apos;name&apos;, &apos;class&apos;] dict.values 元组tup=(1, 2, 3, 4, 5) 元组转为字符串str(tup) 返回：&apos;(1, 2, 3, 4, 5)&apos; 元组转为列表list(tup) 返回：[1, 2, 3, 4, 5] 嵌套元组转为字典dict((1,2),(2,3)) 列表nums=[1, 3, 5, 7, 8, 13, 20]; 列表转为字符串str(nums) 返回：&apos;[1, 3, 5, 7, 8, 13, 20]&apos; 列表转为元组print tuple(nums) 返回：(1, 3, 5, 7, 8, 13, 20) 嵌套列表转为字典dict[[1,2],[2,3]] 字符串#字符串转为元组 tuple(eval(“(1,2,3)”)) 返回：(1, 2, 3) #字符串转为列表 list(eval(“(1,2,3)”)) 返回：[1, 2, 3] #字符串转为字典 eval(&quot;{&apos;name&apos;:&apos;ljq&apos;, &apos;age&apos;:24}&quot;)) enumerateenumerate(&apos;abcde&apos;) enumerate([1,2,3,4])","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"Python 字典列表字符串转换","slug":"Python-字典列表字符串转换","permalink":"http://yoursite.com/tags/Python-字典列表字符串转换/"}]},{"title":"python 字典函数","slug":"python字典","date":"2019-03-20T10:32:36.000Z","updated":"2019-04-19T03:08:12.368Z","comments":true,"path":"2019/03/20/python字典/","link":"","permalink":"http://yoursite.com/2019/03/20/python字典/","excerpt":"","text":"字典是键值对的数据类型,key不可以重复，必须是不可变类型，可hash， 字典是无序的。 语法123456info = &#123; ‘name1’:&apos;tt&apos;, ‘nmae2’:&apos;ttt&apos; ‘david’：[24,&apos;beijing&apos;],&#125;info[&apos;david&apos;] 增加1info[&apos;stu1&apos;]=&apos;cat&apos; 获取1234#没有返回Noneinfo.get(&apos;stu1&apos;)#没有报错info[&apos;stu1&apos;] 删除123info.pop(&apos;stu1&apos;)#随机删除info.popitem() 多级字典嵌套123zoo = &#123; &quot;爬行馆&quot;:&#123;&quot;a1&quot;:&quot;lizard&quot;&#125;,&#125; 获取键12info.keys()&#125; 获取值1info.values() 获取items1info.items() 创建字典fromkeys1info.fromkeys([&apos;A&apos;,&apos;B&apos;,&apos;C&apos;]) 更新字典123dic2 = &#123;&quot;k1&quot;: &quot;v1111&quot;, &quot;a&quot;: &quot;b&quot;&#125;dic2.update(&#123;&quot;k1&quot;: &quot;v1111&quot;, &quot;a&quot;: &quot;b&quot;, &quot;k3&quot;: &quot;v3&quot;&#125;)print(&quot;Value : %s&quot; % dic2) 字典循环123456#高效for k in info: print(k,info[k])#低效for k,v in info.items(): print(k,v)","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"Python 字典","slug":"Python-字典","permalink":"http://yoursite.com/tags/Python-字典/"}]},{"title":"python 字符编码","slug":"python字符编码","date":"2019-03-20T10:32:36.000Z","updated":"2019-04-30T02:50:36.432Z","comments":true,"path":"2019/03/20/python字符编码/","link":"","permalink":"http://yoursite.com/2019/03/20/python字符编码/","excerpt":"","text":"字符集与字符编码 ascii ISO-8859-1 通常叫 做Latin-1，向下兼容ASCII，此字符集支持部分于欧洲使用的语言 GB2312/GBK 这就是汉字的国标码，专门用来表示汉字，是双字节编码，而英文字母和iso8859-1一致（兼容iso8859-1编码）。其中gbk编码能够用来同时表示繁体字和简体字，而gb2312只能表示简体字，gbk是兼容gb2312编码的。 unicode 万国码 cp936 windows中文默认的编码 utf-8 linux默认的编码Unicode也是一种字符编码方法，不过它是由国际组织设计，可以容纳全世界所有语言文字的编码方案。Unicode的学名是”Universal Multiple-Octet Coded Character Set”，简称为UCS。UCS可以看作是”Unicode Character Set”的缩写。也就是说,采用这种编码方式后,世界上所有的语言字符都有一个UNICODE编码(一个数字).UNICODE虽然为所有语言虽有字符都编了一个号,但是它并未规定如何存储,传输这些UNICODE字符,例如对于”中a”,可以采用UNICODE编码来存储,这样它将占用4个字节,但其实字符”a”用一个字节就可以表示,字符”中”才需要两个字节表示,这样可以节省50%的空间,呵呵,如果在考虑到大字节序,小字节序等等,这样又可以产生不少编码变种,例如UTF-8,UTF-16等等,只要软件能够识别它们就可以了. 计算机采用UNICODE之后,内存中并不存放UNICODE字符的编码, 而是存放字符在UNICODE字符集中的序号(如果是ANSI字符,它们的序号和UNICODE编码相同). python3默认的是unicode编码，python2不会自动把文件编码转换为unicode存在内存里，需要转码： py3 文件默认编码 utf-8 字符串 编码是 unicode py2 文件默认编码是 ascii 字符串 编码 默认是ascii 如果文件头声明了gbk, 那字符串的编码就是gbk unicode 单独类型 sys.getdefaultencoding()来获取默认编码 decode1234#python2s = &quot;你好&quot;s1 = s.decode(&apos;utf-8&apos;)print(type(s1)) encode12#python2s2 = s.encode(&apos;GBK&apos;) 参考[字符集与编码两者关系:] (https://www.cnblogs.com/notbecoder/p/4840783.html)[python2-3编码:] (https://blog.csdn.net/lzy98/article/details/83246222)","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"},{"name":"字符编码","slug":"Python/字符编码","permalink":"http://yoursite.com/categories/Python/字符编码/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"字符编码","slug":"字符编码","permalink":"http://yoursite.com/tags/字符编码/"}]},{"title":"编译型语言和解释型语言","slug":"编译型语言和解释型语言","date":"2019-03-20T10:32:36.000Z","updated":"2019-04-17T04:30:46.063Z","comments":true,"path":"2019/03/20/编译型语言和解释型语言/","link":"","permalink":"http://yoursite.com/2019/03/20/编译型语言和解释型语言/","excerpt":"","text":"众所周知，计算机底层只能识别（并执行）0、1序列的机器码，这表示所有的高级编程语言所编写的代码，最终都要以某种方式被转换成能被计算机识别的0、1序列机器码，方可被计算机接受并执行。这种将代码转换为机器码的方式可分为编译型和解释型这2类： 概念：编译型语言把做好的源程序全部编译成二进制代码的可运行程序。然后，可直接运行这个程序。编译是指在应用源程序执行之前，就将程序源代码“翻译”成目标代码(机器语言)，因此其目标程序可以脱离其语言环境独立执行，使用比较方便、效率 较高。但应用程序一旦需要修改，必须先修改源代码，再重新编译生成新的目标文件(＊ .OBJ)才能执行，只有目标文件而没有源代码，修改很不方便。现在大多数的编程语言都是编译型的。编译程序将源程序翻译成目标程序后保存在另一个文件中，该目标程序可脱离编译程序直接在计算机上多次运行。大多数软件产品都是以目标程序形式发行给用户的，不仅便于直接运行，同时又使他人难于盗用其中的技术C、C++、Fortran、Visual Foxpro、Pascal、Delphi、Ada都是编译实现的。 解释型语言把做好的源程序翻译一句，然后执行一句，直至结束！解释型语言的实现中，翻译器并不产生目标机器代码，而是产生易于执行的中间代码，这种中间代码与机器代码是不同的，中间代码的解释是由软件支持的，不能直接使用硬件，软件解释器通常会导致执行效率较低。用解释型语言编写的程序是由另一个可以理解中间代码的解释程序执行的。与编译程序不同的是，解释程序的任务是逐一将源程序的语句解释成可执行的机器指令，不需要将源程序翻译成目标代码后再执行。释程序的优点是当语句出现语法错误时，可以立即引起程序员注意，而程序员在程序开发期间就能进行校正。对于解释型Basic语言，需要一个专门的解释器解释执行 Basic程序，每条语言只有在执行才被翻译。这种解释型语言每执行一次就翻译一次，因而效率低下。一般地，动态语言都是解释型的，如python、Tcl、Perl、Ruby、VBScript、 JavaScript等。 混合型语言Java很特殊，Java程序也需要编译，但是没有直接编译称为机器语言，而是编译称为字节码，然后在Java虚拟机上用解释方式执行字节码。Python 的也采用了类似Java的编译模式，先将Python程序编译成Python字节码，然后由一个专门的Python字节码解释器负责解释执行字节码。(Java虚拟机对字节码的执行相当于模拟一个cpu，而ruby1.8–在虚拟机还未出现前–是通过解释成语法树执行。) 区别编译型语言 编译型语言最大的优势之一就是其执行速度。用C/C++编写的程序运行速度要比用Java编写的相同程序快30%-70%。 编译型程序比解释型程序消耗的内存更少。 不利的一面——编译器比解释器要难写得多。 编译器在调试程序时提供不了多少帮助——有多少次在你的C语言代码中遇到一个“空指针异常”时，需要花费好几个小时来明确错误到底在代码中的什么位置。 可执行的编译型代码要比相同的解释型代码大许多。例如，C/C++的.exe文件要比同样功能的Java的.class文件大很多。 编译型程序是面向特定平台的因而是平台依赖的。 编译型程序不支持代码中实现安全性——例如，一个编译型的程序可以访问内存的任何区域，并且可以对你的PC做它想做的任何事情（大部分病毒是使用编译型语言编写的 由于松散的安全性和平台依赖性，编译型语言不太适合开发因特网或者基于Web的应用。 解释型语言 解释型语言提供了极佳的调试支持。一名Java程序员只需要几分钟就可以定位并修复一个“空指针异常”，因为Java运行环境不仅指明了异常的性质，而且给出了异常发生位置具体的行号和函数调用顺序（著名的堆栈跟踪信息）。这样的便利是编译型语言所无法提供的。 另一个优势是解释器比编译器容易实现 解释型语言最大的优势之一是其平台独立性 解释型语言也可以保证高度的安全性——这是互联网应用迫切需要的 中间语言代码的大小比编译型可执行代码小很多 平台独立性，以及严密的安全性是使解释型语言成为适合互联网和Web应用的理想语言的2个最重要的因素。 解释型语言存在一些严重的缺点。解释型应用占用更多的内存和CPU资源。这是由于，为了运行解释型语言编写的程序，相关的解释器必须首先运行。解释器是复杂的，智能的，大量消耗资源的程序并且它们会占用很多CPU周期和内存。 由于解释型应用的decode-fetch-execute（解码-抓取-执行）的周期，它们比编译型程序慢很多。 解释器也会做很多代码优化，运行时安全性检查；这些额外的步骤占用了更多的资源并进一步降低了应用的运行速度。","categories":[{"name":"语言","slug":"语言","permalink":"http://yoursite.com/categories/语言/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"python 集合函数","slug":"python集合","date":"2019-03-20T10:32:36.000Z","updated":"2019-04-18T06:57:23.813Z","comments":true,"path":"2019/03/20/python集合/","link":"","permalink":"http://yoursite.com/2019/03/20/python集合/","excerpt":"","text":"定义： 1. 不同元素组 2. 无序 3. 集合中的元素必须是不可变类型 语法1s = &#123;1&#125; 列表元组转集合12li = [1,2,3,2,3]s = set(li) 增加元素1s.add(2) 删除元素123456#随机删除s.pop()#指定删除s.remove(2)#无报错删除s.remove(6) 更新多个值1s.update([1,2,3,3,]) 交集123s1=&#123;9&#125;s.intersection(s1)s&amp;s1 差集123s1=&#123;9&#125;s.difference(s1)s - s1 并集12s.union(s1)s | s1 对称差集，两个集合中不重复的元素12s.symmetric_difference(s1)s^s1 超级子集12s.issubset(s1)s.issuperset(s1) 判断相交1s.isdisjoint(s1)","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"Python 集合","slug":"Python-集合","permalink":"http://yoursite.com/tags/Python-集合/"}]},{"title":"3小时学习Python基础","slug":"python-基础","date":"2019-03-20T10:32:36.000Z","updated":"2019-04-18T09:24:53.645Z","comments":true,"path":"2019/03/20/python-基础/","link":"","permalink":"http://yoursite.com/2019/03/20/python-基础/","excerpt":"","text":"变量variable变量的作用存数据(标记）占内存 variables are used to store information and be referenced and manipulated in a program, labelling data with a descriptive name, it is helpful to think variables as containers hold water. their sole purpose is to label and store data in memory. 变量的定义变量第一个字母不可以是数字，只能是字母数字或下划线的任意组合 python语法关键字不可以用于定义变量 驼峰体 AgeOfXiaoming = 30 下划线体 age_of_xiaoming = 30(官方推荐) 变量的调用a = 1 b = a a = 3, b=? 常量的定义python中无定义常量的语法，约定常量定义全部大写 PI = 3.1415926 用户交互name = input(&quot;what&apos;s your name?&quot;) 注释# 在重要和不好理解的地方加注释 可以用中文或英文 数据类型 整型 int 64位计算机寻址范围-2^63~2^63-1,python3中无long 浮点数 float python默认的精度是17位，就是小数点后16位 123a = 2**63b = 1.1415926type(a) 布尔类型 True False 123a = 10b = 9a &gt; b 复数 13+2.7j 字符串 1234name1 = &apos;小红&apos;name2 = &quot;小明&apos;和&apos;小红&quot; msg = &apos;&apos;&apos;小明和小红小红和小明&apos;&apos;&apos; 字符拼接(不可跨类型) 12name1+name2name1*name2 常用占位符的含义 s : 获取传入对象的__str__方法的返回值，并将其格式化到指定位置 r : 获取传入对象的__repr__方法的返回值，并将其格式化到指定位置 c : 整数：将数字转换成其unicode对应的值，10进制范围为 0 &lt;= i &lt;= 1114111（py27则只支持0-255）；字符：将字符添加到指定位置 o : 将整数转换成 八 进制表示，并将其格式化到指定位置 x : 将整数转换成十六进制表示，并将其格式化到指定位置 d : 将整数、浮点数转换成 十 进制表示，并将其格式化到指定位置 e : 将整数、浮点数转换成科学计数法，并将其格式化到指定位置（小写e） E : 将整数、浮点数转换成科学计数法，并将其格式化到指定位置（大写E） f : 将整数、浮点数转换成浮点数表示，并将其格式化到指定位置（默认保留小数点后6位） F : 同上 g : 自动调整将整数、浮点数转换成 浮点型或科学计数法表示（超过6位数用科学计数法），并将其格式化到指定位置（如果是科学计数则是e；） G : 自动调整将整数、浮点数转换成 浮点型或科学计数法表示（超过6位数用科学计数法），并将其格式化到指定位置（如果是科学计数则是E；） % : 当字符串中存在格式化标志时，需要用 %%表示一个百分号; 可选参数 + 右对齐；正数前加正好，负数前加负号； - 左对齐；正数前无符号，负数前加负号； 空格 右对齐；正数前加空格，负数前加负号； 0 右对齐；正数前无符号，负数前加负号；用0填充空白处 12345678910111213141516171819##!/usr/bin/python3# -*- coding:utf-8 -*-# __author__ = David# email:name = input(&quot;input your name:&quot;)job = input(&quot;input your job:&quot;)age = input(&quot;input your age:&quot;)address = input(&quot;input your address:&quot;)info = &apos;&apos;&apos;------info of %s------Name: %sJob: %sAge: %sAddress %s------ end ------&apos;&apos;&apos; % (name, name, job, age, address)print(info) 字符串转数字 12int(&quot;22&quot;)float(&quot;22&quot;) 列表 创建 12a = [1,2,3]a = list(1,2,3) 查找数值2 1a.index(2) 重复值 123a.count(2)``` 切边 a[:]a[:-1]a[-5:]a[::2]1追加 a.append(“iii”)1插入 a.insert(0,’333’)1修改 a[2] = ‘jack’a[0:2] = ‘jack’1删除 a.pop()1指定删除 a.remove(2)1全局删除 del a[2:6]1循环 for i in a: print(i)12排序不支持数字与字符混合排序 a.sort()1反转 a.reverse()1拼接 a+list1a.extend(list1)1清空 a.clear()1浅拷贝(创建独立的列表值，不影响原列表值) b = a.copy()1enumerate枚举 for i in enumerate(a): print(i)for index,value in enumerate(a): print(index, value)1深copy(内嵌列表)不建议使用，占内存 import copyb = copy.deepcopy(a)12345678910111213141516# 运算符* 算术运算&#123;% asset_img 算术运算.png %&#125; /除法永远返回浮点型(python3)* 比较运算&#123;% asset_img 比较运算.png %&#125;* 逻辑运算&#123;% asset_img 逻辑运算.png %&#125;* 赋值运算&#123;% asset_img 赋值运算.png %&#125;* 成员运算* 身份运算* 位运算# 流程控制* 单分支 if 条件 : 满足条件执行代码 1* 双分支 if 条件: 满足条件执行代码 else: 不满足条件执行代码 1* 多分支 if 条件: 满足条件执行代码 elif 条件: 满足条件执行代码 else: 不满足条件执行代码 12* while循环* dead loop while True: 执行代码 1234* continue &amp; break &gt; break跳出循环 continue执行下次循环* while else #判断循环中间没有断开过 while count &lt; 5: if count = 3: break count++ else: print(&quot;循环全部执行&quot;) 1* 查看变量在内存中的地址 a = 2 print(id(a)) `","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"Python 基础","slug":"Python-基础","permalink":"http://yoursite.com/tags/Python-基础/"}]},{"title":"python 数值转换","slug":"python数值转换","date":"2019-03-20T10:32:36.000Z","updated":"2019-04-19T03:08:12.344Z","comments":true,"path":"2019/03/20/python数值转换/","link":"","permalink":"http://yoursite.com/2019/03/20/python数值转换/","excerpt":"","text":"十进制转二进制 1bin(10) 十进制转八进制 1oct(10) 十进制转16进制 1hex(10) 二进制转十进制 1int(10101010,2) 十六进制转十进制 1int(‘ff&apos;,16) 字符转ASCII 1ord(&apos;a&apos;) ASCII码转字符 1chr(97)","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"Python 数值转换","slug":"Python-数值转换","permalink":"http://yoursite.com/tags/Python-数值转换/"}]},{"title":"python 常用模块函数","slug":"python常用模块","date":"2019-03-20T10:32:36.000Z","updated":"2019-04-18T22:36:21.228Z","comments":true,"path":"2019/03/20/python常用模块/","link":"","permalink":"http://yoursite.com/2019/03/20/python常用模块/","excerpt":"","text":"数值计算： 浮点数高精度12345from decimal import *getcontext()getcontext().prec = 50a = &apos;3.141592688999999999999&apos;Decimal(a) id获取对象的内存地址 type获取对象的类型 hash不可变类型数字、字符串、元组可以用hash, 可变类型列表不可用 enumerate用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"Python 常用模块函数","slug":"Python-常用模块函数","permalink":"http://yoursite.com/tags/Python-常用模块函数/"}]},{"title":"PyCharm使用","slug":"pycharm-使用秘籍","date":"2019-03-20T10:32:36.000Z","updated":"2019-04-17T02:55:47.545Z","comments":true,"path":"2019/03/20/pycharm-使用秘籍/","link":"","permalink":"http://yoursite.com/2019/03/20/pycharm-使用秘籍/","excerpt":"","text":"PyCharm介绍PyCharm是一种Python IDE，带有一整套可以帮助用户在使用Pythhon语言开发时提高工作效率的工具，比如调试、语法高亮、Project管理、代码跳转、智能提示、自动完成、单元测试、版本控制等。此外该IDE提供用于支持Django和Flask等框架下的专业web开发功能。 配置python解释器File-&gt;SettingsSettings-&gt;Project-&gt;Project interpreter-&gt;add local 常用快捷键复制ctrl+d删除ctrl+e切换行shift+enter注释ctrl+shift+/取消缩进 shift+tab查找ctrl+f替换ctrl+h PyCharm IDE安装插件file-&gt;settings-&gt;plugin Git配置file-&gt;settings-&gt;version control发布到github 常用操作指南 tab转space Edit-&gt; Convert Indents 同屏显示两个文件 Move right/ Move down PEP8检测 行尾注释 空两格式#空一格+注释内容 单独行注释 #空一格+注释内容 方法之间空两行","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"PyCharm","slug":"PyCharm","permalink":"http://yoursite.com/tags/PyCharm/"}]},{"title":"hexo的markdown记录","slug":"hexo的markdown记录 ","date":"2019-03-20T10:32:36.000Z","updated":"2019-04-25T05:38:51.135Z","comments":true,"path":"2019/03/20/hexo的markdown记录 /","link":"","permalink":"http://yoursite.com/2019/03/20/hexo的markdown记录 /","excerpt":"","text":"流程图添加支持npm install --save hexo-filter-flowchart 演示 1234567891011start=&gt;start: 开始loginInfo=&gt;inputoutput: 登录数据verifyLogin=&gt;subroutine: 登录验证isSuccess=&gt;condition: 验证成功？respondSuccess=&gt;operation: 响应成功responseFailure=&gt;operation: 响应失败,存储状态end=&gt;end: 结束start-&gt;loginInfo-&gt;verifyLogin-&gt;isSuccessisSuccess(yes)-&gt;respondSuccess-&gt;endisSuccess(no)-&gt;responseFailure-&gt;end 操作模块语法 操作模块 说明 start 开始 end 结束 operation 运行 condition 条件 subroutine 子任务块 inputoutput 输入输出块 多级输入判断 表格 编码 字节流 utf-8 b’\\xe5\\x8c\\x97\\xe4\\xba\\xac’ gbk b’\\xb1\\xb1\\xbe\\xa9’ 图像1&#123;% asset_img 实参形参.png %&#125; 特殊字符[Hexo 中 Markdown 特殊字符的处理方法:] (https://www.jianshu.com/p/a8748bf8df1b)[Markdown特殊字符转义] (https://blog.csdn.net/itas109/article/details/86480207) 链接参考1:Markdown流程图参考2:MarkDown和流程图诠释你的代码start=>start: 开始 loginInfo=>inputoutput: 登录数据 verifyLogin=>subroutine: 登录验证 isSuccess=>condition: 验证成功？ respondSuccess=>operation: 响应成功 responseFailure=>operation: 响应失败,存储状态 end=>end: 结束 start->loginInfo->verifyLogin->isSuccess isSuccess(yes)->respondSuccess->end isSuccess(no)->responseFailure->end{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-0-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-0-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-0\", options);start=>start: 开始|past requirementAnalysis=>operation: 需求分析|past design=>operation: 软件设计|past coding=>operation: 编码|past selfTestingPased=>condition: 自测通过？|approved debug=>operation: debug|invalid submitTestingPased=>condition: 提测通过？|rejected modifyBug=>operation: 修bug|current deploy=>operation: 部署|future end=>end: 结束|future start->requirementAnalysis->design->coding->selfTestingPased selfTestingPased(no)->debug(right)->selfTestingPased selfTestingPased(yes)->submitTestingPased submitTestingPased(yes)->deploy->end submitTestingPased(no)->modifyBug(right)->submitTestingPased{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-1-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-1-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-1\", options);start=>start: 开始|past coding=>operation: 读取并显示菜单|past whileFlagPassed=>condition: 是否循环？|approved chooseMenu=>inputoutput: 选择下级菜单 deploy=>operation: 多级输入判断|future end=>end: 结束|future start->coding->whileFlagPassed whileFlagPassed(no)->chooseMenu(right)->deploy(right)->whileFlagPassed whileFlagPassed(yes)->end{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-2-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-2-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-2\", options);st=>start: 开始 e=>end: 结束 cond0=>condition: 输入 in menu？ cond1=>condition: 输入==q？ cond2=>condition: 输入==r？ cond3=>condition: 输入==其它？ op0=>operation: 执行菜单 op1=>operation: 退出菜单 op2=>operation: 返回菜单 op3=>operation: 不是菜单 op=>operation: 检测输入 st->op->cond0->e cond0(no)->cond1 cond1(no)->cond1 cond2(no)->cond1 cond0(no)->cond1 cond1(no)->cond2 cond2(no)->cond3 cond3(no)->op cond3(no)->op cond3(yes)->op3 op3(right)->op cond0(yes)->op0 cond1(yes)->op1 cond2(yes)->op2 op0(right)->op op1->e op2(right)->op{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-3-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-3-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-3\", options);","categories":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"},{"name":"markdown","slug":"hexo/markdown","permalink":"http://yoursite.com/categories/hexo/markdown/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://yoursite.com/tags/markdown/"}]},{"title":"python 文件头注释","slug":"python文件头注释","date":"2019-03-20T10:32:36.000Z","updated":"2019-04-18T09:24:03.309Z","comments":true,"path":"2019/03/20/python文件头注释/","link":"","permalink":"http://yoursite.com/2019/03/20/python文件头注释/","excerpt":"","text":"指定解释器路径1#!/usr/bin/python 上面这种方式，指定了必须用/usr/bin/python这个解释器来解释本python文件 指定系统环境变量设定的解释器路径1#!/usr/bin/env python 而这种方式，指定了使用linux环境变量$PATH里某个路径下名为python的解释器来解释本python文件。（注意到开头/usr/bin/env是linux里读写环境变量的一个程序）如果环境变量$PATH的内容是/usr/bin:/usr/local/bin:/usr/local/python3/bin，那么上面的注释就意味着会依序寻找这些路径： /usr/bin/python /usr/local/bin/python /usr/local/python3/bin/python第一个存在的路径，就会作为python解释器使用。 标明本py文件的编码类型文本文件保存在硬盘上时，是需要按照一定编码规则来保存的。比如GBK、UTF-8之类。而文本编辑器、阅读器、浏览器打开硬盘上的文本文件时，需要知道这个文本文件的编码规则。1# -*- coding: utf-8 -*- 例如下面这段代码123s = &apos;北京&apos;s.encode(&apos;utf-8&apos;)s.encode(&apos;gbk&apos;) 编码 字节流 utf-8 b’\\xe5\\x8c\\x97\\xe4\\xba\\xac’ gbk b’\\xb1\\xb1\\xbe\\xa9’","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"Python 文件头注释","slug":"Python-文件头注释","permalink":"http://yoursite.com/tags/Python-文件头注释/"}]}]}