{"meta":{"title":"Hexo","subtitle":null,"description":"记录为了更好的成长","author":"David","url":"http://yoursite.com","root":"/"},"pages":[{"title":"categories","date":"2019-03-15T20:50:13.000Z","updated":"2019-04-16T08:13:20.114Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-03-15T20:48:46.000Z","updated":"2019-04-16T08:14:01.050Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"关于我","date":"2019-04-16T07:37:26.000Z","updated":"2019-04-16T07:37:43.315Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"python 常用模块函数","slug":"python常用模块","date":"2019-03-20T10:32:36.000Z","updated":"2019-04-18T07:04:29.770Z","comments":true,"path":"2019/03/20/python常用模块/","link":"","permalink":"http://yoursite.com/2019/03/20/python常用模块/","excerpt":"","text":"数值计算： 浮点数高精度 12345from decimal import *getcontext()getcontext().prec = 50a = &apos;3.141592688999999999999&apos;Decimal(a) 十进制转二进制 1bin(10) 十进制转八进制 1oct(10) 十进制转16进制 1hex(10) 字符转ASCII 1ord(&apos;a&apos;) hash不可变类型数字、字符串、元组可以用hash, 可变类型列表不可用 enumerate用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"Python 常用模块函数","slug":"Python-常用模块函数","permalink":"http://yoursite.com/tags/Python-常用模块函数/"}]},{"title":"3小时学习Python基础","slug":"python-基础","date":"2019-03-20T10:32:36.000Z","updated":"2019-04-18T09:24:53.645Z","comments":true,"path":"2019/03/20/python-基础/","link":"","permalink":"http://yoursite.com/2019/03/20/python-基础/","excerpt":"","text":"变量variable变量的作用存数据(标记）占内存 variables are used to store information and be referenced and manipulated in a program, labelling data with a descriptive name, it is helpful to think variables as containers hold water. their sole purpose is to label and store data in memory. 变量的定义变量第一个字母不可以是数字，只能是字母数字或下划线的任意组合 python语法关键字不可以用于定义变量 驼峰体 AgeOfXiaoming = 30 下划线体 age_of_xiaoming = 30(官方推荐) 变量的调用a = 1 b = a a = 3, b=? 常量的定义python中无定义常量的语法，约定常量定义全部大写 PI = 3.1415926 用户交互name = input(&quot;what&apos;s your name?&quot;) 注释# 在重要和不好理解的地方加注释 可以用中文或英文 数据类型 整型 int 64位计算机寻址范围-2^63~2^63-1,python3中无long 浮点数 float python默认的精度是17位，就是小数点后16位 123a = 2**63b = 1.1415926type(a) 布尔类型 True False 123a = 10b = 9a &gt; b 复数 13+2.7j 字符串 1234name1 = &apos;小红&apos;name2 = &quot;小明&apos;和&apos;小红&quot; msg = &apos;&apos;&apos;小明和小红小红和小明&apos;&apos;&apos; 字符拼接(不可跨类型) 12name1+name2name1*name2 常用占位符的含义 s : 获取传入对象的__str__方法的返回值，并将其格式化到指定位置 r : 获取传入对象的__repr__方法的返回值，并将其格式化到指定位置 c : 整数：将数字转换成其unicode对应的值，10进制范围为 0 &lt;= i &lt;= 1114111（py27则只支持0-255）；字符：将字符添加到指定位置 o : 将整数转换成 八 进制表示，并将其格式化到指定位置 x : 将整数转换成十六进制表示，并将其格式化到指定位置 d : 将整数、浮点数转换成 十 进制表示，并将其格式化到指定位置 e : 将整数、浮点数转换成科学计数法，并将其格式化到指定位置（小写e） E : 将整数、浮点数转换成科学计数法，并将其格式化到指定位置（大写E） f : 将整数、浮点数转换成浮点数表示，并将其格式化到指定位置（默认保留小数点后6位） F : 同上 g : 自动调整将整数、浮点数转换成 浮点型或科学计数法表示（超过6位数用科学计数法），并将其格式化到指定位置（如果是科学计数则是e；） G : 自动调整将整数、浮点数转换成 浮点型或科学计数法表示（超过6位数用科学计数法），并将其格式化到指定位置（如果是科学计数则是E；） % : 当字符串中存在格式化标志时，需要用 %%表示一个百分号; 可选参数 + 右对齐；正数前加正好，负数前加负号； - 左对齐；正数前无符号，负数前加负号； 空格 右对齐；正数前加空格，负数前加负号； 0 右对齐；正数前无符号，负数前加负号；用0填充空白处 12345678910111213141516171819##!/usr/bin/python3# -*- coding:utf-8 -*-# __author__ = David# email:name = input(&quot;input your name:&quot;)job = input(&quot;input your job:&quot;)age = input(&quot;input your age:&quot;)address = input(&quot;input your address:&quot;)info = &apos;&apos;&apos;------info of %s------Name: %sJob: %sAge: %sAddress %s------ end ------&apos;&apos;&apos; % (name, name, job, age, address)print(info) 字符串转数字 12int(&quot;22&quot;)float(&quot;22&quot;) 列表 创建 12a = [1,2,3]a = list(1,2,3) 查找数值2 1a.index(2) 重复值 123a.count(2)``` 切边 a[:]a[:-1]a[-5:]a[::2]1追加 a.append(“iii”)1插入 a.insert(0,’333’)1修改 a[2] = ‘jack’a[0:2] = ‘jack’1删除 a.pop()1指定删除 a.remove(2)1全局删除 del a[2:6]1循环 for i in a: print(i)12排序不支持数字与字符混合排序 a.sort()1反转 a.reverse()1拼接 a+list1a.extend(list1)1清空 a.clear()1浅拷贝(创建独立的列表值，不影响原列表值) b = a.copy()1enumerate枚举 for i in enumerate(a): print(i)for index,value in enumerate(a): print(index, value)1深copy(内嵌列表)不建议使用，占内存 import copyb = copy.deepcopy(a)12345678910111213141516# 运算符* 算术运算&#123;% asset_img 算术运算.png %&#125; /除法永远返回浮点型(python3)* 比较运算&#123;% asset_img 比较运算.png %&#125;* 逻辑运算&#123;% asset_img 逻辑运算.png %&#125;* 赋值运算&#123;% asset_img 赋值运算.png %&#125;* 成员运算* 身份运算* 位运算# 流程控制* 单分支 if 条件 : 满足条件执行代码 1* 双分支 if 条件: 满足条件执行代码 else: 不满足条件执行代码 1* 多分支 if 条件: 满足条件执行代码 elif 条件: 满足条件执行代码 else: 不满足条件执行代码 12* while循环* dead loop while True: 执行代码 1234* continue &amp; break &gt; break跳出循环 continue执行下次循环* while else #判断循环中间没有断开过 while count &lt; 5: if count = 3: break count++ else: print(&quot;循环全部执行&quot;) 1* 查看变量在内存中的地址 a = 2 print(id(a)) `","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"Python 基础","slug":"Python-基础","permalink":"http://yoursite.com/tags/Python-基础/"}]},{"title":"编译型语言和解释型语言","slug":"编译型语言和解释型语言","date":"2019-03-20T10:32:36.000Z","updated":"2019-04-17T04:30:46.063Z","comments":true,"path":"2019/03/20/编译型语言和解释型语言/","link":"","permalink":"http://yoursite.com/2019/03/20/编译型语言和解释型语言/","excerpt":"","text":"众所周知，计算机底层只能识别（并执行）0、1序列的机器码，这表示所有的高级编程语言所编写的代码，最终都要以某种方式被转换成能被计算机识别的0、1序列机器码，方可被计算机接受并执行。这种将代码转换为机器码的方式可分为编译型和解释型这2类： 概念：编译型语言把做好的源程序全部编译成二进制代码的可运行程序。然后，可直接运行这个程序。编译是指在应用源程序执行之前，就将程序源代码“翻译”成目标代码(机器语言)，因此其目标程序可以脱离其语言环境独立执行，使用比较方便、效率 较高。但应用程序一旦需要修改，必须先修改源代码，再重新编译生成新的目标文件(＊ .OBJ)才能执行，只有目标文件而没有源代码，修改很不方便。现在大多数的编程语言都是编译型的。编译程序将源程序翻译成目标程序后保存在另一个文件中，该目标程序可脱离编译程序直接在计算机上多次运行。大多数软件产品都是以目标程序形式发行给用户的，不仅便于直接运行，同时又使他人难于盗用其中的技术C、C++、Fortran、Visual Foxpro、Pascal、Delphi、Ada都是编译实现的。 解释型语言把做好的源程序翻译一句，然后执行一句，直至结束！解释型语言的实现中，翻译器并不产生目标机器代码，而是产生易于执行的中间代码，这种中间代码与机器代码是不同的，中间代码的解释是由软件支持的，不能直接使用硬件，软件解释器通常会导致执行效率较低。用解释型语言编写的程序是由另一个可以理解中间代码的解释程序执行的。与编译程序不同的是，解释程序的任务是逐一将源程序的语句解释成可执行的机器指令，不需要将源程序翻译成目标代码后再执行。释程序的优点是当语句出现语法错误时，可以立即引起程序员注意，而程序员在程序开发期间就能进行校正。对于解释型Basic语言，需要一个专门的解释器解释执行 Basic程序，每条语言只有在执行才被翻译。这种解释型语言每执行一次就翻译一次，因而效率低下。一般地，动态语言都是解释型的，如python、Tcl、Perl、Ruby、VBScript、 JavaScript等。 混合型语言Java很特殊，Java程序也需要编译，但是没有直接编译称为机器语言，而是编译称为字节码，然后在Java虚拟机上用解释方式执行字节码。Python 的也采用了类似Java的编译模式，先将Python程序编译成Python字节码，然后由一个专门的Python字节码解释器负责解释执行字节码。(Java虚拟机对字节码的执行相当于模拟一个cpu，而ruby1.8–在虚拟机还未出现前–是通过解释成语法树执行。) 区别编译型语言 编译型语言最大的优势之一就是其执行速度。用C/C++编写的程序运行速度要比用Java编写的相同程序快30%-70%。 编译型程序比解释型程序消耗的内存更少。 不利的一面——编译器比解释器要难写得多。 编译器在调试程序时提供不了多少帮助——有多少次在你的C语言代码中遇到一个“空指针异常”时，需要花费好几个小时来明确错误到底在代码中的什么位置。 可执行的编译型代码要比相同的解释型代码大许多。例如，C/C++的.exe文件要比同样功能的Java的.class文件大很多。 编译型程序是面向特定平台的因而是平台依赖的。 编译型程序不支持代码中实现安全性——例如，一个编译型的程序可以访问内存的任何区域，并且可以对你的PC做它想做的任何事情（大部分病毒是使用编译型语言编写的 由于松散的安全性和平台依赖性，编译型语言不太适合开发因特网或者基于Web的应用。 解释型语言 解释型语言提供了极佳的调试支持。一名Java程序员只需要几分钟就可以定位并修复一个“空指针异常”，因为Java运行环境不仅指明了异常的性质，而且给出了异常发生位置具体的行号和函数调用顺序（著名的堆栈跟踪信息）。这样的便利是编译型语言所无法提供的。 另一个优势是解释器比编译器容易实现 解释型语言最大的优势之一是其平台独立性 解释型语言也可以保证高度的安全性——这是互联网应用迫切需要的 中间语言代码的大小比编译型可执行代码小很多 平台独立性，以及严密的安全性是使解释型语言成为适合互联网和Web应用的理想语言的2个最重要的因素。 解释型语言存在一些严重的缺点。解释型应用占用更多的内存和CPU资源。这是由于，为了运行解释型语言编写的程序，相关的解释器必须首先运行。解释器是复杂的，智能的，大量消耗资源的程序并且它们会占用很多CPU周期和内存。 由于解释型应用的decode-fetch-execute（解码-抓取-执行）的周期，它们比编译型程序慢很多。 解释器也会做很多代码优化，运行时安全性检查；这些额外的步骤占用了更多的资源并进一步降低了应用的运行速度。","categories":[{"name":"语言","slug":"语言","permalink":"http://yoursite.com/categories/语言/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"python 元组","slug":"python元组","date":"2019-03-20T10:32:36.000Z","updated":"2019-04-18T06:11:30.189Z","comments":true,"path":"2019/03/20/python元组/","link":"","permalink":"http://yoursite.com/2019/03/20/python元组/","excerpt":"","text":"元组是有序的不可变 切片1(1,2,3,4)[2:5]","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"Python 元组","slug":"Python-元组","permalink":"http://yoursite.com/tags/Python-元组/"}]},{"title":"python 字典函数","slug":"python字典","date":"2019-03-20T10:32:36.000Z","updated":"2019-04-18T06:12:24.721Z","comments":true,"path":"2019/03/20/python字典/","link":"","permalink":"http://yoursite.com/2019/03/20/python字典/","excerpt":"","text":"字典是键值对的数据类型,key不可以重复，必须是不可变类型，可hash， 字典是无序的。 语法123456info = &#123; ‘name1’:&apos;tt&apos;, ‘nmae2’:&apos;ttt&apos; ‘david’：[24,&apos;beijing&apos;],&#125;info[&apos;david&apos;] 增加1info[&apos;stu1&apos;]=&apos;cat&apos; 获取1234#没有返回Noneinfo.get(&apos;stu1&apos;)#没有报错info[&apos;stu1&apos;] 删除123info.pop(&apos;stu1&apos;)#随即删除info.popitem() 多级字典嵌套123zoo = &#123; &quot;爬行馆&quot;:&#123;&quot;a1&quot;:&quot;lizard&quot;&#125;,&#125; 获取键12info.keys()&#125; 获取值1info.values() 获取items1info.items() 创建字典fromkeys1info.fromkeys([&apos;A&apos;,&apos;B&apos;,&apos;C&apos;]) 更新字典123dic2 = &#123;&quot;k1&quot;: &quot;v1111&quot;, &quot;a&quot;: &quot;b&quot;&#125;dic2.update(&#123;&quot;k1&quot;: &quot;v1111&quot;, &quot;a&quot;: &quot;b&quot;, &quot;k3&quot;: &quot;v3&quot;&#125;)print(&quot;Value : %s&quot; % dic2) 字典循环123456#高效for k in info: print(k,info[k])#低效for k,v in info.items(): print(k,v)","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"Python 字典","slug":"Python-字典","permalink":"http://yoursite.com/tags/Python-字典/"}]},{"title":"python 字符串函数","slug":"python字符串","date":"2019-03-20T10:32:36.000Z","updated":"2019-04-18T06:11:30.184Z","comments":true,"path":"2019/03/20/python字符串/","link":"","permalink":"http://yoursite.com/2019/03/20/python字符串/","excerpt":"","text":"字符串是有序的字符集合 有序 不可变 判断是否是数字12&apos;3&apos;.isdigit()&apos;33.3&apos;.isdecimal() 全部小写1&apos;aB&apos;.casefold() 查找1&apos;aB&apos;.find(&apos;o&apos;) 格式化12a = &quot; hello &#123;name&#125;&quot;a.format(name=&apos;david&apos;) 返回索引12a = &quot; hello world&quot;a.index(&apos;o&apos;,5,6) 合法变量12a = &quot; hello&quot;a.isidentifier() 列表字符串拼接12a = [&apos;1&apos;,&apos;2&apos;,&apos;3&apos;]&apos;+&apos;.join(a) 居中12a = &quot;hello&quot;a.center(20,&quot;*&quot;) 大小写123a = &quot;hello&quot;a.lower()a.upper() 去掉转义字符空格12a = &quot;hello /r/n&quot;a.strip() maketrans&amp;translate1234a = &quot;hello8888&quot;b = &quot;ddid##@@@&quot;table = str.maketrans(a,b)a.translate(table) 替换123a = &quot;hello&quot;a.replace(&apos;h&apos;,&apos;H&apos;)a.replace(&apos;l&apos;,&apos;o&apos;,2) 分割123a = &quot;hello&quot;a.split(&apos;l&apos;,1)a.rsplit(&apos;l&apos;,1)","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"Python 字符串","slug":"Python-字符串","permalink":"http://yoursite.com/tags/Python-字符串/"}]},{"title":"PyCharm使用","slug":"pycharm-使用秘籍","date":"2019-03-20T10:32:36.000Z","updated":"2019-04-17T02:55:47.545Z","comments":true,"path":"2019/03/20/pycharm-使用秘籍/","link":"","permalink":"http://yoursite.com/2019/03/20/pycharm-使用秘籍/","excerpt":"","text":"PyCharm介绍PyCharm是一种Python IDE，带有一整套可以帮助用户在使用Pythhon语言开发时提高工作效率的工具，比如调试、语法高亮、Project管理、代码跳转、智能提示、自动完成、单元测试、版本控制等。此外该IDE提供用于支持Django和Flask等框架下的专业web开发功能。 配置python解释器File-&gt;SettingsSettings-&gt;Project-&gt;Project interpreter-&gt;add local 常用快捷键复制ctrl+d删除ctrl+e切换行shift+enter注释ctrl+shift+/取消缩进 shift+tab查找ctrl+f替换ctrl+h PyCharm IDE安装插件file-&gt;settings-&gt;plugin Git配置file-&gt;settings-&gt;version control发布到github 常用操作指南 tab转space Edit-&gt; Convert Indents 同屏显示两个文件 Move right/ Move down PEP8检测 行尾注释 空两格式#空一格+注释内容 单独行注释 #空一格+注释内容 方法之间空两行","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"PyCharm","slug":"PyCharm","permalink":"http://yoursite.com/tags/PyCharm/"}]},{"title":"python的两种注释方式","slug":"python注释","date":"2019-03-20T10:32:36.000Z","updated":"2019-04-18T06:11:30.168Z","comments":true,"path":"2019/03/20/python注释/","link":"","permalink":"http://yoursite.com/2019/03/20/python注释/","excerpt":"","text":"为程序添加注释可以用来解释程序某些部分的作用和功能，提高程序的可读性。除此之外，注释也是调试程序的重要方式。在某些时候，我们不希望编译、执行程序中的某些代码，这时就可以将这些代码注释掉。Python 语言允许在任何地方插入空字符或注释，但不能插入到标识符和字符串中间。Python 源代码的注释有两种形式，分别是单行注释和多行注释： 单行注释Python 使用井号（＃）表示单行注释的开始，跟在“＃”号后面直到这行结束为止的代码都将被解释器忽略。单行注释就是在程序中注释一行代码，在Python 程序中将井号（＃）放在需要注释的内容之前就可以了。 多行注释多行注释是指一次性将程序中的多行代码注释掉，在 Python 程序中使用三个单引号或三个双引号将注释的内容括起来。 1234567891011#这是一行简单的注释print (&quot;Hello World!&quot;)&apos;&apos;&apos;这里面的内容全部是多行注释Python语言真的很简单&apos;&apos;&apos;# print(&quot;这行代码被注释了，将不会被编译、执行！&quot;)&quot;&quot;&quot;这是用三个双引号括起来的多行注释Python 同样是允许的&quot;&quot;&quot;","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"Python 注释","slug":"Python-注释","permalink":"http://yoursite.com/tags/Python-注释/"}]},{"title":"python 数值转换","slug":"python数值转换","date":"2019-03-20T10:32:36.000Z","updated":"2019-04-18T06:11:30.173Z","comments":true,"path":"2019/03/20/python数值转换/","link":"","permalink":"http://yoursite.com/2019/03/20/python数值转换/","excerpt":"","text":"十进制转二进制：bin(10) 编译型语言把做好的源程序全部编译成二进制代码的可运行程序。然后，可直接运行这个程序。编译是指在应用源程序执行之前，就将程序源代码“翻译”成目标代码(机器语言)，因此其目标程序可以脱离其语言环境独立执行，使用比较方便、效率 较高。但应用程序一旦需要修改，必须先修改源代码，再重新编译生成新的目标文件(＊ .OBJ)才能执行，只有目标文件而没有源代码，修改很不方便。现在大多数的编程语言都是编译型的。编译程序将源程序翻译成目标程序后保存在另一个文件中，该目标程序可脱离编译程序直接在计算机上多次运行。大多数软件产品都是以目标程序形式发行给用户的，不仅便于直接运行，同时又使他人难于盗用其中的技术C、C++、Fortran、Visual Foxpro、Pascal、Delphi、Ada都是编译实现的。 解释型语言把做好的源程序翻译一句，然后执行一句，直至结束！解释型语言的实现中，翻译器并不产生目标机器代码，而是产生易于执行的中间代码，这种中间代码与机器代码是不同的，中间代码的解释是由软件支持的，不能直接使用硬件，软件解释器通常会导致执行效率较低。用解释型语言编写的程序是由另一个可以理解中间代码的解释程序执行的。与编译程序不同的是，解释程序的任务是逐一将源程序的语句解释成可执行的机器指令，不需要将源程序翻译成目标代码后再执行。释程序的优点是当语句出现语法错误时，可以立即引起程序员注意，而程序员在程序开发期间就能进行校正。对于解释型Basic语言，需要一个专门的解释器解释执行 Basic程序，每条语言只有在执行才被翻译。这种解释型语言每执行一次就翻译一次，因而效率低下。一般地，动态语言都是解释型的，如python、Tcl、Perl、Ruby、VBScript、 JavaScript等。 混合型语言Java很特殊，Java程序也需要编译，但是没有直接编译称为机器语言，而是编译称为字节码，然后在Java虚拟机上用解释方式执行字节码。Python 的也采用了类似Java的编译模式，先将Python程序编译成Python字节码，然后由一个专门的Python字节码解释器负责解释执行字节码。(Java虚拟机对字节码的执行相当于模拟一个cpu，而ruby1.8–在虚拟机还未出现前–是通过解释成语法树执行。) 区别编译型语言 编译型语言最大的优势之一就是其执行速度。用C/C++编写的程序运行速度要比用Java编写的相同程序快30%-70%。 编译型程序比解释型程序消耗的内存更少。 不利的一面——编译器比解释器要难写得多。 编译器在调试程序时提供不了多少帮助——有多少次在你的C语言代码中遇到一个“空指针异常”时，需要花费好几个小时来明确错误到底在代码中的什么位置。 可执行的编译型代码要比相同的解释型代码大许多。例如，C/C++的.exe文件要比同样功能的Java的.class文件大很多。 编译型程序是面向特定平台的因而是平台依赖的。 编译型程序不支持代码中实现安全性——例如，一个编译型的程序可以访问内存的任何区域，并且可以对你的PC做它想做的任何事情（大部分病毒是使用编译型语言编写的 由于松散的安全性和平台依赖性，编译型语言不太适合开发因特网或者基于Web的应用。 解释型语言 解释型语言提供了极佳的调试支持。一名Java程序员只需要几分钟就可以定位并修复一个“空指针异常”，因为Java运行环境不仅指明了异常的性质，而且给出了异常发生位置具体的行号和函数调用顺序（著名的堆栈跟踪信息）。这样的便利是编译型语言所无法提供的。 另一个优势是解释器比编译器容易实现 解释型语言最大的优势之一是其平台独立性 解释型语言也可以保证高度的安全性——这是互联网应用迫切需要的 中间语言代码的大小比编译型可执行代码小很多 平台独立性，以及严密的安全性是使解释型语言成为适合互联网和Web应用的理想语言的2个最重要的因素。 解释型语言存在一些严重的缺点。解释型应用占用更多的内存和CPU资源。这是由于，为了运行解释型语言编写的程序，相关的解释器必须首先运行。解释器是复杂的，智能的，大量消耗资源的程序并且它们会占用很多CPU周期和内存。 由于解释型应用的decode-fetch-execute（解码-抓取-执行）的周期，它们比编译型程序慢很多。 解释器也会做很多代码优化，运行时安全性检查；这些额外的步骤占用了更多的资源并进一步降低了应用的运行速度。","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"Python 数值转换","slug":"Python-数值转换","permalink":"http://yoursite.com/tags/Python-数值转换/"}]},{"title":"python 集合函数","slug":"python集合","date":"2019-03-20T10:32:36.000Z","updated":"2019-04-18T06:57:23.813Z","comments":true,"path":"2019/03/20/python集合/","link":"","permalink":"http://yoursite.com/2019/03/20/python集合/","excerpt":"","text":"定义： 1. 不同元素组 2. 无序 3. 集合中的元素必须是不可变类型 语法1s = &#123;1&#125; 列表元组转集合12li = [1,2,3,2,3]s = set(li) 增加元素1s.add(2) 删除元素123456#随机删除s.pop()#指定删除s.remove(2)#无报错删除s.remove(6) 更新多个值1s.update([1,2,3,3,]) 交集123s1=&#123;9&#125;s.intersection(s1)s&amp;s1 差集123s1=&#123;9&#125;s.difference(s1)s - s1 并集12s.union(s1)s | s1 对称差集，两个集合中不重复的元素12s.symmetric_difference(s1)s^s1 超级子集12s.issubset(s1)s.issuperset(s1) 判断相交1s.isdisjoint(s1)","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"Python 集合","slug":"Python-集合","permalink":"http://yoursite.com/tags/Python-集合/"}]},{"title":"python 集合函数","slug":"python字符编码","date":"2019-03-20T10:32:36.000Z","updated":"2019-04-18T07:51:34.406Z","comments":true,"path":"2019/03/20/python字符编码/","link":"","permalink":"http://yoursite.com/2019/03/20/python字符编码/","excerpt":"","text":"python3默认的是unicode编码，python2不会自动把文件编码转换为unicode存在内存里，需要转码： py3 文件默认编码 utf-8 字符串 编码是 unicode py2 文件默认编码是 ascii 字符串 编码 默认是ascii 如果文件头声明了gbk, 那字符串的编码就是gbk unicode 单独类型 decode1234#python2s = &quot;你好&quot;s1 = s.decode(&apos;utf-8&apos;)print(type(s1)) encode12#python2s2 = s.encode(&apos;GBK&apos;)","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"Python 字符编码","slug":"Python-字符编码","permalink":"http://yoursite.com/tags/Python-字符编码/"}]},{"title":"python 文件头注释","slug":"python文件头注释","date":"2019-03-20T10:32:36.000Z","updated":"2019-04-18T09:24:03.309Z","comments":true,"path":"2019/03/20/python文件头注释/","link":"","permalink":"http://yoursite.com/2019/03/20/python文件头注释/","excerpt":"","text":"指定解释器路径1#!/usr/bin/python 上面这种方式，指定了必须用/usr/bin/python这个解释器来解释本python文件 指定系统环境变量设定的解释器路径1#!/usr/bin/env python 而这种方式，指定了使用linux环境变量$PATH里某个路径下名为python的解释器来解释本python文件。（注意到开头/usr/bin/env是linux里读写环境变量的一个程序）如果环境变量$PATH的内容是/usr/bin:/usr/local/bin:/usr/local/python3/bin，那么上面的注释就意味着会依序寻找这些路径： /usr/bin/python /usr/local/bin/python /usr/local/python3/bin/python第一个存在的路径，就会作为python解释器使用。 标明本py文件的编码类型文本文件保存在硬盘上时，是需要按照一定编码规则来保存的。比如GBK、UTF-8之类。而文本编辑器、阅读器、浏览器打开硬盘上的文本文件时，需要知道这个文本文件的编码规则。1# -*- coding: utf-8 -*- 例如下面这段代码123s = &apos;北京&apos;s.encode(&apos;utf-8&apos;)s.encode(&apos;gbk&apos;) 编码 字节流 utf-8 b’\\xe5\\x8c\\x97\\xe4\\xba\\xac’ gbk b’\\xb1\\xb1\\xbe\\xa9’","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"Python 文件头注释","slug":"Python-文件头注释","permalink":"http://yoursite.com/tags/Python-文件头注释/"}]}]}