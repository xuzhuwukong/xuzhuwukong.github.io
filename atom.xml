<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-06-13T14:12:31.136Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>David</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python 类和对象</title>
    <link href="http://yoursite.com/2019/05/20/python-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2019/05/20/python-类和对象/</id>
    <published>2019-05-20T04:32:36.000Z</published>
    <updated>2019-06-13T14:12:31.136Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><p>面向过程，流程化，设计简单，不容易扩展，扩展需要改动大，比如登录接口，用户，密码，增加email字段<br>面向对象，对象是一个实例，有属性，特征，有方法。比如孙悟空，属性，72变。优点，扩展性强。缺点，编程复杂度高，过度设计。<br>应用于用户需求经常变化，经常改参数，企业内部应用，办公系统。</p><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><pre><code>站在不同的角度，得到不同的分类.class Student(object):    school=&apos;school&apos;    #数据属性    def learn(self):    #函数属性        print(&quot;is learning&quot;)</code></pre><h2 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h2><pre><code>print(Student.__dict__) # 查看类的名称空间print(Student.__dict__[&apos;school&apos;])print(Student.school)    </code></pre><h2 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h2><pre><code>Student.country = &quot;China&quot;</code></pre><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><pre><code>del</code></pre><h2 id="改"><a href="#改" class="headerlink" title="改"></a>改</h2><pre><code>Student.school = &apos;School&apos;</code></pre><h2 id="创造对象"><a href="#创造对象" class="headerlink" title="创造对象"></a>创造对象</h2><pre><code>stu1 = Student()</code></pre><h1 id="构造方法init-和-析构方法del"><a href="#构造方法init-和-析构方法del" class="headerlink" title="构造方法init 和 析构方法del"></a>构造方法<strong>init</strong> 和 析构方法<strong>del</strong></h1><pre><code> __init__个性化定制属性,独有特征 def __init__(self,name,age):    self.name = name    self.age = age调用过程，先产生一个空对象，stu1调用__init__方法，__init__(stu1,name,age)</code></pre><h1 id="属性查找"><a href="#属性查找" class="headerlink" title="属性查找"></a>属性查找</h1><pre><code>Stuendt.learn(stu1)对象---》 类 ---》父类 不会到全局去找，没找到报错</code></pre><h1 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h1><h1 id="绑定方法和非绑定方法"><a href="#绑定方法和非绑定方法" class="headerlink" title="绑定方法和非绑定方法"></a>绑定方法和非绑定方法</h1><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><h1 id="继承和派生"><a href="#继承和派生" class="headerlink" title="继承和派生"></a>继承和派生</h1><h1 id="多态和多态性"><a href="#多态和多态性" class="headerlink" title="多态和多态性"></a>多态和多态性</h1><h1 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h1><h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h1 id="内置方法"><a href="#内置方法" class="headerlink" title="内置方法"></a>内置方法</h1><h2 id="new、init"><a href="#new、init" class="headerlink" title="new、init"></a>new、init</h2><p><strong>new</strong>方法是真正的类构造方法，用于产生实例化对象（空属性）。重写<strong>new</strong>方法可以控制对象的产生过程。<br><strong>init</strong>方法是初始化方法，负责对实例化对象进行属性值初始化，此方法必须返回None，<strong>new</strong>方法必须返回一个对象。重写<strong>init</strong>方法可以控制对象的初始化过程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 使用new来处理单例模式</span><br><span class="line"></span><br><span class="line">class Student:</span><br><span class="line">    __instance = None</span><br><span class="line"></span><br><span class="line">    def __new__(cls, *args, **kwargs):</span><br><span class="line">        if not cls.__instance:</span><br><span class="line">            cls.__instance = object.__new__(cls)</span><br><span class="line">        return cls.__instance</span><br><span class="line"></span><br><span class="line">    def sleep(self):</span><br><span class="line">        print(&apos;sleeping...&apos;)</span><br><span class="line"></span><br><span class="line">stu1 = Student()</span><br><span class="line">stu2 = Student()</span><br><span class="line"></span><br><span class="line">print(id(stu1), id(stu2))  # 两者输出相同</span><br><span class="line">print(stu1 is stu2)  # True</span><br></pre></td></tr></table></figure></p><h2 id="str、repr"><a href="#str、repr" class="headerlink" title="str、repr"></a>str、repr</h2><p>两者的目的都是为了显式的显示对象的一些必要信息，方便查看和调试。<br><strong>str</strong>被print默认调用，<strong>repr</strong>被控制台输出时默认调用。即，使用<strong>str</strong>控制用户展示，使用<strong>repr</strong>控制调试展示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 自定义str来控制print的显示内容，str函数必须return一个字符串对象</span><br><span class="line"># 使用repr = str来偷懒控制台和print的显示一致</span><br><span class="line"></span><br><span class="line">class Student:</span><br><span class="line">    def __init__(self, name, age):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return f&apos;&#123;self.__class__&#125;, &#123;self.name&#125;, &#123;self.age&#125;&apos;</span><br><span class="line">    </span><br><span class="line">    __repr__ = __str__</span><br><span class="line"></span><br><span class="line">stu = Student(&apos;zlw&apos;, 26)</span><br><span class="line">print(stu)  # &lt;class &apos;__main__.Student&apos;&gt;, zlw, 26</span><br></pre></td></tr></table></figure></p><h2 id="call"><a href="#call" class="headerlink" title="call"></a>call</h2><p><strong>call</strong>方法提供给对象可以被执行的能力，就像函数那样，而本质上，函数就是对象，函数就是一个拥有<strong>call</strong>方法的对象。<br>拥有<strong>call</strong>方法的对象，使用callable可以得到True的结果，可以使用（）执行，执行时，可以传入参数，也可以返回值。<br>所以我们可以使用<strong>call</strong>方法来实现实例化对象作为装饰器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 检查一个函数的输入参数个数, 如果调用此函数时提供的参数个数不符合预定义，则无法调用。</span><br><span class="line"></span><br><span class="line"># 单纯函数版本装饰器</span><br><span class="line">def args_num_require(require_num):</span><br><span class="line">    def outer(func):</span><br><span class="line">        def inner(*args, **kw):</span><br><span class="line">            if len(args) != require_num:</span><br><span class="line">                print(&apos;函数参数个数不符合预定义，无法执行函数&apos;)</span><br><span class="line">                return None</span><br><span class="line"></span><br><span class="line">            return func(*args, **kw)</span><br><span class="line">        return inner</span><br><span class="line">    return outer</span><br><span class="line"></span><br><span class="line">@args_num_require(2)</span><br><span class="line">def show(*args):</span><br><span class="line">    print(&apos;show函数成功执行!&apos;)</span><br><span class="line"></span><br><span class="line">show(1)  # 函数参数个数不符合预定义，无法执行函数</span><br><span class="line">show(1,2) # show函数成功执行!</span><br><span class="line">show(1,2,3)  # 函数参数个数不符合预定义，无法执行函数</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># 检查一个函数的输入参数个数,</span><br><span class="line"># 如果调用此函数时提供的参数个数不符合预定义，则无法调用。</span><br><span class="line"></span><br><span class="line"># 实例对象版本装饰器</span><br><span class="line">class Checker:</span><br><span class="line">    def __init__(self, require_num):</span><br><span class="line">        self.require_num = require_num</span><br><span class="line"></span><br><span class="line">    def __call__(self, func):</span><br><span class="line">        self.func = func</span><br><span class="line"></span><br><span class="line">        def inner(*args, **kw):</span><br><span class="line">            if len(args) != self.require_num:</span><br><span class="line">                print(&apos;函数参数个数不符合预定义，无法执行函数&apos;)</span><br><span class="line">                return None</span><br><span class="line"></span><br><span class="line">            return self.func(*args, **kw)</span><br><span class="line">        return inner</span><br><span class="line"></span><br><span class="line">@Checker(2)</span><br><span class="line">def show(*args):</span><br><span class="line">    print(&apos;show函数成功执行!&apos;)</span><br><span class="line"></span><br><span class="line">show(1)  # 函数参数个数不符合预定义，无法执行函数</span><br><span class="line">show(1,2) # show函数成功执行!</span><br><span class="line">show(1,2,3)  # 函数参数个数不符合预定义，无法执行函数</span><br></pre></td></tr></table></figure><h2 id="del"><a href="#del" class="headerlink" title="del"></a>del</h2><p><strong>del</strong>用于当对象的引用计数为0时自动调用。<br><strong>del</strong>一般出现在两个地方：1、手工使用del减少对象引用计数至0，被垃圾回收处理时调用。2、程序结束时调用。<br><strong>del</strong>一般用于需要声明在对象被删除前需要处理的资源回收操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 手工调用del 可以将对象引用计数减一，如果减到0，将会触发垃圾回收</span><br><span class="line"></span><br><span class="line">class Student:</span><br><span class="line"></span><br><span class="line">    def __del__(self):</span><br><span class="line">        print(&apos;调用对象的del方法，此方法将会回收此对象内存地址&apos;)</span><br><span class="line"></span><br><span class="line">stu = Student()  # 调用对象的__del__方法回收此对象内存地址</span><br><span class="line"></span><br><span class="line">del stu</span><br><span class="line"></span><br><span class="line">print(&apos;下面还有程序其他代码&apos;)</span><br></pre></td></tr></table></figure></p><h2 id="iter、next"><a href="#iter、next" class="headerlink" title="iter、next"></a>iter、next</h2><p>这2个方法用于将一个对象模拟成序列。内置类型如列表、元组都可以被迭代，文件对象也可以被迭代获取每一行内容。重写这两个方法就可以实现自定义的迭代对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 定义一个指定范围的自然数类，并可以提供迭代</span><br><span class="line"></span><br><span class="line">class Num:</span><br><span class="line">    def __init__(self, max_num):</span><br><span class="line">        self.max_num = max_num</span><br><span class="line">        self.count = 0</span><br><span class="line">        </span><br><span class="line">    def __iter__(self):</span><br><span class="line">        return self</span><br><span class="line"></span><br><span class="line">    def __next__(self):</span><br><span class="line">        if self.count &lt; self.max_num:</span><br><span class="line">            self.count += 1</span><br><span class="line">            return self.count</span><br><span class="line">        else:</span><br><span class="line">            raise StopIteration(&apos;已经到达临界&apos;)</span><br><span class="line">        </span><br><span class="line">num = Num(10)</span><br><span class="line">for i in num:</span><br><span class="line">    print(i)  # 循环打印1---10</span><br></pre></td></tr></table></figure></p><h2 id="getitem、setitem、delitem"><a href="#getitem、setitem、delitem" class="headerlink" title="getitem、setitem、delitem"></a>getitem、setitem、delitem</h2><p>重写此系列方法可以模拟对象成列表或者是字典，即可以使用key-value的类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">class StudentManager:</span><br><span class="line">    li = []</span><br><span class="line">    dic = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    def add(self, obj):</span><br><span class="line">        self.li.append(obj)</span><br><span class="line">        self.dic[obj.name] = obj</span><br><span class="line"></span><br><span class="line">    def __getitem__(self, item):</span><br><span class="line">        if isinstance(item, int):</span><br><span class="line">            # 通过下标得到对象</span><br><span class="line">            return self.li[item]</span><br><span class="line">        elif isinstance(item, slice):</span><br><span class="line">            # 通过切片得到一串对象</span><br><span class="line">            start = item.start</span><br><span class="line">            stop = item.stop</span><br><span class="line">            return [student for student in self.li[start:stop]]</span><br><span class="line">        elif isinstance(item, str):</span><br><span class="line">            # 通过名字得到对象</span><br><span class="line">            return self.dic.get(item, None)</span><br><span class="line">        else:</span><br><span class="line">            # 给定的key类型错误</span><br><span class="line">            raise TypeError(&apos;你输入的key类型错误!&apos;)</span><br><span class="line"></span><br><span class="line">class Student:</span><br><span class="line">    manager = StudentManager()</span><br><span class="line"></span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">        self.manager.add(self)</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return f&apos;学生: &#123;self.name&#125;&apos;</span><br><span class="line"></span><br><span class="line">    __repr__ = __str__</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stu1 = Student(&apos;小明&apos;)</span><br><span class="line">stu2 = Student(&apos;大白&apos;)</span><br><span class="line">stu3 = Student(&apos;小红&apos;)</span><br><span class="line">stu4 = Student(&apos;胖虎&apos;)</span><br><span class="line"># 当做列表使用</span><br><span class="line">print(Student.manager[0])  # 学生: 小明</span><br><span class="line">print(Student.manager[-1])  # 学生: 胖虎</span><br><span class="line">print(Student.manager[1:3])  # [学生: 大白, 学生: 小红]</span><br><span class="line"></span><br><span class="line"># 当做字典使用</span><br><span class="line">print(Student.manager[&apos;胖虎&apos;])  # 学生: 胖虎</span><br></pre></td></tr></table></figure></p><h2 id="getattr、setattr、delattr"><a href="#getattr、setattr、delattr" class="headerlink" title="getattr、setattr、delattr"></a>getattr、setattr、delattr</h2><p>当使用obj.x = y的时候触发对象的setattr方法，当del obj.x的时候触发对象的delattr方法。<br>当尝试访问对象的一个不存在的属性时 obj.noexist 会触发getattr方法，getattr方法是属性查找中优先级最低的。<br>可以重写这3个方法来控制对象属性的访问、设置和删除。<br><strong>特别注意：如果定义了getattr，而没有任何代码（即只有pass），则所有不存在的属性值都是None而不会报错,可以使用super().<strong>getattr</strong>()方法来处理</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Student:</span><br><span class="line">    def __getattr__(self, item):</span><br><span class="line">        print(&apos;访问一个不存在的属性时候触发&apos;)</span><br><span class="line">        return &apos;不存在&apos;</span><br><span class="line"></span><br><span class="line">    def __setattr__(self, key, value):</span><br><span class="line">        print(&apos;设置一个属性值的时候触发&apos;)</span><br><span class="line">        # self.key = value  # 这样会无限循环</span><br><span class="line">        self.__dict__[key] = value</span><br><span class="line"></span><br><span class="line">    def __delattr__(self, item):</span><br><span class="line">        print(&apos;删除一个属性的时候触发&apos;)</span><br><span class="line">        if self.__dict__.get(item, None):</span><br><span class="line">            del self.__dict__[item]</span><br><span class="line"></span><br><span class="line">stu = Student()</span><br><span class="line">stu.name = &apos;zlw&apos;  # 设置一个属性值的时候触发</span><br><span class="line">print(stu.noexit)  # 访问一个不存在的属性时候触发 , 返回&apos;不存在&apos;</span><br><span class="line">del stu.name  # 删除一个属性的时候触发</span><br></pre></td></tr></table></figure></p><h2 id="getatrribute"><a href="#getatrribute" class="headerlink" title="getatrribute"></a>getatrribute</h2><p>这是一个属性访问截断器，即，在你访问属性时，这个方法会把你的访问行为截断，并优先执行此方法中的代码，此方法应该是属性查找顺序中优先级最高的。<br>属性查找顺序：<br>实例的getattribute–&gt;实例对象字典–&gt;实例所在类字典–&gt;实例所在类的父类(MRO顺序）字典–&gt;实例所在类的getattr–&gt;报错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class People:</span><br><span class="line">    a = 200</span><br><span class="line"></span><br><span class="line">class Student(People):</span><br><span class="line">    a = 100</span><br><span class="line"></span><br><span class="line">    def __init__(self, a):</span><br><span class="line">        self.a = a</span><br><span class="line"></span><br><span class="line">    def __getattr__(self, item):</span><br><span class="line">        print(&apos;没有找到:&apos;, item)</span><br><span class="line"></span><br><span class="line">    def __getattribute__(self, item):</span><br><span class="line">        print(&apos;属性访问截断器&apos;)</span><br><span class="line">        if item == &apos;a&apos;:</span><br><span class="line">            return 1</span><br><span class="line">        return super().__getattribute__(item)</span><br><span class="line"></span><br><span class="line">stu = Student(1)</span><br><span class="line">print(stu.a)  # 1</span><br></pre></td></tr></table></figure></p><h2 id="enter、exit"><a href="#enter、exit" class="headerlink" title="enter、exit"></a>enter、exit</h2><p>这两个方法的重写可以让我们对一个对象使用with方法来处理工作前的准备，以及工作之后的清扫行为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class MySQL:</span><br><span class="line">    def connect(self):</span><br><span class="line">        print(&apos;启动数据库连接，申请系统资源&apos;)</span><br><span class="line"></span><br><span class="line">    def execute(self):</span><br><span class="line">        print(&apos;执行sql命令，操作数据&apos;)</span><br><span class="line"></span><br><span class="line">    def finish(self):</span><br><span class="line">        print(&apos;数据库连接关闭，清理系统资源&apos;)</span><br><span class="line"></span><br><span class="line">    def __enter__(self):  # with的时候触发，并赋给as变量</span><br><span class="line">        self.connect()</span><br><span class="line">        return self</span><br><span class="line"></span><br><span class="line">    def __exit__(self, exc_type, exc_val, exc_tb):  # 离开with语句块时触发</span><br><span class="line">        self.finish()</span><br><span class="line"></span><br><span class="line">with MySQL() as mysql:</span><br><span class="line">    mysql.execute()</span><br><span class="line">    </span><br><span class="line"># 结果:</span><br><span class="line"># 启动数据库连接，申请系统资源</span><br><span class="line"># 执行sql命令，操作数据</span><br><span class="line"># 数据库连接关闭，清理系统资源</span><br></pre></td></tr></table></figure></p><h2 id="get、set、delete、描述符-研究中，待补充）"><a href="#get、set、delete、描述符-研究中，待补充）" class="headerlink" title="get、set、delete、描述符(研究中，待补充）"></a>get、set、delete、描述符(研究中，待补充）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#描述符类(相当于代理)</span><br><span class="line">#定义为了数据描述符：定义了_set_ 和_get_方法的对象</span><br><span class="line">class Foo():</span><br><span class="line">    def __get__(self, instance, owner):</span><br><span class="line">        print(&quot;执行Foo get方法&quot;)</span><br><span class="line">    def __set__(self, instance, value):</span><br><span class="line">        print(&quot;执行Foo set方法&quot;)</span><br><span class="line">    def __delete__(self):</span><br><span class="line">        print(&quot;执行Foo del方法&quot;)</span><br><span class="line"></span><br><span class="line">#主要运行的类:</span><br><span class="line">class Test():</span><br><span class="line">    #类的x属性被Foo代理,所以属性访问优先级也被修改:</span><br><span class="line">    #类属性 &gt; 数据描述符 &gt; 实例属性 &gt; 非实例属性 &gt; __getattr__()</span><br><span class="line">    x = Foo()</span><br><span class="line">    def __init__(self,num):</span><br><span class="line">        self.x = num</span><br><span class="line"></span><br><span class="line">#因为x类属性被Foo代理,触发Foo的set方法,而set方法只是打印了,没有做数据操作,</span><br><span class="line">abc = Test(100)</span><br><span class="line">abc.x</span><br><span class="line">print(abc.__dict__)</span><br><span class="line"></span><br><span class="line"># print输出:-----------</span><br><span class="line"># 执行Foo set方法</span><br><span class="line"># 执行Foo get方法</span><br><span class="line"># &#123;&#125;</span><br><span class="line"># 执行Foo del方法</span><br><span class="line"># print输出:-----------</span><br></pre></td></tr></table></figure><h1 id="双下划线"><a href="#双下划线" class="headerlink" title="双下划线"></a>双下划线</h1><p>默认情况下，Python中的成员函数和成员变量都是公开的(相当于java中的public，或者OC中定义在.h文件中的公开成员变量)。在python中没有public,private等关键词来修饰成员函数和成员变量。为了区分，用下划线来体现。</p><h2 id="1-xxx"><a href="#1-xxx" class="headerlink" title="(1)_xxx"></a>(1)_xxx</h2><p>“单下划线 “ 开始的成员变量相当于私有变量，也叫做保护变量，意思是只有类实例和子类实例能访问到这些变量，需通过类提供的接口进行访问（可以定义有点像java中的getter、setter方法，借助方法访问，而不是直接对变量动刀子）；不能用’from module import *’导入。其实，Python并没有真正的私有化支持，用下划线得到的是伪私有，也就是说如果你强行要用也是可以的，但不符合python的规范。我们应该尽量避免重新定义以下划线开头的变量。</p><h2 id="2-末尾单下划线：var"><a href="#2-末尾单下划线：var" class="headerlink" title="(2)末尾单下划线：var_"></a>(2)末尾单下划线：var_</h2><p>在开发过种中，一个最合适的变量名称已经被一个关键字占用。因此像class、def这样的名称不能用作python中的变量名称。在这样的情况下，你可以使用在关键字未尾附加一个下划线来解决命名冲突问题。<br>同样在PEP8中也对此约定进行了解释。</p><h2 id="3-单下划线："><a href="#3-单下划线：" class="headerlink" title="(3)单下划线：_"></a>(3)单下划线：_</h2><p>python中单下划线和其它语言一样用来表示这个变量是临时的或无关紧要的，抛弃掉这个值。<br>如在循环处理中，我们不需要列表中的索引值，就可以使用“_”抛弃掉此值。<br>for _ in range(10):<br>又如 在拆分元组为单独变量时候， 我们可以把不需要的值使用 _ 作为占位符变量进行抛弃。<br>除了用作临时变量之外，“_”是大多数Python REPL中的一个特殊变量，它表示由解释器评估的最近一个表达式的结果。<br>你可以在一个解释器会话中访问先前计算的结果，或者，你是在动态构建多个对象并与它们交互，无需事先给这些对象分配名字。</p><h2 id="4-xxx"><a href="#4-xxx" class="headerlink" title="(4)__xxx"></a>(4)__xxx</h2><p>双下划线：类中的私有变量/方法名 （Python的函数也是对象，所以成员方法称为成员变量也行得通）。” 双下划线 “ 开始的是私有成员，意思是只有类对象自己能访问，连子类对象也不能访问到这个数据。</p><h2 id="5-xxx"><a href="#5-xxx" class="headerlink" title="(5)xxx"></a>(5)<strong>xxx</strong></h2><p>系统定义名字，前后均有一个“双下划线” 代表python里特殊方法专用的标识，如 <strong>init</strong>（）代表类的构造函数。类似<strong>xxx</strong>这样的变量是特殊变量，可以被直接引用，但是有特殊用途，比如一个模块的<strong>author</strong>，<strong>name</strong>就是特殊变量，模块定义的文档注释（就是模块开头的字符串）也可以用特殊变量<strong>doc</strong>访问，我们自己的变量一般不要用这种变量名。</p><h1 id="元类（选学）"><a href="#元类（选学）" class="headerlink" title="元类（选学）"></a>元类（选学）</h1><h1 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h1><h1 id="粘包"><a href="#粘包" class="headerlink" title="粘包"></a>粘包</h1><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><h1 id="主动触发异常"><a href="#主动触发异常" class="headerlink" title="主动触发异常"></a>主动触发异常</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class ListNode(object):</span><br><span class="line">...     def __init__(self,value):</span><br><span class="line">...             self.val = value</span><br><span class="line">...             self.next = None</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; a = ListNode(1)</span><br><span class="line"></span><br><span class="line">a.val</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; class Li(ListNode):</span><br><span class="line">...     a = 3</span><br><span class="line">...     def __init__(self,value,a):</span><br><span class="line">...             ListNode.__init__(self,value)</span><br><span class="line">...             self.a = a</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">Li.a</span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/magicking/p/8971740.html" target="_blank" rel="noopener">https://www.cnblogs.com/magicking/p/8971740.html</a><br><a href="https://www.cnblogs.com/zzzlw/p/9286828.html" target="_blank" rel="noopener">https://www.cnblogs.com/zzzlw/p/9286828.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;面向对象&quot;&gt;&lt;a href=&quot;#面向对象&quot; class=&quot;headerlink&quot; title=&quot;面向对象&quot;&gt;&lt;/a&gt;面向对象&lt;/h1&gt;&lt;p&gt;面向过程，流程化，设计简单，不容易扩展，扩展需要改动大，比如登录接口，用户，密码，增加email字段&lt;br&gt;面向对象，对象是
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="类" scheme="http://yoursite.com/tags/%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>python 网络通信</title>
    <link href="http://yoursite.com/2019/05/18/python-%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"/>
    <id>http://yoursite.com/2019/05/18/python-网络通信/</id>
    <published>2019-05-18T04:32:36.000Z</published>
    <updated>2019-05-26T05:01:51.816Z</updated>
    
    <content type="html"><![CDATA[<pre><code>网络编程中有两个主要的问题：如何准确的定位网络上一台或多台主机找到主机后如何可靠高效的进行数据传输</code></pre><h1 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h1><img src="/2019/05/18/python-网络通信/tcp.jpg"><h1 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h1><img src="/2019/05/18/python-网络通信/socket.jpg"><h2 id="创建套接字"><a href="#创建套接字" class="headerlink" title="创建套接字"></a>创建套接字</h2><pre><code>socket.socket([family[, type[, proto]]])family: 套接字家族可以使AF_UNIX或者AF_INETtype: 套接字类型可以根据是面向连接的还是非连接分为SOCK_STREAM（基于TCP）或SOCK_DGRAM（基于UDP）protocol: 一般不填默认为0.</code></pre><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><p>sk.bind(address)</p><p>　　s.bind(address) 将套接字绑定到地址。address地址的格式取决于地址族。在AF_INET下，以元组（host,port）的形式表示地址。</p><p>sk.listen(backlog)</p><p>　　开始监听传入连接。backlog指定在拒绝连接之前，可以挂起的最大连接数量。</p><pre><code>backlog等于5，表示内核已经接到了连接请求，但服务器还没有调用accept进行处理的连接个数最大为5这个值不能无限大，因为要在内核中维护连接队列</code></pre><p>sk.accept()</p><p>　　接受连接并返回（conn,address）,其中conn是新的套接字对象，可以用来接收和发送数据。address是连接客户端的地址。</p><p>　　接收TCP 客户的连接（阻塞式）等待连接的到来</p><p>sk.connect(address)</p><p>　　连接到address处的套接字。一般，address的格式为元组（hostname,port）,如果连接出错，返回socket.error错误。</p><p>sk.close()</p><p>　　关闭套接字</p><p>sk.recv(bufsize[,flag])</p><p>　　接受套接字的数据。数据以字符串形式返回，bufsize指定最多可以接收的数量。flag提供有关消息的其他信息，通常可以忽略。</p><p>sk.send(string[,flag])</p><p>　　将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。即：可能未将指定内容全部发送。</p><h1 id="struct模块"><a href="#struct模块" class="headerlink" title="struct模块"></a>struct模块</h1><p>有的时候需要用python处理二进制数据，比如，存取文件，socket操作时.这时候，可以使用python的struct模块来完成.可以用 struct来处理c语言中的结构体.<br>一个字节 = 2个十六进制<br>struct模块中最重要的三个函数是pack(), unpack(), calcsize()</p><p>pack(fmt, v1, v2, …)     按照给定的格式(fmt)，把数据封装成字符串(实际上是类似于c结构体的字节流)</p><p>unpack(fmt, string)       按照给定的格式(fmt)解析字节流string，返回解析出来的tuple</p><p>calcsize(fmt)                 计算给定的格式(fmt)占用多少字节的内存</p><p>struct中支持的格式如下表：</p><table><thead><tr><th>Format</th><th>C Type</th><th>Python</th><th>字节数</th></tr></thead><tbody><tr><td>x</td><td>pad byte</td><td>no value</td><td>1</td></tr><tr><td>c</td><td>char</td><td>string of length 1</td><td>1</td></tr><tr><td>b</td><td>signed char</td><td>integer</td><td>1</td></tr><tr><td>B</td><td>unsigned char</td><td>integer</td><td>1</td></tr><tr><td>?</td><td>_Bool</td><td>bool</td><td>1</td></tr><tr><td>h</td><td>short</td><td>integer</td><td>2</td></tr><tr><td>H</td><td>unsigned short</td><td>integer</td><td>2</td></tr><tr><td>i</td><td>int</td><td>string of length 1</td><td>1</td></tr><tr><td>I</td><td>unsigned int</td><td>string of length 1</td><td>1</td></tr><tr><td>l</td><td>long</td><td>integer</td><td>4</td></tr><tr><td>L</td><td>unsigned long</td><td>long</td><td>4</td></tr><tr><td>q</td><td>long long</td><td>long</td><td>8</td></tr><tr><td>Q</td><td>unsigned long long</td><td>long</td><td>8</td></tr><tr><td>f</td><td>float</td><td>float</td><td>4</td></tr><tr><td>d</td><td>double</td><td>float</td><td>8</td></tr><tr><td>s</td><td>char[]</td><td>string</td><td>1</td></tr><tr><td>p</td><td>char[]</td><td>string</td><td>1</td></tr><tr><td>P</td><td>void *</td><td>long</td><td>?</td></tr></tbody></table><p>注1.q和Q只在机器支持64位操作时有意思</p><p>注2.每个格式前可以有一个数字，表示个数</p><p>注3.s格式表示一定长度的字符串，4s表示长度为4的字符串，但是p表示的是pascal字符串</p><p>注4.P用来转换一个指针，其长度和机器字长相关</p><p>注5.最后一个可以用来表示指针类型的，占4个字节</p><p>为了同c中的结构体交换数据，还要考虑有的c或c++编译器使用了字节对齐，通常是以4个字节为单位的32位系统，故而struct根据本地机器字节顺序转换.可以用格式中的第一个字符来改变对齐方式.定义如下：</p><table><thead><tr><th>Character</th><th>Byte order</th><th>Size and alignment</th></tr></thead><tbody><tr><td>@</td><td>native</td><td>native            凑够4个字节</td></tr><tr><td>=</td><td>native</td><td>standard        按原字节数</td></tr><tr><td>&lt;</td><td>little-endian</td><td>standard        按原字节数</td></tr><tr><td>&gt;</td><td>big-endian</td><td>standard        按原字节数</td></tr><tr><td>!</td><td>network (= big-endian)</td><td>standard        按原字节数</td></tr></tbody></table><p>示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import struct</span><br><span class="line">&gt;&gt;&gt; struct.pack(&apos;&lt;HH&apos;, 1,2)</span><br><span class="line">b&apos;\x01\x00\x02\x00&apos;</span><br><span class="line">&gt;&gt;&gt; struct.unpack(&apos;&lt;hh&apos;, bytes(b&apos;\x01\x00\x00\x00&apos;))</span><br><span class="line">(1, 0)</span><br><span class="line">&gt;&gt;&gt; struct.unpack(&apos;&lt;h&apos;, bytes(b&apos;\x03\x00&apos;))</span><br><span class="line">(3,)</span><br></pre></td></tr></table></figure></p><p>示例一：</p><p>比如有一个结构体</p><p>struct Header</p><p>{</p><pre><code>unsigned short id;char[4] tag;unsigned int version;unsigned int count;</code></pre><p>}</p><p>通过socket.recv接收到了一个上面的结构体数据，存在字符串s中，现在需要把它解析出来，可以使用unpack()函数.</p><p>import struct</p><p>id, tag, version, count = struct.unpack(“!H4s2I”, s)</p><p>上面的格式字符串中，!表示我们要使用网络字节顺序解析，因为我们的数据是从网络中接收到的，在网络上传送的时候它是网络字节顺序的.后面的H表示 一个unsigned short的id,4s表示4字节长的字符串，2I表示有两个unsigned int类型的数据.</p><p>就通过一个unpack，现在id, tag, version, count里已经保存好我们的信息了.</p><p>同样，也可以很方便的把本地数据再pack成struct格式.</p><p>ss = struct.pack(“!H4s2I”, id, tag, version, count);</p><p>pack函数就把id, tag, version, count按照指定的格式转换成了结构体Header，ss现在是一个字符串(实际上是类似于c结构体的字节流)，可以通过 socket.send(ss)把这个字符串发送出去.</p><p>示例二：</p><p>import struct</p><p>a=12.34</p><p>#将a变为二进制</p><p>bytes=struct.pack(‘i’,a)</p><p>此时bytes就是一个string字符串，字符串按字节同a的二进制存储内容相同。</p><p>再进行反操作</p><p>现有二进制数据bytes，（其实就是字符串），将它反过来转换成python的数据类型：</p><p>a,=struct.unpack(‘i’,bytes)</p><p>注意，unpack返回的是tuple</p><p>所以如果只有一个变量的话：</p><p>bytes=struct.pack(‘i’,a)</p><p>那么，解码的时候需要这样</p><p>a,=struct.unpack(‘i’,bytes) 或者 (a,)=struct.unpack(‘i’,bytes)</p><p>如果直接用a=struct.unpack(‘i’,bytes)，那么 a=(12.34,) ，是一个tuple而不是原来的浮点数了。</p><p>如果是由多个数据构成的，可以这样：</p><p>a=’hello’</p><p>b=’world!’</p><p>c=2</p><p>d=45.123</p><p>bytes=struct.pack(‘5s6sif’,a,b,c,d)</p><p>此时的bytes就是二进制形式的数据了，可以直接写入文件比如 binfile.write(bytes)</p><p>然后，当我们需要时可以再读出来，bytes=binfile.read()</p><p>再通过struct.unpack()解码成python变量</p><p>a,b,c,d=struct.unpack(‘5s6sif’,bytes)</p><p>‘5s6sif’这个叫做fmt，就是格式化字符串，由数字加字符构成，5s表示占5个字符的字符串，2i，表示2个整数等等，下面是可用的字符及类型，ctype表示可以与python中的类型一一对应。</p><p>注意：二进制文件处理时会碰到的问题</p><p>我们使用处理二进制文件时，需要用如下方法</p><p>binfile=open(filepath,’rb’)    读二进制文件</p><p>binfile=open(filepath,’wb’)    写二进制文件</p><p>那么和binfile=open(filepath,’r’)的结果到底有何不同呢？</p><p>不同之处有两个地方：</p><p>第一，使用’r’的时候如果碰到’0x1A’，就会视为文件结束，这就是EOF。使用’rb’则不存在这个问题。即，如果你用二进制写入再用文本读出的话，如果其中存在’0X1A’，就只会读出文件的一部分。使用’rb’的时候会一直读到文件末尾。</p><p>第二，对于字符串x=’abc\ndef’，我们可用len(x)得到它的长度为7，\n我们称之为换行符，实际上是’0X0A’。当我们用’w’即文本方式写的时候，在windows平台上会自动将’0X0A’变成两个字符’0X0D’，’0X0A’，即文件长度实际上变成8.。当用’r’文本方式读取时，又自动的转换成原来的换行符。如果换成’wb’二进制方式来写的话，则会保持一个字符不变，读取时也是原样读取。所以如果用文本方式写入，用二进制方式读取的话，就要考虑这多出的一个字节了。’0X0D’又称回车符。linux下不会变。因为linux只使用’0X0A’来表示换行。</p><h2 id="大小端以及字节序的问题"><a href="#大小端以及字节序的问题" class="headerlink" title="大小端以及字节序的问题"></a>大小端以及字节序的问题</h2><p>网络字节顺序NBO（Network Byte Order）：按从高到低的顺序存储，在网络上使用统一的网络字节顺序，可以避免兼容性问题。</p><p>The order in which the bytes of a multi-byte number are transmitted on a network - most significant byte first (as in “big-endian” storage). </p><p>主机字节顺序（HBO，Host Byte Order）：不同的机器HBO不相同，与CPU设计有关计算机数据存储有两种字节优先顺序：高位字节优先和低位字节优先。</p><p>[struct] (<a href="https://docs.python.org/3/library/struct.html" target="_blank" rel="noopener">https://docs.python.org/3/library/struct.html</a>)<br>[关于int，unsigned int , short的关系与跨平台应用及char,int,float等类型在不同平台下所占字节数] (<a href="https://blog.csdn.net/bzhxuexi/article/details/19551979" target="_blank" rel="noopener">https://blog.csdn.net/bzhxuexi/article/details/19551979</a>)</p><h1 id="单线程通信"><a href="#单线程通信" class="headerlink" title="单线程通信"></a>单线程通信</h1><p>　　该实例中，只能 client 发一句， server回一句（先启动server，后启动client）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"></span><br><span class="line">import socket</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  #ipv4, TCP</span><br><span class="line">    sock.bind((&apos;0.0.0.0&apos;,5000))  #元组,相当于一个参数</span><br><span class="line">    sock.listen(10)   #同时保持是十个人的连接</span><br><span class="line">    conn, addr = sock.accept()</span><br><span class="line">    while True:</span><br><span class="line">        data = conn.recv(1024)   #最多1K的数据</span><br><span class="line">        print(data)</span><br><span class="line">        if data == &apos;bye&apos;:</span><br><span class="line">            break</span><br><span class="line">        else:</span><br><span class="line">            msg = raw_input(&quot;&gt;&gt;&quot;)</span><br><span class="line">            conn.send(msg)</span><br><span class="line">    sock.close()</span><br><span class="line">    print(&apos;Bye!!&apos;)</span><br></pre></td></tr></table></figure><p>Client<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"></span><br><span class="line">import socket, time</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    sock.connect((&apos;localhost&apos;,5000))</span><br><span class="line">    while True:</span><br><span class="line">        msg = raw_input(&quot;&gt;&gt;&quot;)</span><br><span class="line">        if msg == &quot;bye&quot;:</span><br><span class="line">            sock.send(msg)</span><br><span class="line">            sock.close()</span><br><span class="line">            break</span><br><span class="line">        else:</span><br><span class="line">            sock.send(msg)</span><br><span class="line">            data = sock.recv(1024)</span><br></pre></td></tr></table></figure></p><h1 id="多线程通信"><a href="#多线程通信" class="headerlink" title="多线程通信"></a>多线程通信</h1><p>　　在该实例中可以自由发送和接收信息（先启动server，后启动client）</p><p>　　利用threading，多线程进行接受消息和发送消息</p><p>　　callback_recv函数负责接受信息的功能<br>　　callback_send函数负责发送信息的功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"></span><br><span class="line">import socket, threading, sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def callback_send(conn):</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">    :param sq:</span><br><span class="line">    :return:</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    while True:                #为了维持持续的发送</span><br><span class="line">        msg = raw_input(&quot;&gt;&gt;&quot;)</span><br><span class="line">        conn.send(msg)</span><br><span class="line"></span><br><span class="line">def callback_recv(conn):</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">    :param sock:</span><br><span class="line">    :return:</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    while True:               #为了维持持续的接收</span><br><span class="line">        data = conn.recv(1024)</span><br><span class="line">        print(data)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    sock.bind((&apos;0.0.0.0&apos;,5000))  #元组,相当于一个参数</span><br><span class="line">    sock.listen(10)   #同时保持是十个人的连接</span><br><span class="line">    conn, addr = sock.accept()</span><br><span class="line"></span><br><span class="line">    thread_send = threading.Thread(target=callback_send, args=(conn, ))</span><br><span class="line">    thread_recv = threading.Thread(target=callback_recv, args=(conn, ))</span><br><span class="line"></span><br><span class="line">    thread_send.start()</span><br><span class="line">    thread_recv.start()</span><br><span class="line"></span><br><span class="line">    sock.close()</span><br></pre></td></tr></table></figure><p>client</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"></span><br><span class="line">import socket, time, threading, sys</span><br><span class="line"></span><br><span class="line">def callback_send(sock):</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">    :param sq:</span><br><span class="line">    :return:</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    while True:</span><br><span class="line">        msg = raw_input(&quot;&gt;&gt;&quot;)</span><br><span class="line">        sock.send(msg)</span><br><span class="line">        # if msg in [&apos;bye&apos;, &apos;quit&apos;]:</span><br><span class="line">        #     sock.close</span><br><span class="line">        #     break</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def callback_recv(sock):</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">    :param sock:</span><br><span class="line">    :return:</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    while True:</span><br><span class="line">        data = sock.recv(1024)</span><br><span class="line">        print(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    sock.connect((&apos;localhost&apos;,5000))</span><br><span class="line"></span><br><span class="line">    thread_send = threading.Thread(target=callback_send, args=(sock, ))</span><br><span class="line">    thread_recv = threading.Thread(target=callback_recv, args=(sock, ))</span><br><span class="line"></span><br><span class="line">    thread_send.start()</span><br><span class="line">    thread_recv.start()</span><br><span class="line"></span><br><span class="line">    while True:</span><br><span class="line">        pass</span><br><span class="line">    sock.close()</span><br></pre></td></tr></table></figure><h1 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h1><img src="/2019/05/18/python-网络通信/UDP.jpg"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">import socket</span><br><span class="line">def send_msg(udp_socket):</span><br><span class="line">    # 获取输入</span><br><span class="line">    msg = input(&quot;请输入要发送的数据：&quot;)</span><br><span class="line">    # 输入对方IP</span><br><span class="line">    dest_ip = input(&quot;请输入对方ip：&quot;)</span><br><span class="line">    # 输入对方port</span><br><span class="line">    dest_port = int(input(&quot;请输入对方端口：&quot;))</span><br><span class="line">    # 编码</span><br><span class="line">    udp_b = msg.encode(&apos;utf-8&apos;)</span><br><span class="line">    # 发送数据</span><br><span class="line">    udp_socket.sendto(udp_b,(dest_ip,dest_port))</span><br><span class="line"></span><br><span class="line">def recv_msg(udp_socket):</span><br><span class="line">    recv_msg = udp_socket.recvfrom(1024)</span><br><span class="line">    # 解码</span><br><span class="line">    # udp_j = recv_msg.decode(&apos;utf-8&apos;)</span><br><span class="line">    # 显示</span><br><span class="line">    recv_msg = recv_msg[0].decode(&apos;utf-8&apos;)</span><br><span class="line">    print(recv_msg)</span><br><span class="line">def main():</span><br><span class="line">    # 创建套接字</span><br><span class="line">    udp_socket = socket.socket(socket.AF_INET,socket.SOCK_DGRAM)</span><br><span class="line">    # 绑定本地信息</span><br><span class="line">    udp_socket.bind((&quot;&quot;,7789))</span><br><span class="line">    while True:</span><br><span class="line">        print(&quot;=&quot; * 30)</span><br><span class="line">        print(&quot;1.发送消息&quot;)</span><br><span class="line">        print(&quot;2.接收消息&quot;)</span><br><span class="line">        print(&quot;0.退出聊天&quot;)</span><br><span class="line">        op_num = input(&quot;请输入要操作的功能：&quot;)</span><br><span class="line">        if op_num == &quot;1&quot;:</span><br><span class="line">            send_msg(udp_socket)</span><br><span class="line">        elif op_num == &quot;2&quot;:</span><br><span class="line">            recv_msg(udp_socket)</span><br><span class="line">        elif op_num == &quot;0&quot;:</span><br><span class="line">            break</span><br><span class="line">        else:</span><br><span class="line">            print(&quot;输入有误，请重新输入&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    udp_socket.close()</span><br><span class="line"></span><br><span class="line">if __name__== main():</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><img src="/2019/05/18/python-网络通信/HTTP.jpg"><h1 id="int与IP转换"><a href="#int与IP转换" class="headerlink" title="int与IP转换"></a>int与IP转换</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import socket,struct</span><br><span class="line">&gt;&gt;&gt; int_ip = 123456789</span><br><span class="line">&gt;&gt;&gt; socket.inet_ntoa(struct.pack(‘I’,socket.htonl(int_ip)))#整数转换为ip地址</span><br><span class="line">’7.91.205.21′</span><br><span class="line">&gt;&gt;&gt; str(socket.ntohl(struct.unpack(“I”,socket.inet_aton(“255.255.255.255″))[0]))#ip地址转换为整数</span><br><span class="line">’4294967295′</span><br><span class="line">实际上也就是进制数的转换</span><br><span class="line">用lambda的方式，int2ip一行代码搞定</span><br><span class="line">&gt;&gt;&gt; int2ip = lambda x: &apos;.&apos;.join([str(x/(256**i)%256) for i in range(3,-1,-1)])</span><br><span class="line">&gt;&gt;&gt; int2ip(123456789)</span><br><span class="line">’7.91.205.21′</span><br><span class="line">用lambda的方式，ip2int</span><br><span class="line">&gt;&gt;&gt; ip2int = lambda x:sum([256**j*int(i) for j,i in enumerate(x.split(&apos;.&apos;)[::-1])])</span><br><span class="line">&gt;&gt;&gt; ip2int(&apos;7.91.205.21&apos;)</span><br><span class="line">123456789</span><br></pre></td></tr></table></figure><h1 id="request模块"><a href="#request模块" class="headerlink" title="request模块"></a>request模块</h1><p>requests模块是python的一个第三方模块，它是基于python自带的urllib模块封装的，用来发送http请求和获取返回的结果，操作很简单。需要自己安装  pip install requests</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> pa = &#123;&apos;query&apos;:&apos;&apos;&apos;&#123;</span><br><span class="line">...     id</span><br><span class="line">...     name</span><br><span class="line">...     age</span><br><span class="line">...     isKid</span><br><span class="line">...     &#125;</span><br><span class="line">... &apos;&apos;&apos;&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; res = requests.post(url=url, params=pa)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; res.content</span><br><span class="line">b&apos;&#123;&quot;data&quot;:&#123;&quot;id&quot;:123,&quot;name&quot;:&quot;jack&quot;,&quot;age&quot;:10,&quot;isKid&quot;:true&#125;&#125;&apos;</span><br><span class="line">&gt;&gt;&gt; res.cookies</span><br><span class="line">&lt;RequestsCookieJar[]&gt;</span><br><span class="line">&gt;&gt;&gt; res.json</span><br><span class="line">&lt;bound method Response.json of &lt;Response [200]&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; res.json()</span><br><span class="line">&#123;&apos;data&apos;: &#123;&apos;age&apos;: 10, &apos;id&apos;: 123, &apos;isKid&apos;: True, &apos;name&apos;: &apos;jack&apos;&#125;&#125;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;网络编程中有两个主要的问题：
如何准确的定位网络上一台或多台主机
找到主机后如何可靠高效的进行数据传输
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;TCP-IP&quot;&gt;&lt;a href=&quot;#TCP-IP&quot; class=&quot;headerlink&quot; title=&quot;TCP/
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python 网络通信" scheme="http://yoursite.com/tags/Python-%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>python 线程</title>
    <link href="http://yoursite.com/2019/05/18/python-%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/05/18/python-线程/</id>
    <published>2019-05-18T04:32:36.000Z</published>
    <updated>2019-05-28T16:17:39.599Z</updated>
    
    <content type="html"><![CDATA[<h1 id="子线程强制终止"><a href="#子线程强制终止" class="headerlink" title="子线程强制终止"></a>子线程强制终止</h1><p>子线程的强制性终止是我们实际应用时经常需要用到的，然而python官方并没有给出相关的函数来处理这种情况。<br><a href="http://stackoverflow.com/questions/323972/is-there-any-way-to-kill-a-thread-in-python" target="_blank" rel="noopener">http://stackoverflow.com/questions/323972/is-there-any-way-to-kill-a-thread-in-python</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def _async_raise(tid, exctype):</span><br><span class="line">    &quot;&quot;&quot;raises the exception, performs cleanup if needed&quot;&quot;&quot;</span><br><span class="line">    tid = ctypes.c_long(tid)</span><br><span class="line">    if not inspect.isclass(exctype):</span><br><span class="line">        exctype = type(exctype)</span><br><span class="line">    res = ctypes.pythonapi.PyThreadState_SetAsyncExc(tid, ctypes.py_object(exctype))</span><br><span class="line">    if res == 0:</span><br><span class="line">        raise ValueError(&quot;invalid thread id&quot;)</span><br><span class="line">    elif res != 1:</span><br><span class="line">        # &quot;&quot;&quot;if it returns a number greater than one, you&apos;re in trouble,</span><br><span class="line">        # and you should call it again with exc=NULL to revert the effect&quot;&quot;&quot;</span><br><span class="line">        ctypes.pythonapi.PyThreadState_SetAsyncExc(tid, None)</span><br><span class="line">        raise SystemError(&quot;PyThreadState_SetAsyncExc failed&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def stop_thread(thread):</span><br><span class="line">    _async_raise(thread.ident, SystemExit)</span><br></pre></td></tr></table></figure></p><h1 id="线程的暂停-恢复-退出"><a href="#线程的暂停-恢复-退出" class="headerlink" title="线程的暂停, 恢复, 退出"></a>线程的暂停, 恢复, 退出</h1><p>我们都知道python中可以是threading模块实现多线程, 但是模块并没有提供暂停, 恢复和停止线程的方法, 一旦线程对象调用start方法后, 只能等到对应的方法函数运行完毕.<br>也就是说一旦start后, 线程就属于失控状态. 不过, 我们可以自己实现这些. 一般的方法就是循环地判断一个标志位, 一旦标志位到达到预定的值, 就退出循环. 这样就能做到退出线程了.<br>但暂停和恢复线程就有点难了, 我一直也不清除有什么好的方法, 直到我看到threading中Event对象的wait方法的描述时.<br>    Block until the internal flag is true. If the internal flag is true on entry, return immediately. Otherwise, block until another thread calls set() to set the flag to true, or until the optional timeout occurs.<br>    阻塞, 直到内部的标志位为True时. 如果在内部的标志位在进入时为True时, 立即返回. 否则, 阻塞直到其他线程调用set()方法将标准位设为True, 或者到达了可选的timeout时间.</p><pre><code>When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof).当给定了timeout参数且不为None, 它应该是一个浮点数，以秒为单位指定操作的超时（或是分数）。This method returns the internal flag on exit, so it will always return True except if a timeout is given and the operation times out.此方法在退出时返回内部标志，因此除非给定了超时且操作超时，否则它将始终返回True。Changed in version 2.7: Previously, the method always returned None. 2.7版本以前, 这个方法总会返回None.</code></pre><p>利用wait的阻塞机制, 就能够实现暂停和恢复了, 再配合循环判断标识位, 就能实现退出了, 下面是代码示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Job(threading.Thread):</span><br><span class="line">    def __init__(self, *args, **kwargs):</span><br><span class="line">        super(Job, self).__init__(*args, **kwargs)</span><br><span class="line">        self.__flag = threading.Event()  # 用于暂停线程的标识</span><br><span class="line">        self.__flag.set()  # 设置为True</span><br><span class="line">        self.__running = threading.Event()  # 用于停止线程的标识</span><br><span class="line">        self.__running.set()  # 将running设置为True</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        while self.__running.isSet():</span><br><span class="line">            self.__flag.wait()  # 为True时立即返回, 为False时阻塞直到内部的标识位为True后返回</span><br><span class="line">            print(time.time())</span><br><span class="line">            time.sleep(1)</span><br><span class="line"></span><br><span class="line">    def pause(self):</span><br><span class="line">        self.__flag.clear()  # 设置为False, 让线程阻塞</span><br><span class="line"></span><br><span class="line">    def resume(self):</span><br><span class="line">        self.__flag.set()  # 设置为True, 让线程停止阻塞</span><br><span class="line"></span><br><span class="line">    def stop(self):</span><br><span class="line">        self.__flag.set()  # 将线程从暂停状态恢复, 如何已经暂停的话</span><br><span class="line">        self.__running.clear()  # 设置为False</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a.start()</span><br><span class="line">time.sleep(3)</span><br><span class="line">a.pause()</span><br><span class="line">time.sleep(3)</span><br><span class="line">a.resume()</span><br><span class="line">time.sleep(3)</span><br><span class="line">a.pause()</span><br><span class="line">time.sleep(2)</span><br><span class="line">a.stop()</span><br></pre></td></tr></table></figure><h1 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h1><p>Callback早就有Twisted，新生代也有Tornado，Coroutine有Gevent，Actor有Pulsar，VM方面要稳妥CPython，要性能PYPY，要并发Stackless，AIO神马的的选择太多。cyclone<br>在Python中，一个异步的函数我们通常叫它协程。之前我们在讲解yield的时候也已经讲过yield语法在协程中的基本使用了，这次同样是协程，但却是不同的语法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#在Python 3.4中, 创建一个协程我们用asyncio.coroutine装饰器:</span><br><span class="line">async def double(x):</span><br><span class="line">    return x * 2</span><br><span class="line"></span><br><span class="line"># 这是个协程对象</span><br><span class="line">&gt;&gt;&gt; double(6)</span><br><span class="line">&gt;&gt;&gt;&lt;coroutine object double at 0x115b59d58&gt;</span><br><span class="line"></span><br><span class="line"># 既然是协程，我们像之前yield协程那样，预激活一下(注意这里用next(double(6)预激活会报错)</span><br><span class="line">&gt;&gt;&gt; double(6).send(None)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">StopIteration: 12</span><br><span class="line"># 好像差不多。</span><br></pre></td></tr></table></figure></p><h2 id="asyncio的几个重要结构"><a href="#asyncio的几个重要结构" class="headerlink" title="asyncio的几个重要结构"></a>asyncio的几个重要结构</h2><blockquote><p>event loop:<br>    An event loop essentially manages and distributes the execution of different tasks. It registers them and handles distributing the flow of control between them.</p></blockquote><blockquote><p>Coroutines<br>    Coroutines are special functions that work similarly Python generators that on await they release the flow of control back to the event loop. A coroutine needs to be scheduled to run using the event loop, to do this we create a Task, which is a type of Future.<br>Futures：<br>    Futures are objects that represent the result of a task that may or may not have been executed. This result may be an exception.</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">import asyncio</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def tic():</span><br><span class="line">    return &apos;at %1.1f seconds&apos; % (time.time() - start)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">async def gr1():</span><br><span class="line">    # Busy waits for a second, but we don&apos;t want to stick around...</span><br><span class="line">    print(&apos;gr1 started work: &#123;&#125;&apos;.format(tic()))</span><br><span class="line">    # 暂停两秒，但不阻塞时间循环，下同</span><br><span class="line">    await asyncio.sleep(2)</span><br><span class="line">    print(&apos;gr1 ended work: &#123;&#125;&apos;.format(tic()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">async def gr2():</span><br><span class="line">    # Busy waits for a second, but we don&apos;t want to stick around...</span><br><span class="line">    print(&apos;gr2 started work: &#123;&#125;&apos;.format(tic()))</span><br><span class="line">    await asyncio.sleep(2)</span><br><span class="line">    print(&apos;gr2 Ended work: &#123;&#125;&apos;.format(tic()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">async def gr3():</span><br><span class="line">    print(&quot;Let&apos;s do some stuff while the coroutines are blocked, &#123;&#125;&quot;.format(tic()))</span><br><span class="line">    await asyncio.sleep(1)</span><br><span class="line">    print(&quot;Done!&quot;)</span><br><span class="line"></span><br><span class="line"># 事件循环</span><br><span class="line">ioloop = asyncio.get_event_loop()</span><br><span class="line"></span><br><span class="line"># tasks中也可以使用asyncio.ensure_future(gr1())..</span><br><span class="line">tasks = [</span><br><span class="line">    ioloop.create_task(gr1()),</span><br><span class="line">    ioloop.create_task(gr2()),</span><br><span class="line">    ioloop.create_task(gr3())</span><br><span class="line">]</span><br><span class="line">ioloop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">ioloop.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">output：</span><br><span class="line">    gr1 started work: at 0.0 seconds</span><br><span class="line">    gr2 started work: at 0.0 seconds</span><br><span class="line">    Let&apos;s do some stuff while the coroutines are blocked, at 0.0 seconds</span><br><span class="line">    Done!</span><br><span class="line">    gr2 Ended work: at 2.0 seconds</span><br><span class="line">    gr1 ended work: at 2.0 seconds</span><br></pre></td></tr></table></figure><p>event loop 流程图</p><img src="/2019/05/18/python-线程/协程.jpg">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;子线程强制终止&quot;&gt;&lt;a href=&quot;#子线程强制终止&quot; class=&quot;headerlink&quot; title=&quot;子线程强制终止&quot;&gt;&lt;/a&gt;子线程强制终止&lt;/h1&gt;&lt;p&gt;子线程的强制性终止是我们实际应用时经常需要用到的，然而python官方并没有给出相关的函数来处理这种
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python 线程" scheme="http://yoursite.com/tags/Python-%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>python pstuil</title>
    <link href="http://yoursite.com/2019/05/18/python-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97psutil/"/>
    <id>http://yoursite.com/2019/05/18/python-常用模块psutil/</id>
    <published>2019-05-18T04:32:36.000Z</published>
    <updated>2019-05-23T03:21:39.685Z</updated>
    
    <content type="html"><![CDATA[<h1 id="psutil模块介绍"><a href="#psutil模块介绍" class="headerlink" title="psutil模块介绍"></a>psutil模块介绍</h1><p>psutil是一个跨平台库（<a href="http://code.google.com/p/psutil/），能够轻松实现获取系统运行的进程和系统利用率（包括CPU、内存、磁盘、网络等）信息。它主要应用于系统监控，分析和限制系统资源及进程的管理。" target="_blank" rel="noopener">http://code.google.com/p/psutil/），能够轻松实现获取系统运行的进程和系统利用率（包括CPU、内存、磁盘、网络等）信息。它主要应用于系统监控，分析和限制系统资源及进程的管理。</a><br>它实现了同等命令行工具提供的功能，如ps、top、lsof、netstat、ifconfig、who、df、kill、free、nice、ionice、iostat、iotop、uptime、pidof、tty、taskset、pmap等。<br>目前支持32位和64位的Linux、Windows、OS X、FreeBSD和Sun Solaris等操作系统。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><pre><code>wget https://pypi.python.org/packages/source/p/psutil/psutil-2.0.0.tar.gztar -xzvf psutil-2.0.0.tar.gzcd psutil-2.0.0python setup.py install</code></pre><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>获取系统性能信息（CPU,内存，磁盘，网络）</p><h2 id="CPU相关"><a href="#CPU相关" class="headerlink" title="CPU相关"></a>CPU相关</h2><p>查看cpu信息</p><p>import Psutil<br>查看cpu所有信息</p><blockquote><blockquote><blockquote><p>psutil.cpu_times()<br>scputimes(user=11677.09, nice=57.93, system=148675.58, idle=2167147.79, iowait=260828.48, irq=7876.28, softirq=0.0, steal=3694.59, guest=0.0, guest_nice=0.0)<br>显示cpu所有逻辑信息</p></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><p>psutil.cpu_times(percpu=True)<br>[scputimes(user=11684.17, nice=57.93, system=148683.01, idle=2168982.08, iowait=260833.18, irq=7882.35, softirq=0.0, steal=3697.3, guest=0.0, guest_nice=0.0)]<br>查看用户的cpu时间比</p></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><p>psutil.cpu_times().user<br>11684.4<br>查看cpu逻辑个数</p></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><p>psutil.cpu_count()<br>1<br>查看cpu物理个数</p></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><p>psutil.cpu_count(logical=False)<br>1</p></blockquote></blockquote></blockquote><h2 id="查看系统内存"><a href="#查看系统内存" class="headerlink" title="查看系统内存"></a>查看系统内存</h2><blockquote><blockquote><blockquote><p>import psutil<br>mem = psutil.virtual_memory()<br>mem</p></blockquote></blockquote></blockquote><h2 id="系统内存的所有信息"><a href="#系统内存的所有信息" class="headerlink" title="系统内存的所有信息"></a>系统内存的所有信息</h2><p>svmem(total=1040662528, available=175054848, percent=83.2, used=965718016, free=74944512, active=566755328, inactive=59457536, buffers=9342976, cached=90767360)<br>系统总计内存</p><blockquote><blockquote><blockquote><p>mem.total<br>1040662528<br>系统已经使用内存</p></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><p>mem.used<br>965718016<br>系统空闲内存</p></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><p>mem.free<br>112779264<br>获取swap内存信息</p></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><p>psutil.swap_memory()<br>sswap(total=0, used=0, free=0, percent=0, sin=0, sout=0)</p></blockquote></blockquote></blockquote><h2 id="读取磁盘参数"><a href="#读取磁盘参数" class="headerlink" title="读取磁盘参数"></a>读取磁盘参数</h2><p>磁盘利用率使用psutil.disk_usage方法获取，</p><p>磁盘IO信息包括read_count(读IO数)，write_count(写IO数)<br>read_bytes(IO写字节数)，read_time(磁盘读时间)，write_time(磁盘写时间),这些IO信息用</p><p>psutil.disk_io_counters()<br>获取磁盘的完整信息</p><p>psutil.disk_partitions()<br>获取分区表的参数</p><p>psutil.disk_usage(‘/‘)   #获取/分区的状态<br>获取硬盘IO总个数</p><p>psutil.disk_io_counters()<br>获取单个分区IO个数</p><p>psutil.disk_io_counters(perdisk=True)    #perdisk=True参数获取单个分区IO个数</p><h2 id="读取网络信息"><a href="#读取网络信息" class="headerlink" title="读取网络信息"></a>读取网络信息</h2><p>网络信息与磁盘IO信息类似,涉及到几个关键点，包括byes_sent(发送字节数),byte_recv=xxx(接受字节数),<br>pack-ets_sent=xxx(发送数据包数),pack-ets_recv=xxx(接收数据包数)。</p><p>获取网络总IO信息</p><p>psutil.net_io_counters()<br>输出网络每个接口信息</p><p>psutil.net_io_counters(pernic=True)     #pernic=True<br>获取当前系统用户登录信息</p><p>psutil.users()<br>获取开机时间</p><p>psutil.boot_time() #以linux时间格式返回</p><p>datetime.datetime.fromtimestamp(psutil.boot_time ()).strftime(“%Y-%m-%d %H: %M: %S”) #转换成自然时间格式</p><h2 id="系统进程管理"><a href="#系统进程管理" class="headerlink" title="系统进程管理"></a>系统进程管理</h2><p>获取当前系统的进程信息,获取当前程序的运行状态,包括进程的启动时间,查看设置CPU亲和度,内存使用率,IO信息<br>socket连接,线程数等<br>获取进程信息</p><p>查看系统全部进程</p><p>psutil.pids()<br>查看单个进程</p><p>p = psutil.Process(2423)<br>p.name()   #进程名<br>p.exe()    #进程的bin路径<br>p.cwd()    #进程的工作目录绝对路径<br>p.status()   #进程状态<br>p.create_time()  #进程创建时间<br>p.uids()    #进程uid信息<br>p.gids()    #进程的gid信息<br>p.cpu_times()   #进程的cpu时间信息,包括user,system两个cpu信息<br>p.cpu_affinity()  #get进程cpu亲和度,如果要设置cpu亲和度,将cpu号作为参考就好<br>p.memory_percent()  #进程内存利用率<br>p.memory_info()    #进程内存rss,vms信息<br>p.io_counters()    #进程的IO信息,包括读写IO数字及参数<br>p.connectios()   #返回进程列表<br>p.num_threads()  #进程开启的线程数<br>听过psutil的Popen方法启动应用程序，可以跟踪程序的相关信息<br>from subprocess import PIPE<br>p = psutil.Popen([“/usr/bin/python”, “-c”, “print(‘hello’)”],stdout=PIPE)<br>p.name()<br>p.username()</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;psutil模块介绍&quot;&gt;&lt;a href=&quot;#psutil模块介绍&quot; class=&quot;headerlink&quot; title=&quot;psutil模块介绍&quot;&gt;&lt;/a&gt;psutil模块介绍&lt;/h1&gt;&lt;p&gt;psutil是一个跨平台库（&lt;a href=&quot;http://code.goo
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python psutil" scheme="http://yoursite.com/tags/Python-psutil/"/>
    
  </entry>
  
  <entry>
    <title>python 数学函数</title>
    <link href="http://yoursite.com/2019/05/18/python-%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2019/05/18/python-数学函数/</id>
    <published>2019-05-18T04:32:36.000Z</published>
    <updated>2019-05-27T13:29:53.451Z</updated>
    
    <content type="html"><![CDATA[<h1 id="四舍五入"><a href="#四舍五入" class="headerlink" title="四舍五入"></a>四舍五入</h1><pre><code>round(4.54,1)</code></pre><h1 id="向上取整"><a href="#向上取整" class="headerlink" title="向上取整"></a>向上取整</h1><pre><code>import mathmath.ceil(4.1) = 5</code></pre><h1 id="向下取整"><a href="#向下取整" class="headerlink" title="向下取整"></a>向下取整</h1><pre><code>math.floor(4.9) = 4</code></pre><h1 id="忽略小数点"><a href="#忽略小数点" class="headerlink" title="忽略小数点"></a>忽略小数点</h1><pre><code>int(3.215)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;四舍五入&quot;&gt;&lt;a href=&quot;#四舍五入&quot; class=&quot;headerlink&quot; title=&quot;四舍五入&quot;&gt;&lt;/a&gt;四舍五入&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;round(4.54,1)
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;向上取整&quot;&gt;&lt;a href=&quot;#向上取
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="数学函数" scheme="http://yoursite.com/tags/%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>挣值分析</title>
    <link href="http://yoursite.com/2019/04/19/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%8C%A3%E5%80%BC%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2019/04/19/项目管理-挣值分析/</id>
    <published>2019-04-19T04:08:36.000Z</published>
    <updated>2019-04-22T05:46:34.653Z</updated>
    
    <content type="html"><![CDATA[<h1 id="挣值分析"><a href="#挣值分析" class="headerlink" title="挣值分析"></a>挣值分析</h1><p>挣值分析的三个基本参数包括: 计划值（PV）、实际成本（AC）、和挣值（EV）。四个评价指标包括:进度偏差（SV）、成本偏差（CV）、成本执行指标(CPI)和进度执行指标（SPI）。</p><h1 id="基本参数"><a href="#基本参数" class="headerlink" title="基本参数"></a>基本参数</h1><p>1、 计划价值（Plan Value）。又叫（BCWS,Budgeted Cost for work scheduled)计划工作量的预算费用。是指项目实施过程中某阶段计划要求完成的工作量所需的预算工时（或费用）。<br>    计算公式 PV = BCWS = 计划工作量 <em> 计划单价。<br>    PV的总和有时被称为绩效测量基准（PMB）。项目的总计划价值又被称为完工预算（BAC）<br>2、 实际成本（Actual Cost）。又叫（ACWP, Actual Cost for Work Performed）。是指项目实施过程中某阶段实际完成的工作量所消耗的工时（或费用）。<br>    AC = ACWP = 已完成工作量 </em> 实际单价<br>3、 挣值（EV，Earned Value），又叫（BCWP，Budgeted Cost for Work Performed）已完成工作量的预算成本。<br>    EV = BCWP = 已完成工作量 * 计划单价</p><h1 id="评价指标"><a href="#评价指标" class="headerlink" title="评价指标"></a>评价指标</h1><p>挣值分析法的四个评价指标：进度偏差（SV）、成本偏差（CV）、成本执行指标（CPI）和进度执行指标（SPI）：<br>1、进度偏差（SV，Schedule Variance）SV是指检查日期EV和PV之间的差异：<br>SV=EV-PV=BCWP-BCWS<br>当SV为正值时，表示进度提前；<br>当SV等于零时，表示实际与计划相符。<br>当SV为负值时，表示进度延误。<br>2、成本偏差（CV，Cost Variance）。CV是指检查期间EV和AC之间的差异：<br>CV=EV-AC=BCWP-ACWP<br>当CV为正值时，表示实际消耗的人工（或费用）低于预算值，即有结余或效率高；<br>当CV等于零时，表示实际消耗的人工（或费用）等于预算值；<br>当CV为负值时，表示实际消耗的人工（或费用）超出预算值或超支。<br>3、成本执行指标（CPI，Cost Performed Index）。指项目挣值与实际费用之比（或工时值之比）：<br>CPI=EV/AC=BCWP/ACWP<br>当CPI&gt;1时，表示低于预算，即实际费用低于预算费用；<br>当CPI=1时，表示实际费用与预算费用吻合；<br>当CPI&lt;1时，表示超出预算，即实际费用高于预算费用；<br>4、进度绩效指标（Schedule Performed Index）。指项目挣值与计划值之比：<br>SPI=EV/PV=BCWP/BCWS<br>当SPI&gt;1时，表示进度超前<br>当SPI=1时，表示实际进度与计划进度相同<br>当SPI&lt;1时，表示进度延误<br>挣值管理是项目管理的一种方法，主要用于项目成本和进度的监控<br>挣值通过项目开始时的计划与所完成的工作进行比较，给出了一个项目何时完工的估算，通过从项目已经完工的部分进行推算，项目经理可以估计出项目完工的时候，将会花费多少资源。<br>这项技术基于关键路径的概念。另一个项目绩效测量和管理技术是关键链，它使用的是缓冲管理。原因是挣值管理方法不能区别基于项目约束（例如：项目的关键链）的进度和基于非约束（例如：项目路径网络中的其他路径）的进度，这在某些时候会造成项目经理为了追求更好的挣值测量，而以关键任务成本来急于完成非关键的任务，导致项目完工的推延。这是一个局部最优的例子，问题在于缺乏局部测量与整体测量的从属关系。<br>为了在项目中应用挣值方法，项目经理需要下列首要数据：<br>工作分解结构 (WBS): 以层次化分解的所有任务的列表。<br>项目主进度计划(PMS): 关于那些任务将完成以及谁完成的甘特图<br>计划完成的工作的预计成本(计划值): 每一个周期预计当前完成的工作的预算。<br>实际完成的工作的预计成本(挣值): 每一个周期当前实际完成的工作的预算。<br>实际完成的工作的实际成本(实际成本): 每一个周期工作的实际成本。<br>项目总预算(BAC): 预计用于完成项目所花费的总预算。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;挣值分析&quot;&gt;&lt;a href=&quot;#挣值分析&quot; class=&quot;headerlink&quot; title=&quot;挣值分析&quot;&gt;&lt;/a&gt;挣值分析&lt;/h1&gt;&lt;p&gt;挣值分析的三个基本参数包括: 计划值（PV）、实际成本（AC）、和挣值（EV）。四个评价指标包括:进度偏差（SV）、成本偏差
      
    
    </summary>
    
      <category term="项目管理" scheme="http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="挣值分析" scheme="http://yoursite.com/tags/%E6%8C%A3%E5%80%BC%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>项目整合管理</title>
    <link href="http://yoursite.com/2019/04/19/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E8%BF%87%E7%A8%8B%E7%BB%84%E5%92%8C%E7%9F%A5%E8%AF%86%E9%A2%86%E5%9F%9F/"/>
    <id>http://yoursite.com/2019/04/19/项目管理-过程组和知识领域/</id>
    <published>2019-04-19T04:08:36.000Z</published>
    <updated>2019-04-19T05:20:55.973Z</updated>
    
    <content type="html"><![CDATA[<hr><table><br>    <tr><br>        <th rowspan="2">知识领域</th><br>        <th colspan="5" style="text-align:center">项目管理过程组</th><br>    </tr><br>    <tr><br>        <th>启动过程组<br>        </th><th>规划过程组<br>        </th><th>执行过程组<br>        </th><th>监控过程组<br>        </th><th>收尾过程组<br>    </th></tr><br>    <tr><br>        <td>项目整合管理</td><br>        <td>制定项目章程</td><br>        <td>制定项目管理计划</td><br>        <td><br>            指导与管理项目工作<br>            管理项目知识<br>        </td><br>        <td><br>            监控项目工作<br>            实施整体变更控制<br>        </td><br>        <td><br>            结束项目或阶段<br>        </td><br>    </tr><br>    <tr><br>        <td>项目范围管理</td><br>        <td></td><br>        <td><br>            规划范围管理<br>            收集需求<br>            定义范围<br>            创建WBS<br>        </td><br>        <td><br>        </td><br>        <td><br>            确认范围<br>            控制范围<br>        </td><br>        <td></td><br>    </tr><br>    <tr><br>        <td>项目进度管理</td><br>        <td></td><br>        <td><br>            规划进度管理<br>            定义活动<br>            排列活动次序<br>            估算活动持续时间<br>            制定进度计划<br>        </td><br>        <td><br>        </td><br>        <td><br>            控制进度<br>        </td><br>        <td></td><br>    </tr><br>    <tr><br>        <td>项目成本管理</td><br>        <td><br>        </td><br>        <td><br>            规划成本管理<br>            估算成本<br>            制定预算<br>        </td><br>        <td></td><br>        <td><br>            控制成本<br>        </td><br>        <td></td><br>    </tr><br>    <tr><br>        <td>项目质量管理</td><br>        <td></td><br>        <td><br>            规划质量管理<br>        </td><br>        <td><br>            管理质量<br>        </td><br>        <td><br>            控制质量<br>        </td><br>        <td></td><br>    </tr><br>    <tr><br>        <td>项目资源管理</td><br>        <td></td><br>        <td><br>            规划资源管理<br>            估算活动资源<br>        </td><br>        <td><br>            获取资源<br>            建设团队<br>            管理团队<br>        </td><br>        <td><br>            控制资源<br>        </td><br>        <td></td><br>    </tr><br>    <tr><br>        <td>项目沟通管理</td><br>        <td></td><br>        <td>规划沟通管理</td><br>        <td>管理沟通</td><br>        <td>监督沟通</td><br>        <td></td><br>    </tr><br>    <tr><br>        <td>项目风险管理</td><br>        <td></td><br>        <td><br>            规划风险管理<br>            识别风险<br>            实施定性风险分析<br>            实施定量风险分析<br>            规划风险应对<br>        </td><br>        <td><br>            实施风险应对<br>        </td><br>        <td><br>            监督风险<br>        </td><br>        <td></td><br>    </tr><br>    <tr><br>        <td>项目采购管理</td><br>        <td></td><br>        <td>规划采购管理</td><br>        <td>实施采购</td><br>        <td>控制采购</td><br>        <td></td><br>    </tr><br>    <tr><br>        <td>项目相关方管理</td><br>        <td>识别相关方</td><br>        <td>规划相关方参与</td><br>        <td>管理相关方参与</td><br>        <td>监督相关方参与</td><br>        <td></td><br>    </tr><br></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;table&gt;&lt;br&gt;    &lt;tr&gt;&lt;br&gt;        &lt;th rowspan=&quot;2&quot;&gt;知识领域&lt;/th&gt;&lt;br&gt;        &lt;th colspan=&quot;5&quot; style=&quot;text-align:center&quot;&gt;项目管理过程组&lt;/th&gt;&lt;br&gt;    &lt;/tr&gt;
      
    
    </summary>
    
      <category term="项目管理" scheme="http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="过程组" scheme="http://yoursite.com/tags/%E8%BF%87%E7%A8%8B%E7%BB%84/"/>
    
      <category term="知识领域" scheme="http://yoursite.com/tags/%E7%9F%A5%E8%AF%86%E9%A2%86%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>项目管理计划</title>
    <link href="http://yoursite.com/2019/04/19/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E8%AE%A1%E5%88%92/"/>
    <id>http://yoursite.com/2019/04/19/项目管理-项目管理计划/</id>
    <published>2019-04-19T04:08:36.000Z</published>
    <updated>2019-04-25T08:00:40.586Z</updated>
    
    <content type="html"><![CDATA[<h1 id="项目管理计划"><a href="#项目管理计划" class="headerlink" title="项目管理计划"></a>项目管理计划</h1><img src="/2019/04/19/项目管理-项目管理计划/项目管理计划.png">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;项目管理计划&quot;&gt;&lt;a href=&quot;#项目管理计划&quot; class=&quot;headerlink&quot; title=&quot;项目管理计划&quot;&gt;&lt;/a&gt;项目管理计划&lt;/h1&gt;&lt;img src=&quot;/2019/04/19/项目管理-项目管理计划/项目管理计划.png&quot;&gt;

      
    
    </summary>
    
      <category term="项目管理" scheme="http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="项目管理计划" scheme="http://yoursite.com/tags/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>python 项目目录</title>
    <link href="http://yoursite.com/2019/03/22/python-%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95/"/>
    <id>http://yoursite.com/2019/03/22/python-项目目录/</id>
    <published>2019-03-22T10:32:36.000Z</published>
    <updated>2019-04-30T04:05:07.443Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一般项目的目录结构"><a href="#一般项目的目录结构" class="headerlink" title="一般项目的目录结构"></a>一般项目的目录结构</h1><p>project_name<br>    log<br>    conf<br>    project_name     #core<br>    libs/modules<br>    docs<br>    README<br>        install<br>            python3 setup.py install<br>    setup.py<br>    bin/<br>        start_project.py<br>    requirements.txt    #pip install requirements</p><blockquote><p>pip freeze #列出所有的模块</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一般项目的目录结构&quot;&gt;&lt;a href=&quot;#一般项目的目录结构&quot; class=&quot;headerlink&quot; title=&quot;一般项目的目录结构&quot;&gt;&lt;/a&gt;一般项目的目录结构&lt;/h1&gt;&lt;p&gt;project_name&lt;br&gt;    log&lt;br&gt;    conf&lt;br&gt;   
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="项目目录" scheme="http://yoursite.com/tags/%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>python 高阶函数的使用</title>
    <link href="http://yoursite.com/2019/03/22/python-%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>http://yoursite.com/2019/03/22/python-高阶函数的应用/</id>
    <published>2019-03-22T10:32:36.000Z</published>
    <updated>2019-05-01T00:09:47.375Z</updated>
    
    <content type="html"><![CDATA[<p>zip,map,filter,reduce,sorted，列表推导式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">columns = [&apos;id&apos;,&apos;name&apos;,&apos;age&apos;,&apos;phone&apos;,&apos;dept&apos;,&apos;enrolled_date&apos;]</span><br><span class="line"></span><br><span class="line">with open(r&apos;staff_db.txt&apos;,&apos;r&apos;,encoding=&apos;utf-8&apos;) as fp:</span><br><span class="line"></span><br><span class="line">staff_list = [line.strip().split(&apos;,&apos;) for line in fp] # 列表结构形式员工信息</span><br><span class="line"></span><br><span class="line">data = dict(zip(columns, map(list, zip(*staff_list)))) # 将员工信息存到如下结构中</span><br><span class="line"></span><br><span class="line">data=&#123;&apos;id&apos;: [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;],</span><br><span class="line">&apos;name&apos;: [&apos;Li&apos;, &apos;Wang&apos;, &apos;Rain&apos;],</span><br><span class="line">&apos;age&apos;: [&apos;22&apos;, &apos;28&apos;, &apos;21&apos;],</span><br><span class="line">&apos;phone&apos;: [&apos;13651054608&apos;, &apos;13451024608&apos;, &apos;13451054608&apos;],</span><br><span class="line">&apos;dept&apos;: [&apos;IT&apos;, &apos;HR&apos;, &apos;IT&apos;],</span><br><span class="line">&apos;enrolled_date&apos;: [&apos;2013-04-01&apos;, &apos;2015-01-07&apos;, &apos;2017-04-01&apos;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">info=list(zip(data[&apos;age&apos;],data[&apos;phone&apos;],data[&apos;dept&apos;],data[&apos;enrolled_date&apos;],data[&apos;name&apos;],data[&apos;id&apos;]))</span><br><span class="line"></span><br><span class="line">res=(&apos; &apos;.join(info[0]))</span><br></pre></td></tr></table></figure><pre><code>字典的查询速度是比较快的</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;zip,map,filter,reduce,sorted，列表推导式。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="高阶函数" scheme="http://yoursite.com/tags/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>python 多分支判断</title>
    <link href="http://yoursite.com/2019/03/22/python-%E5%A4%9A%E5%88%86%E6%94%AF%E5%88%A4%E6%96%AD/"/>
    <id>http://yoursite.com/2019/03/22/python-多分支判断/</id>
    <published>2019-03-22T10:32:36.000Z</published>
    <updated>2019-04-30T23:44:43.446Z</updated>
    
    <content type="html"><![CDATA[<p>python中没有switch语句，可以考虑字典的映射关系来实现多分支判断。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">swtich_dic=&#123;</span><br><span class="line">&quot;add&quot;:add_info,</span><br><span class="line">&quot;del&quot;:del_info,</span><br><span class="line">&quot;find&quot;:find_info,</span><br><span class="line">&quot;update&quot;:update_info</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">cmd=input(&apos;&gt;&gt;：&apos;).strip().lower().split()</span><br><span class="line">if not cmd:continue</span><br><span class="line">if cmd in func_dic:</span><br><span class="line">func = switch_dic.get(cmd)</span><br><span class="line">func()</span><br></pre></td></tr></table></figure><pre><code>实现功能以后,可以用极限法看看代码有没有优化的地方,就比如这个分支判断，如果用极限法放大分支数量,就会发现用字典的优势了,还有数据,如果数据量比较大的话,也是一样的</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;python中没有switch语句，可以考虑字典的映射关系来实现多分支判断。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="多分支判断" scheme="http://yoursite.com/tags/%E5%A4%9A%E5%88%86%E6%94%AF%E5%88%A4%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>python 增删改查操作</title>
    <link href="http://yoursite.com/2019/03/22/python-%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/"/>
    <id>http://yoursite.com/2019/03/22/python-增删改查/</id>
    <published>2019-03-22T10:32:36.000Z</published>
    <updated>2019-04-30T04:12:51.113Z</updated>
    
    <content type="html"><![CDATA[<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="查找find"><a href="#查找find" class="headerlink" title="查找find"></a>查找find</h2><h2 id="替换replace"><a href="#替换replace" class="headerlink" title="替换replace"></a>替换replace</h2><h2 id="strip"><a href="#strip" class="headerlink" title="strip()"></a>strip()</h2><h2 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h2><h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h2 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h2><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><h2 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h2><h2 id="增加-1"><a href="#增加-1" class="headerlink" title="增加"></a>增加</h2><h2 id="更新-1"><a href="#更新-1" class="headerlink" title="更新"></a>更新</h2><h2 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h2><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="查找-2"><a href="#查找-2" class="headerlink" title="查找"></a>查找</h2><h2 id="增加-2"><a href="#增加-2" class="headerlink" title="增加"></a>增加</h2><h2 id="更新-2"><a href="#更新-2" class="headerlink" title="更新"></a>更新</h2><h2 id="删除-2"><a href="#删除-2" class="headerlink" title="删除"></a>删除</h2><h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><h2 id="查找-3"><a href="#查找-3" class="headerlink" title="查找"></a>查找</h2><h2 id="增加-3"><a href="#增加-3" class="headerlink" title="增加"></a>增加</h2><h2 id="更新-3"><a href="#更新-3" class="headerlink" title="更新"></a>更新</h2><h2 id="删除-3"><a href="#删除-3" class="headerlink" title="删除"></a>删除</h2><h1 id="Json"><a href="#Json" class="headerlink" title="Json"></a>Json</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;字符串&quot;&gt;&lt;a href=&quot;#字符串&quot; class=&quot;headerlink&quot; title=&quot;字符串&quot;&gt;&lt;/a&gt;字符串&lt;/h1&gt;&lt;h2 id=&quot;查找find&quot;&gt;&lt;a href=&quot;#查找find&quot; class=&quot;headerlink&quot; title=&quot;查找find&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="增删改查" scheme="http://yoursite.com/tags/%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/"/>
    
  </entry>
  
  <entry>
    <title>python 常用模块</title>
    <link href="http://yoursite.com/2019/03/21/python-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    <id>http://yoursite.com/2019/03/21/python-常用模块/</id>
    <published>2019-03-21T10:32:36.000Z</published>
    <updated>2019-05-04T11:48:42.877Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><pre><code>python中，一个py文件就是一个模块避免函数名和变量名冲突。提高代码可维护性，可重用</code></pre><h1 id="模块分类"><a href="#模块分类" class="headerlink" title="模块分类"></a>模块分类</h1><p>模块分三种</p><ul><li>内置标准模块（又称标准库）执行help(‘modules’)查看所有python自带模块列表</li><li>第三方开源模块，可通过pip install 模块名 安装</li><li>自定义模块<br>  模块一旦被调用，执行了文件里的程序<h1 id="模块安装"><a href="#模块安装" class="headerlink" title="模块安装"></a>模块安装</h1></li><li>模块路径<br>  sys.path</li><li>卸载模块<br>  pip3 uninstall modules</li><li>国内源安装<br>  pip3 install -i <a href="http://pypi.douban.com/simple/" target="_blank" rel="noopener">http://pypi.douban.com/simple/</a> modules –trusted-host pypi.douban.com</li></ul><h1 id="模块导入"><a href="#模块导入" class="headerlink" title="模块导入"></a>模块导入</h1><pre><code>执行文件的目录为当前目录python2中文件夹中增加__init__.py,将文件夹变成包</code></pre><ul><li>导入路径，动态识别当前路径<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import sys,os</span><br><span class="line">print(dir())</span><br><span class="line">print(__file__)</span><br><span class="line">#相对路径</span><br><span class="line">#BASE_DIR = os.path.dirname(os.path.dirname(__file__))</span><br><span class="line">#sys.path.append()</span><br><span class="line">#绝对路径</span><br><span class="line">os.path.abspath(__file__)</span><br><span class="line">BASE_DIR = os.path.dirname(os.path.abspath(__file__))</span><br><span class="line">sys.path.append(BASE_DIR)</span><br><span class="line">#相对路径 </span><br><span class="line"># from . import models</span><br><span class="line"># 相对导入不能存在程序主入口</span><br></pre></td></tr></table></figure></li></ul><h1 id="time与datetime模块"><a href="#time与datetime模块" class="headerlink" title="time与datetime模块"></a>time与datetime模块</h1><p>在python中，通常3种时间的表示</p><ul><li>时间戳(timestamp)：通常来说，时间戳表示的是从1970年1月1日00:00:00开始按秒计算的偏移量。我们运行“type(time.time())”，返回的是float类型。</li><li>格式化的时间字符串(Format String)</li><li><p>结构化的时间(struct_time)：struct_time元组共有9个元素共九个元素:(年，月，日，时，分，秒，一年中第几周，一年中第几天，夏令时)</p><img src="/2019/03/21/python-常用模块/时间转换.jpg"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">print(time.time())</span><br><span class="line"># 时间戳:1546273960.5988934</span><br><span class="line"> </span><br><span class="line">print(time.localtime())</span><br><span class="line">#本地时区的struct_time  time.struct_time(tm_year=2019, tm_mon=1, tm_mday=1, tm_hour=0, tm_min=32, tm_sec=40, tm_wday=1, tm_yday=1, tm_isdst=0)</span><br><span class="line">print(time.localtime(1546273960.5988934))</span><br><span class="line">#time.struct_time(tm_year=2019, tm_mon=1, tm_mday=1, tm_hour=0, tm_min=32, tm_sec=40, tm_wday=1, tm_yday=1, tm_isdst=0)</span><br><span class="line"> </span><br><span class="line">print(time.gmtime())</span><br><span class="line">#UTC时区的struct_time   time.struct_time(tm_year=2018, tm_mon=12, tm_mday=31, tm_hour=16, tm_min=32, tm_sec=40, tm_wday=0, tm_yday=365, tm_isdst=0)</span><br><span class="line">print(time.gmtime(1546273960.5988934))</span><br><span class="line">#UTC时区的struct_time   time.struct_time(tm_year=2018, tm_mon=12, tm_mday=31, tm_hour=16, tm_min=32, tm_sec=40, tm_wday=0, tm_yday=365, tm_isdst=0)</span><br><span class="line"> </span><br><span class="line">print(time.mktime(time.localtime()))</span><br><span class="line">#将一个结构化struct_time转化为时间戳。#1546274313.0</span><br><span class="line"> </span><br><span class="line">print(time.strftime(&quot;%Y-%m-%d %X&quot;))</span><br><span class="line">#格式化的时间字符串:&apos;2019-01-01 00:32:40&apos;</span><br><span class="line">print(time.strftime(&quot;%Y-%m-%d %X&quot;, time.localtime()))</span><br><span class="line">#格式化的时间字符串:&apos;2019-01-01 00:32:40&apos;</span><br><span class="line"> </span><br><span class="line">print(time.strptime(&apos;2018-08-08 16:37:06&apos;, &apos;%Y-%m-%d %X&apos;))</span><br><span class="line">#把一个格式化时间字符串转化为struct_time。实际上它和strftime()是逆操作。 time.struct_time(tm_year=2018, tm_mon=8, tm_mday=8, tm_hour=16, tm_min=37, tm_sec=6, tm_wday=2, tm_yday=220, tm_isdst=-1)</span><br><span class="line">#%z</span><br><span class="line">#%Z</span><br><span class="line">#%w</span><br><span class="line">#%U</span><br><span class="line">#%p</span><br><span class="line">time.sleep(5)#线程推迟指定的时间运行，单位为秒。</span><br></pre></td></tr></table></figure></li><li><p>asctime/ctime</p><img src="/2019/03/21/python-常用模块/ctime.jpg"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">print(time.asctime())#Tue Jan  1 00:53:00 2019</span><br><span class="line">print(time.asctime(time.localtime()))#Tue Jan  1 00:55:00 2019</span><br><span class="line"> </span><br><span class="line">print(time.ctime())  # Tue Jan  1 00:53:00 2019</span><br><span class="line">print(time.ctime(time.time()))  # Tue Jan  1 00:53:00 2019</span><br></pre></td></tr></table></figure></li></ul><img src="/2019/03/21/python-常用模块/时间转换2.png"><ul><li>时间加减<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import datetime,time</span><br><span class="line"> </span><br><span class="line">print(datetime.datetime.now()) #返回 2019-01-01 00:56:58.771296</span><br><span class="line">print(datetime.date.fromtimestamp(time.time()) )  # 时间戳直接转成日期格式 2019-01-01</span><br><span class="line"> </span><br><span class="line">print(datetime.datetime.now() + datetime.timedelta(3)) #当前时间+3天  2019-01-04 00:56:58.771296</span><br><span class="line">print(datetime.datetime.now() + datetime.timedelta(-3)) #当前时间-3天 2018-12-29 00:56:58.771296</span><br><span class="line">print(datetime.datetime.now() + datetime.timedelta(hours=3)) #当前时间+3小时  2019-01-01 03:56:58.771296</span><br><span class="line">print(datetime.datetime.now() + datetime.timedelta(minutes=30)) #当前时间+30分  2019-01-01 01:26:58.771296</span><br><span class="line"> </span><br><span class="line">c_time  = datetime.datetime.now()</span><br><span class="line">print(c_time.replace(minute=3,hour=2)) #时间替换  2019-01-01 02:03:58.771296</span><br></pre></td></tr></table></figure></li></ul><h1 id="random模块"><a href="#random模块" class="headerlink" title="random模块"></a>random模块</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line">print(random.random())  # (0,1)----float    大于0且小于1之间的小数</span><br><span class="line">print(random.randint(1, 3))  # [1,3]    大于等于1且小于等于3之间的整数</span><br><span class="line">print(random.randrange(1, 3))  # [1,3)    大于等于1且小于3之间的整数</span><br><span class="line">print(random.choice([1, &apos;23&apos;, [4, 5]]))  # 1或者23或者[4,5]</span><br><span class="line">print(random.sample([1, &apos;23&apos;, [4, 5]], 2))  # 列表元素任意2个组合</span><br><span class="line">print(random.uniform(1, 3))  # 大于1小于3的小数，如1.927109612082716</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line">def make_code(n):</span><br><span class="line">    res=&apos;&apos;</span><br><span class="line">    for i in range(n):</span><br><span class="line">        alf=chr(random.randint(65,90))</span><br><span class="line">        num=str(random.randint(0,9))</span><br><span class="line">        res+=random.choice([alf,num])</span><br><span class="line">    return res</span><br><span class="line"> </span><br><span class="line">print(make_code(6))</span><br></pre></td></tr></table></figure><h1 id="os模块"><a href="#os模块" class="headerlink" title="os模块"></a>os模块</h1><p>os模块是与操作系统交互的一个接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">os.getcwd() 获取当前工作目录，即当前python脚本工作的目录路径</span><br><span class="line">os.chdir(&quot;dirname&quot;)  改变当前脚本工作目录；相当于shell下cd</span><br><span class="line">os.curdir  返回当前目录: (&apos;.&apos;)</span><br><span class="line">os.pardir  获取当前目录的父目录字符串名：(&apos;..&apos;)</span><br><span class="line">os.makedirs(&apos;dirname1/dirname2&apos;)    可生成多层递归目录</span><br><span class="line">os.removedirs(&apos;dirname1&apos;)    若目录为空，则删除，并递归到上一级目录，如若也为空，则删除，依此类推</span><br><span class="line">os.mkdir(&apos;dirname&apos;)    生成单级目录；相当于shell中mkdir dirname ，默认权限777</span><br><span class="line">os.rmdir(&apos;dirname&apos;)    删除单级空目录，若目录不为空则无法删除，报错；相当于shell中rmdir dirname</span><br><span class="line">os.listdir(&apos;dirname&apos;)    列出指定目录下的所有文件和子目录，包括隐藏文件，并以列表方式打印</span><br><span class="line">os.remove()  删除一个文件</span><br><span class="line">os.rename(&quot;oldname&quot;,&quot;newname&quot;)  重命名文件/目录， 无返回值</span><br><span class="line">os.stat(&apos;path/filename&apos;)  获取文件/目录信息</span><br><span class="line">os.sep    输出操作系统特定的路径分隔符，win下为&quot;\\&quot;,Linux下为&quot;/&quot;</span><br><span class="line">os.linesep    输出当前平台使用的行终止符，win下为&quot;\t\n&quot;,Linux下为&quot;\n&quot;</span><br><span class="line">os.pathsep    输出用于分割文件路径的字符串 win下为;,Linux下为:</span><br><span class="line">os.name    输出字符串指示当前使用平台。win-&gt;&apos;nt&apos;; Linux-&gt;&apos;posix&apos;</span><br><span class="line">os.system(&quot;bash command&quot;)  运行shell命令，直接显示</span><br><span class="line">os.environ  获取系统环境变量</span><br><span class="line">os.path.abspath(path)  返回path规范化的绝对路径</span><br><span class="line">os.path.split(path)  将path分割成目录和文件名二元组返回</span><br><span class="line">os.path.dirname(path)  返回path的目录。其实就是os.path.split(path)的第一个元素</span><br><span class="line">os.path.basename(path)  返回path最后的文件名。如何path以／或\结尾，那么就会返回空值。即os.path.split(path)的第二个元素</span><br><span class="line">os.path.exists(path)  如果path存在，返回True；如果path不存在，返回False</span><br><span class="line">os.path.isabs(path)  如果path是绝对路径，返回True</span><br><span class="line">os.path.isfile(path)  如果path是一个存在的文件，返回True。否则返回False</span><br><span class="line">os.path.isdir(path)  如果path是一个存在的目录，则返回True。否则返回False</span><br><span class="line">os.path.join(path1[, path2[, ...]])  将多个路径组合后返回，第一个绝对路径之前的参数将被忽略</span><br><span class="line">print(os.path.join(&quot;D:\\python\\wwww&quot;,&quot;aaa&quot;))   #做路径拼接用的 #D:\python\wwww\aaa</span><br><span class="line">print(os.path.join(r&quot;D:\python\wwww&quot;,&quot;aaa&quot;))   #做路径拼接用的 #D:\python\wwww\aaa</span><br><span class="line">os.path.getatime(path)  返回path所指向的文件或者目录的最后存取时间</span><br><span class="line">os.path.getmtime(path)  返回path所指向的文件或者目录的最后修改时间</span><br><span class="line">os.path.getsize(path) 返回path的大小</span><br><span class="line">在Linux和Mac平台上，该函数会原样返回path，在windows平台上会将路径中所有字符转换为小写，并将所有斜杠转换为饭斜杠。</span><br><span class="line">&gt;&gt;&gt; os.path.normcase(&apos;c:/windows\\system32\\&apos;)  </span><br><span class="line">&apos;c:\\windows\\system32\\&apos;  </span><br><span class="line">    </span><br><span class="line"> </span><br><span class="line">规范化路径，如..和/</span><br><span class="line">&gt;&gt;&gt; os.path.normpath(&apos;c://windows\\System32\\../Temp/&apos;)  </span><br><span class="line">&apos;c:\\windows\\Temp&apos;  </span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; a=&apos;/Users/jieli/test1/\\\a1/\\\\aa.py/../..&apos;</span><br><span class="line">&gt;&gt;&gt; print(os.path.normpath(a))</span><br><span class="line">/Users/jieli/test1</span><br><span class="line">os路径处理</span><br><span class="line">#方式一：推荐使用</span><br><span class="line">import os</span><br><span class="line">#具体应用</span><br><span class="line">import os,sys</span><br><span class="line">possible_topdir = os.path.normpath(os.path.join(</span><br><span class="line">    os.path.abspath(__file__),</span><br><span class="line">    os.pardir, #上一级</span><br><span class="line">    os.pardir,</span><br><span class="line">    os.pardir</span><br><span class="line">))</span><br><span class="line">sys.path.insert(0,possible_topdir)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">#方式二：不推荐使用</span><br><span class="line">os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))</span><br></pre></td></tr></table></figure></p><h1 id="sys模块"><a href="#sys模块" class="headerlink" title="sys模块"></a>sys模块</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">sys.version</span><br><span class="line">sys.maxsize</span><br><span class="line">sys.path</span><br><span class="line">sys.platform</span><br><span class="line">sys.stdout.write(&apos;hey world&apos;)</span><br><span class="line">val = sys.stdin.readline()[:-1]</span><br><span class="line">sys.getrecursionlimit()</span><br><span class="line">sys.setrecursionlimit(2000)</span><br><span class="line">sys.getdefaultencoding()</span><br><span class="line">sys.getfilesystemencoding() #文件的默认编码</span><br></pre></td></tr></table></figure><h1 id="shutil模块"><a href="#shutil模块" class="headerlink" title="shutil模块"></a>shutil模块</h1><p>高级的 文件、文件夹、压缩包 处理模块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import shutil</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">高级的 文件、文件夹、压缩包 处理模块</span><br><span class="line">shutil.copyfileobj(fsrc, fdst[, length])</span><br><span class="line">将文件内容拷贝到另一个文件中,可以指定部分长度内容copy,直到结束</span><br></pre></td></tr></table></figure></p><p>import shutil<br>f1 = open(“source.py”,’r’)<br>f2 = open(“new.py”,’w’)<br>shutil.copyfileobj(f1,f2)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">shutil.copyfile(src, dst)</span><br><span class="line">拷贝文件,</span><br><span class="line"> </span><br><span class="line">shutil.copymode(src, dst)</span><br><span class="line">仅拷贝权限。内容、组、用户均不变</span><br><span class="line"> </span><br><span class="line">shutil.copystat(src, dst)</span><br><span class="line">仅拷贝状态的信息，包括：mode bits, atime创建时间, mtime修改时间, flags</span><br><span class="line"> </span><br><span class="line">shutil.copy(src, dst)</span><br><span class="line">拷贝文件和权限</span><br><span class="line"> </span><br><span class="line">shutil.copy2(src, dst)</span><br><span class="line">拷贝文件和状态信息</span><br><span class="line"> </span><br><span class="line">shutil.ignore_patterns(*patterns)</span><br><span class="line">shutil.copytree(src, dst, symlinks=False, ignore=None)</span><br><span class="line">递归的去拷贝文件夹</span><br><span class="line"> </span><br><span class="line">shutil.move(src, dst)</span><br><span class="line">递归的去移动文件，它类似mv命令，其实就是重命名。</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"> </span><br><span class="line">shutil.copyfileobj(open(&apos;xmltest.xml&apos;,&apos;r&apos;), open(&apos;new.xml&apos;, &apos;w&apos;))</span><br><span class="line">shutil.copyfile(&apos;b.txt&apos;, &apos;bnew.txt&apos;)#目标文件无需存在</span><br><span class="line">shutil.copymode(&apos;f1.log&apos;, &apos;f2.log&apos;) #目标文件必须存在</span><br><span class="line">shutil.copystat(&apos;f1.log&apos;, &apos;f2.log&apos;) #目标文件必须存在</span><br><span class="line">shutil.copy(&apos;f1.log&apos;, &apos;f2.log&apos;)</span><br><span class="line">shutil.copy2(&apos;f1.log&apos;, &apos;f2.log&apos;)</span><br><span class="line">shutil.copytree(&apos;folder1&apos;, &apos;folder2&apos;, ignore=shutil.ignore_patterns(&apos;*.pyc&apos;, &apos;tmp*&apos;)) #目标目录不能存在，注意对folder2目录父级目录要有可写权限，ignore的意思是排除</span><br><span class="line"> </span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">通常的拷贝都把软连接拷贝成硬链接，即对待软连接来说，创建新的文件</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">#拷贝软连接</span><br><span class="line">shutil.copytree(&apos;f1&apos;, &apos;f2&apos;, symlinks=True, ignore=shutil.ignore_patterns(&apos;*.pyc&apos;, &apos;tmp*&apos;))</span><br><span class="line"> </span><br><span class="line">shutil.move(&apos;folder1&apos;, &apos;folder3&apos;)</span><br><span class="line"> </span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">shutil.make_archive(base_name, format,...)</span><br><span class="line">创建压缩包并返回文件路径，例如：zip、tar</span><br><span class="line">base_name： 压缩包的文件名，也可以是压缩包的路径。只是文件名时，则保存至当前目录，否则保存至指定路径，</span><br><span class="line">如 data_bak                       =&gt;保存至当前路径</span><br><span class="line">如：/tmp/data_bak =&gt;保存至/tmp/</span><br><span class="line">format： 压缩包种类，“zip”, “tar”, “bztar”，“gztar”</span><br><span class="line">root_dir：   要压缩的文件夹路径（默认当前目录）</span><br><span class="line">owner：  用户，默认当前用户</span><br><span class="line">group：  组，默认当前组</span><br><span class="line">logger： 用于记录日志，通常是logging.Logger对象</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"> </span><br><span class="line"># 将 /data 下的文件打包放置当前程序目录</span><br><span class="line">import shutil</span><br><span class="line">ret = shutil.make_archive(&quot;data_bak&quot;, &apos;gztar&apos;, root_dir=&apos;/data&apos;)</span><br><span class="line"># 将 /data下的文件打包放置 /tmp/目录</span><br><span class="line">import shutil</span><br><span class="line">ret = shutil.make_archive(&quot;/tmp/data_bak&quot;, &apos;gztar&apos;, root_dir=&apos;/data&apos;)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">#shutil 对压缩包的处理是调用 ZipFile 和 TarFile 两个模块来进行的，详细：</span><br><span class="line"> </span><br><span class="line">#zipfile压缩解压缩</span><br><span class="line">import zipfile</span><br><span class="line"># 压缩</span><br><span class="line">z = zipfile.ZipFile(&apos;laxi.zip&apos;, &apos;w&apos;)</span><br><span class="line">z.write(&apos;a.log&apos;)</span><br><span class="line">z.write(&apos;data.data&apos;)</span><br><span class="line">z.close()</span><br><span class="line"> </span><br><span class="line"># 解压</span><br><span class="line">z = zipfile.ZipFile(&apos;laxi.zip&apos;, &apos;r&apos;)</span><br><span class="line">z.extractall(path=&apos;.&apos;)</span><br><span class="line">z.close()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">#tarfile压缩解压缩</span><br><span class="line">import tarfile</span><br><span class="line"> </span><br><span class="line"># 压缩</span><br><span class="line">t=tarfile.open(&apos;/tmp/egon.tar&apos;,&apos;w&apos;)</span><br><span class="line">t.add(&apos;/test1/a.py&apos;,arcname=&apos;a.bak&apos;)</span><br><span class="line">t.add(&apos;/test1/b.py&apos;,arcname=&apos;b.bak&apos;)</span><br><span class="line">t.close()</span><br><span class="line"> </span><br><span class="line"># 解压</span><br><span class="line">t=tarfile.open(&apos;/tmp/egon.tar&apos;,&apos;r&apos;)</span><br><span class="line">t.extractall(&apos;/egon&apos;)</span><br><span class="line">t.close()</span><br></pre></td></tr></table></figure></p><h1 id="序列化模块"><a href="#序列化模块" class="headerlink" title="序列化模块"></a>序列化模块</h1><ul><li>什么是序列化<br>  内存里的数据转成字符串，存到硬盘或者网络传输。我们把对象(变量)从内存中变成可存储或传输的过程称之为序列化，在Python中叫pickling，在其他语言中也被称之为serialization，marshalling，flattening等等，都是一个意思。</li><li><p>为什么要序列化<br>  dict等对象无法保存到硬盘上<br>  持久保持状态<br>  跨平台数据交互</p></li><li><p>什么是反序列化<br>把变量字符内容从序列化的对象重新读到内存里称之为反序列化</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">data = &#123;&apos;students&apos;:[</span><br><span class="line">&#123;&apos;name&apos;:&apos;zhangsan,&apos;age&apos;:20&#125;</span><br><span class="line">&#123;&apos;name&apos;:&apos;lisi&apos;,&apos;age&apos;:25&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">f = open(&quot;school&quot;,&quot;w&quot;)</span><br><span class="line">f.write(str(data))</span><br><span class="line">f.close()</span><br><span class="line">f = open(&quot;school&quot;,&apos;r&apos;)</span><br><span class="line">d = f.read()</span><br><span class="line">d = eval(d)</span><br><span class="line">print(d[&apos;roles&apos;])</span><br></pre></td></tr></table></figure><p>eval内置方法可以将一个字符串转成python对象，不过，eval方法是有局限性的，对于普通的数据类型，json.loads和eval都能用，但遇到特殊类型的时候，eval就不管用了,所以eval的重点还是通常用来执行一个字符串表达式，并返回表达式的值。<br>    如果我们要在不同的编程语言之间传递对象，就必须把对象序列化为标准格式，比如XML，但更好的方法是序列化为JSON，因为JSON表示出来就是一个字符串，可以被所有语言读取，也可以方便地存储到磁盘或者通过网络传输。<br>    JSON不仅是标准格式，并且比XML更快，而且可以直接在Web页面中读取，非常方便。</p><h2 id="json模块"><a href="#json模块" class="headerlink" title="json模块"></a>json模块</h2><ul><li>JSON表示的对象就是标准的JavaScript语言的对象，JSON和Python内置的数据类型对应如下：</li></ul><table><thead><tr><th>json类型</th><th>python类型</th></tr></thead><tbody><tr><td>{}</td><td>dict</td></tr><tr><td>[]</td><td>list</td></tr><tr><td>()</td><td>tuple</td></tr><tr><td>“string”</td><td>str</td></tr><tr><td>1234.56</td><td>int or float</td></tr><tr><td>true/false</td><td>True/False</td></tr><tr><td>null</td><td>None</td></tr></tbody></table><ul><li>json.dumps(data) json.loads#转换成字符串到内存中<blockquote><p>把你的内存数据 通过网络 共享给远程其它人<br>跨平台、跨语言共享数据</p></blockquote></li><li><p>转换成字符存储到文件中</p><blockquote><p>f = file.open(“data.json”,”w”)<br>json.dump(data,f)</p></blockquote></li><li><p>读取文件的数据</p><blockquote><p>f = open(“data.json”,”r”)<br>data = json.load(f)</p></blockquote></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">dumps,loads</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">import json</span><br><span class="line"> </span><br><span class="line">dic = &#123;&apos;name&apos;: &apos;tom&apos;, &apos;age&apos;: 18, &apos;sex&apos;: &apos;male&apos;&#125;</span><br><span class="line">print(type(dic))  # &lt;class &apos;dict&apos;&gt;</span><br><span class="line"> </span><br><span class="line">j = json.dumps(dic)</span><br><span class="line">print(type(j))  # &lt;class &apos;str&apos;&gt;</span><br><span class="line"> </span><br><span class="line">f = open(&apos;序列化对象&apos;, &apos;w&apos;)</span><br><span class="line">f.write(j)  #等价于json.dump(dic,f)</span><br><span class="line">f.close()</span><br><span class="line">#反序列化</span><br><span class="line">import json</span><br><span class="line">f = open(&apos;序列化对象&apos;)</span><br><span class="line">data = json.loads(f.read())  # 等价于data=json.load(f)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">无论数据是怎样创建的，只要满足json格式，就可以json.loads出来,不一定非要dumps的数据才能loads</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">import json</span><br><span class="line">dct=&quot;&#123;&apos;1&apos;:111&#125;&quot;#报错,json 不认单引号</span><br><span class="line">dct=str(&#123;&quot;1&quot;:&quot;111&quot;&#125;)#报错,因为生成的数据还是单引号:&#123;&apos;1&apos;: &apos;111&apos;&#125;</span><br><span class="line">print(dct)  #&#123;&apos;1&apos;: &apos;111&apos;&#125;</span><br><span class="line"> </span><br><span class="line">dct=str(&apos;&#123;&quot;1&quot;:&quot;111&quot;&#125;&apos;)#正确写法</span><br><span class="line">dct=&apos;&#123;&quot;1&quot;:&quot;111&quot;&#125;&apos;#正确写法</span><br><span class="line">print(json.loads(dct))</span><br></pre></td></tr></table></figure><pre><code>json模块只能序列化int,str,list,dict,tuple五种类型ensure_ascii参数还是比较常用的，当该参数的值 为True（默认值）时，输出中的所有非ASCII字符（比如中文）都会被转义成&apos;\uXXXX&apos;组成的序 列，所以设置为Flase就可以保留中文字符。sort_keys参数表示序列化时是否对dict的key进行排序indent参数可以设置数据存储的格式separators参数也可以优化数据存储格式，重新指定分隔符，从而去除无用的空白字符</code></pre><h2 id="pickle"><a href="#pickle" class="headerlink" title="pickle"></a>pickle</h2><p>Pickle的问题和所有其他编程语言特有的序列化问题一样，就是它只能用于Python，支持python所有的数据类型，有可能不同版本的Python彼此都不兼容，因此，只能用Pickle保存那些不重要的数据，不能成功地反序列化也没关系。<br>可序列化所有类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import pickle</span><br><span class="line">dic = &#123;&apos;name&apos;: &apos;tom&apos;, &apos;age&apos;: 23, &apos;sex&apos;: &apos;male&apos;&#125;</span><br><span class="line">print(type(dic))  # &lt;class &apos;dict&apos;&gt;</span><br><span class="line"> </span><br><span class="line">j = pickle.dumps(dic)</span><br><span class="line">print(type(j))  # &lt;class &apos;bytes&apos;&gt;</span><br><span class="line"> </span><br><span class="line">f = open(&apos;序列化对象_pickle&apos;, &apos;wb&apos;)  # 注意是w是写入str,wb是写入bytes,j是&apos;bytes&apos;</span><br><span class="line">f.write(j)  #-等价于pickle.dump(dic,f)</span><br><span class="line"> </span><br><span class="line">f.close()</span><br><span class="line"> </span><br><span class="line"># 反序列化</span><br><span class="line">import pickle</span><br><span class="line">f = open(&apos;序列化对象_pickle&apos;, &apos;rb&apos;)</span><br><span class="line">data = pickle.loads(f.read())  # 等价于data=pickle.load(f)</span><br><span class="line">print(data[&apos;age&apos;])</span><br></pre></td></tr></table></figure></p><h2 id="shelve模块"><a href="#shelve模块" class="headerlink" title="shelve模块"></a>shelve模块</h2><p>shelve模块比pickle模块简单，只有一个open函数，返回类似字典的对象，可读可写;key必须为字符串，而值可以是python所支持的数据类型<br>支持多次序列化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import shelve</span><br><span class="line">f=shelve.open(r&apos;sheve.txt&apos;)</span><br><span class="line">#存</span><br><span class="line"># f[&apos;stu1_info&apos;]=&#123;&apos;name&apos;:&apos;rose&apos;,&apos;age&apos;:18,&apos;hobby&apos;:[&apos;sing&apos;,&apos;talk&apos;,&apos;swim&apos;]&#125;</span><br><span class="line"># f[&apos;stu2_info&apos;]=&#123;&apos;name&apos;:&apos;tom&apos;,&apos;age&apos;:53&#125;</span><br><span class="line">#取</span><br><span class="line">print(f[&apos;stu1_info&apos;][&apos;hobby&apos;])</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure></p><h2 id="xml模块"><a href="#xml模块" class="headerlink" title="xml模块"></a>xml模块</h2><p>xml是实现不同语言或程序之间进行数据交换的协议，跟json差不多，但json使用起来更简单，不过，古时候，在json还没诞生的黑暗年代，大家只能选择用xml呀，至今很多传统公司如金融行业的很多系统的接口还主要是xml。<br>    &lt;?xml version=”1.0”?&gt;<br>    <data><br>        <country name="Liechtenstein"><br>            <rank updated="yes">2</rank><br>            <year>2008</year><br>            <gdppc>141100</gdppc><br>            <neighbor name="Austria" direction="E"><br>            <neighbor name="Switzerland" direction="W"><br>        </neighbor></neighbor></country><br>        <country name="Singapore"><br>            <rank updated="yes">5</rank><br>            <year>2011</year><br>            <gdppc>59900</gdppc><br>            <neighbor name="Malaysia" direction="N"><br>        </neighbor></country><br>        <country name="Panama"><br>            <rank updated="yes">69</rank><br>            <year>2011</year><br>            <gdppc>13600</gdppc><br>            <neighbor name="Costa Rica" direction="W"><br>            <neighbor name="Colombia" direction="E"><br>        </neighbor></neighbor></country><br>    </data></p><h3 id="解析方式"><a href="#解析方式" class="headerlink" title="解析方式"></a>解析方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"> </span><br><span class="line">import xml.etree.ElementTree as ET</span><br><span class="line"> </span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">############ 解析方式一 ############</span><br><span class="line">str_xml = open(&apos;xmltest.xml&apos;, &apos;r&apos;).read()# 打开文件，读取XML内容</span><br><span class="line">root = ET.XML(str_xml)# 将字符串解析成xml特殊对象，root代指xml文件的根节点</span><br><span class="line">print(root.tag)#获取根节点的标签名</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">############ 解析方式二 ############</span><br><span class="line">tree = ET.parse(&quot;xmltest.xml&quot;)# 直接解析xml文件</span><br><span class="line">root = tree.getroot()# 获取xml文件的根节点</span><br><span class="line">print(root.tag)#获取根节点的标签名</span><br><span class="line"> </span><br><span class="line"># 遍历xml文档</span><br><span class="line">for child in root:</span><br><span class="line">    print(&apos;========&gt;&apos;, child.tag, child.attrib, child.attrib[&apos;name&apos;])</span><br><span class="line">    for i in child:</span><br><span class="line">        print(i.tag, i.attrib, i.text)   #标签 属性 文本</span><br><span class="line"> </span><br><span class="line"># 只遍历year 节点</span><br><span class="line">for node in root.iter(&apos;year&apos;):</span><br><span class="line">    print(node.tag, node.text)</span><br><span class="line"># ---------------------------------------</span><br><span class="line"> </span><br><span class="line">import xml.etree.ElementTree as ET</span><br><span class="line"> </span><br><span class="line">tree = ET.parse(&quot;xmltest.xml&quot;)</span><br><span class="line">root = tree.getroot()</span><br><span class="line"> </span><br><span class="line"># 修改</span><br><span class="line">for node in root.iter(&apos;year&apos;):</span><br><span class="line">    new_year = int(node.text) + 1</span><br><span class="line">    node.text = str(new_year)</span><br><span class="line">    node.set(&apos;updated&apos;, &apos;yes&apos;)</span><br><span class="line">    node.set(&apos;version&apos;, &apos;1.0&apos;)</span><br><span class="line">tree.write(&apos;test.xml&apos;)</span><br><span class="line"> </span><br><span class="line"># 删除node</span><br><span class="line">for country in root.findall(&apos;country&apos;):</span><br><span class="line">    rank = int(country.find(&apos;rank&apos;).text)</span><br><span class="line">    if rank &gt; 50:</span><br><span class="line">        root.remove(country)</span><br><span class="line"> </span><br><span class="line">tree.write(&apos;output.xml&apos;)</span><br><span class="line"> </span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">#在country内添加（append）节点year2</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"> </span><br><span class="line">import xml.etree.ElementTree as ET</span><br><span class="line">tree = ET.parse(&quot;xmltest.xml&quot;)</span><br><span class="line">root=tree.getroot()</span><br><span class="line">for country in root.findall(&apos;country&apos;):</span><br><span class="line">    for year in country.findall(&apos;year&apos;):</span><br><span class="line">        if int(year.text) &gt; 2000:</span><br><span class="line">            year2=ET.Element(&apos;year2&apos;)</span><br><span class="line">            year2.text=&apos;新年&apos;</span><br><span class="line">            year2.attrib=&#123;&apos;update&apos;:&apos;yes&apos;&#125;</span><br><span class="line">            country.append(year2) #往country节点下添加子节点</span><br><span class="line"> </span><br><span class="line">tree.write(&apos;a.xml.swap&apos;)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">#自己创建xml文档</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"> </span><br><span class="line">import xml.etree.ElementTree as ET</span><br><span class="line"> </span><br><span class="line">new_xml = ET.Element(&quot;namelist&quot;)</span><br><span class="line">name = ET.SubElement(new_xml, &quot;name&quot;, attrib=&#123;&quot;enrolled&quot;: &quot;yes&quot;&#125;)</span><br><span class="line">age = ET.SubElement(name, &quot;age&quot;, attrib=&#123;&quot;checked&quot;: &quot;no&quot;&#125;)</span><br><span class="line">sex = ET.SubElement(name, &quot;sex&quot;)</span><br><span class="line">sex.text = &apos;33&apos;</span><br><span class="line">name2 = ET.SubElement(new_xml, &quot;name&quot;, attrib=&#123;&quot;enrolled&quot;: &quot;no&quot;&#125;)</span><br><span class="line">age = ET.SubElement(name2, &quot;age&quot;)</span><br><span class="line">age.text = &apos;19&apos;</span><br><span class="line"> </span><br><span class="line">et = ET.ElementTree(new_xml)  # 生成文档对象</span><br><span class="line">et.write(&quot;test.xml&quot;, encoding=&quot;utf-8&quot;, xml_declaration=True)</span><br><span class="line"> </span><br><span class="line">ET.dump(new_xml)  # 打印生成的格式</span><br></pre></td></tr></table></figure><h3 id="xml的语法功能"><a href="#xml的语法功能" class="headerlink" title="xml的语法功能"></a>xml的语法功能</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br></pre></td><td class="code"><pre><span class="line">class Element:</span><br><span class="line">    &quot;&quot;&quot;An XML element.</span><br><span class="line"></span><br><span class="line">    This class is the reference implementation of the Element interface.</span><br><span class="line"></span><br><span class="line">    An element&apos;s length is its number of subelements.  That means if you</span><br><span class="line">    want to check if an element is truly empty, you should check BOTH</span><br><span class="line">    its length AND its text attribute.</span><br><span class="line"></span><br><span class="line">    The element tag, attribute names, and attribute values can be either</span><br><span class="line">    bytes or strings.</span><br><span class="line"></span><br><span class="line">    *tag* is the element name.  *attrib* is an optional dictionary containing</span><br><span class="line">    element attributes. *extra* are additional element attributes given as</span><br><span class="line">    keyword arguments.</span><br><span class="line"></span><br><span class="line">    Example form:</span><br><span class="line">        &lt;tag attrib&gt;text&lt;child/&gt;...&lt;/tag&gt;tail</span><br><span class="line"></span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    当前节点的标签名</span><br><span class="line">    tag = None</span><br><span class="line">    &quot;&quot;&quot;The element&apos;s name.&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    当前节点的属性</span><br><span class="line"></span><br><span class="line">    attrib = None</span><br><span class="line">    &quot;&quot;&quot;Dictionary of the element&apos;s attributes.&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    当前节点的内容</span><br><span class="line">    text = None</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    Text before first subelement. This is either a string or the value None.</span><br><span class="line">    Note that if there is no text, this attribute may be either</span><br><span class="line">    None or the empty string, depending on the parser.</span><br><span class="line"></span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    tail = None</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    Text after this element&apos;s end tag, but before the next sibling element&apos;s</span><br><span class="line">    start tag.  This is either a string or the value None.  Note that if there</span><br><span class="line">    was no text, this attribute may be either None or an empty string,</span><br><span class="line">    depending on the parser.</span><br><span class="line"></span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def __init__(self, tag, attrib=&#123;&#125;, **extra):</span><br><span class="line">        if not isinstance(attrib, dict):</span><br><span class="line">            raise TypeError(&quot;attrib must be dict, not %s&quot; % (</span><br><span class="line">                attrib.__class__.__name__,))</span><br><span class="line">        attrib = attrib.copy()</span><br><span class="line">        attrib.update(extra)</span><br><span class="line">        self.tag = tag</span><br><span class="line">        self.attrib = attrib</span><br><span class="line">        self._children = []</span><br><span class="line"></span><br><span class="line">    def __repr__(self):</span><br><span class="line">        return &quot;&lt;%s %r at %#x&gt;&quot; % (self.__class__.__name__, self.tag, id(self))</span><br><span class="line"></span><br><span class="line">    def makeelement(self, tag, attrib):</span><br><span class="line">        创建一个新节点</span><br><span class="line">        &quot;&quot;&quot;Create a new element with the same type.</span><br><span class="line"></span><br><span class="line">        *tag* is a string containing the element name.</span><br><span class="line">        *attrib* is a dictionary containing the element attributes.</span><br><span class="line"></span><br><span class="line">        Do not call this method, use the SubElement factory function instead.</span><br><span class="line"></span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        return self.__class__(tag, attrib)</span><br><span class="line"></span><br><span class="line">    def copy(self):</span><br><span class="line">        &quot;&quot;&quot;Return copy of current element.</span><br><span class="line"></span><br><span class="line">        This creates a shallow copy. Subelements will be shared with the</span><br><span class="line">        original tree.</span><br><span class="line"></span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        elem = self.makeelement(self.tag, self.attrib)</span><br><span class="line">        elem.text = self.text</span><br><span class="line">        elem.tail = self.tail</span><br><span class="line">        elem[:] = self</span><br><span class="line">        return elem</span><br><span class="line"></span><br><span class="line">    def __len__(self):</span><br><span class="line">        return len(self._children)</span><br><span class="line"></span><br><span class="line">    def __bool__(self):</span><br><span class="line">        warnings.warn(</span><br><span class="line">            &quot;The behavior of this method will change in future versions.  &quot;</span><br><span class="line">            &quot;Use specific &apos;len(elem)&apos; or &apos;elem is not None&apos; test instead.&quot;,</span><br><span class="line">            FutureWarning, stacklevel=2</span><br><span class="line">            )</span><br><span class="line">        return len(self._children) != 0 # emulate old behaviour, for now</span><br><span class="line"></span><br><span class="line">    def __getitem__(self, index):</span><br><span class="line">        return self._children[index]</span><br><span class="line"></span><br><span class="line">    def __setitem__(self, index, element):</span><br><span class="line">        # if isinstance(index, slice):</span><br><span class="line">        #     for elt in element:</span><br><span class="line">        #         assert iselement(elt)</span><br><span class="line">        # else:</span><br><span class="line">        #     assert iselement(element)</span><br><span class="line">        self._children[index] = element</span><br><span class="line"></span><br><span class="line">    def __delitem__(self, index):</span><br><span class="line">        del self._children[index]</span><br><span class="line"></span><br><span class="line">    def append(self, subelement):</span><br><span class="line">        为当前节点追加一个子节点</span><br><span class="line">        &quot;&quot;&quot;Add *subelement* to the end of this element.</span><br><span class="line"></span><br><span class="line">        The new element will appear in document order after the last existing</span><br><span class="line">        subelement (or directly after the text, if it&apos;s the first subelement),</span><br><span class="line">        but before the end tag for this element.</span><br><span class="line"></span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        self._assert_is_element(subelement)</span><br><span class="line">        self._children.append(subelement)</span><br><span class="line"></span><br><span class="line">    def extend(self, elements):</span><br><span class="line">        为当前节点扩展 n 个子节点</span><br><span class="line">        &quot;&quot;&quot;Append subelements from a sequence.</span><br><span class="line"></span><br><span class="line">        *elements* is a sequence with zero or more elements.</span><br><span class="line"></span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        for element in elements:</span><br><span class="line">            self._assert_is_element(element)</span><br><span class="line">        self._children.extend(elements)</span><br><span class="line"></span><br><span class="line">    def insert(self, index, subelement):</span><br><span class="line">        在当前节点的子节点中插入某个节点，即：为当前节点创建子节点，然后插入指定位置</span><br><span class="line">        &quot;&quot;&quot;Insert *subelement* at position *index*.&quot;&quot;&quot;</span><br><span class="line">        self._assert_is_element(subelement)</span><br><span class="line">        self._children.insert(index, subelement)</span><br><span class="line"></span><br><span class="line">    def _assert_is_element(self, e):</span><br><span class="line">        # Need to refer to the actual Python implementation, not the</span><br><span class="line">        # shadowing C implementation.</span><br><span class="line">        if not isinstance(e, _Element_Py):</span><br><span class="line">            raise TypeError(&apos;expected an Element, not %s&apos; % type(e).__name__)</span><br><span class="line"></span><br><span class="line">    def remove(self, subelement):</span><br><span class="line">        在当前节点在子节点中删除某个节点</span><br><span class="line">        &quot;&quot;&quot;Remove matching subelement.</span><br><span class="line"></span><br><span class="line">        Unlike the find methods, this method compares elements based on</span><br><span class="line">        identity, NOT ON tag value or contents.  To remove subelements by</span><br><span class="line">        other means, the easiest way is to use a list comprehension to</span><br><span class="line">        select what elements to keep, and then use slice assignment to update</span><br><span class="line">        the parent element.</span><br><span class="line"></span><br><span class="line">        ValueError is raised if a matching element could not be found.</span><br><span class="line"></span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # assert iselement(element)</span><br><span class="line">        self._children.remove(subelement)</span><br><span class="line"></span><br><span class="line">    def getchildren(self):</span><br><span class="line">        获取所有的子节点（废弃）</span><br><span class="line">        &quot;&quot;&quot;(Deprecated) Return all subelements.</span><br><span class="line"></span><br><span class="line">        Elements are returned in document order.</span><br><span class="line"></span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        warnings.warn(</span><br><span class="line">            &quot;This method will be removed in future versions.  &quot;</span><br><span class="line">            &quot;Use &apos;list(elem)&apos; or iteration over elem instead.&quot;,</span><br><span class="line">            DeprecationWarning, stacklevel=2</span><br><span class="line">            )</span><br><span class="line">        return self._children</span><br><span class="line"></span><br><span class="line">    def find(self, path, namespaces=None):</span><br><span class="line">        获取第一个寻找到的子节点</span><br><span class="line">        &quot;&quot;&quot;Find first matching element by tag name or path.</span><br><span class="line"></span><br><span class="line">        *path* is a string having either an element tag or an XPath,</span><br><span class="line">        *namespaces* is an optional mapping from namespace prefix to full name.</span><br><span class="line"></span><br><span class="line">        Return the first matching element, or None if no element was found.</span><br><span class="line"></span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        return ElementPath.find(self, path, namespaces)</span><br><span class="line"></span><br><span class="line">    def findtext(self, path, default=None, namespaces=None):</span><br><span class="line">        获取第一个寻找到的子节点的内容</span><br><span class="line">        &quot;&quot;&quot;Find text for first matching element by tag name or path.</span><br><span class="line"></span><br><span class="line">        *path* is a string having either an element tag or an XPath,</span><br><span class="line">        *default* is the value to return if the element was not found,</span><br><span class="line">        *namespaces* is an optional mapping from namespace prefix to full name.</span><br><span class="line"></span><br><span class="line">        Return text content of first matching element, or default value if</span><br><span class="line">        none was found.  Note that if an element is found having no text</span><br><span class="line">        content, the empty string is returned.</span><br><span class="line"></span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        return ElementPath.findtext(self, path, default, namespaces)</span><br><span class="line"></span><br><span class="line">    def findall(self, path, namespaces=None):</span><br><span class="line">        获取所有的子节点</span><br><span class="line">        &quot;&quot;&quot;Find all matching subelements by tag name or path.</span><br><span class="line"></span><br><span class="line">        *path* is a string having either an element tag or an XPath,</span><br><span class="line">        *namespaces* is an optional mapping from namespace prefix to full name.</span><br><span class="line"></span><br><span class="line">        Returns list containing all matching elements in document order.</span><br><span class="line"></span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        return ElementPath.findall(self, path, namespaces)</span><br><span class="line"></span><br><span class="line">    def iterfind(self, path, namespaces=None):</span><br><span class="line">        获取所有指定的节点，并创建一个迭代器（可以被for循环）</span><br><span class="line">        &quot;&quot;&quot;Find all matching subelements by tag name or path.</span><br><span class="line"></span><br><span class="line">        *path* is a string having either an element tag or an XPath,</span><br><span class="line">        *namespaces* is an optional mapping from namespace prefix to full name.</span><br><span class="line"></span><br><span class="line">        Return an iterable yielding all matching elements in document order.</span><br><span class="line"></span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        return ElementPath.iterfind(self, path, namespaces)</span><br><span class="line"></span><br><span class="line">    def clear(self):</span><br><span class="line">        清空节点</span><br><span class="line">        &quot;&quot;&quot;Reset element.</span><br><span class="line"></span><br><span class="line">        This function removes all subelements, clears all attributes, and sets</span><br><span class="line">        the text and tail attributes to None.</span><br><span class="line"></span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        self.attrib.clear()</span><br><span class="line">        self._children = []</span><br><span class="line">        self.text = self.tail = None</span><br><span class="line"></span><br><span class="line">    def get(self, key, default=None):</span><br><span class="line">        获取当前节点的属性值</span><br><span class="line">        &quot;&quot;&quot;Get element attribute.</span><br><span class="line"></span><br><span class="line">        Equivalent to attrib.get, but some implementations may handle this a</span><br><span class="line">        bit more efficiently.  *key* is what attribute to look for, and</span><br><span class="line">        *default* is what to return if the attribute was not found.</span><br><span class="line"></span><br><span class="line">        Returns a string containing the attribute value, or the default if</span><br><span class="line">        attribute was not found.</span><br><span class="line"></span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        return self.attrib.get(key, default)</span><br><span class="line"></span><br><span class="line">    def set(self, key, value):</span><br><span class="line">        为当前节点设置属性值</span><br><span class="line">        &quot;&quot;&quot;Set element attribute.</span><br><span class="line"></span><br><span class="line">        Equivalent to attrib[key] = value, but some implementations may handle</span><br><span class="line">        this a bit more efficiently.  *key* is what attribute to set, and</span><br><span class="line">        *value* is the attribute value to set it to.</span><br><span class="line"></span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        self.attrib[key] = value</span><br><span class="line"></span><br><span class="line">    def keys(self):</span><br><span class="line">        获取当前节点的所有属性的 key</span><br><span class="line"></span><br><span class="line">        &quot;&quot;&quot;Get list of attribute names.</span><br><span class="line"></span><br><span class="line">        Names are returned in an arbitrary order, just like an ordinary</span><br><span class="line">        Python dict.  Equivalent to attrib.keys()</span><br><span class="line"></span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        return self.attrib.keys()</span><br><span class="line"></span><br><span class="line">    def items(self):</span><br><span class="line">        获取当前节点的所有属性值，每个属性都是一个键值对</span><br><span class="line">        &quot;&quot;&quot;Get element attributes as a sequence.</span><br><span class="line"></span><br><span class="line">        The attributes are returned in arbitrary order.  Equivalent to</span><br><span class="line">        attrib.items().</span><br><span class="line"></span><br><span class="line">        Return a list of (name, value) tuples.</span><br><span class="line"></span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        return self.attrib.items()</span><br><span class="line"></span><br><span class="line">    def iter(self, tag=None):</span><br><span class="line">        在当前节点的子孙中根据节点名称寻找所有指定的节点，并返回一个迭代器（可以被for循环）。</span><br><span class="line">        &quot;&quot;&quot;Create tree iterator.</span><br><span class="line"></span><br><span class="line">        The iterator loops over the element and all subelements in document</span><br><span class="line">        order, returning all elements with a matching tag.</span><br><span class="line"></span><br><span class="line">        If the tree structure is modified during iteration, new or removed</span><br><span class="line">        elements may or may not be included.  To get a stable set, use the</span><br><span class="line">        list() function on the iterator, and loop over the resulting list.</span><br><span class="line"></span><br><span class="line">        *tag* is what tags to look for (default is to return all elements)</span><br><span class="line"></span><br><span class="line">        Return an iterator containing all the matching elements.</span><br><span class="line"></span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if tag == &quot;*&quot;:</span><br><span class="line">            tag = None</span><br><span class="line">        if tag is None or self.tag == tag:</span><br><span class="line">            yield self</span><br><span class="line">        for e in self._children:</span><br><span class="line">            yield from e.iter(tag)</span><br><span class="line"></span><br><span class="line">    # compatibility</span><br><span class="line">    def getiterator(self, tag=None):</span><br><span class="line">        # Change for a DeprecationWarning in 1.4</span><br><span class="line">        warnings.warn(</span><br><span class="line">            &quot;This method will be removed in future versions.  &quot;</span><br><span class="line">            &quot;Use &apos;elem.iter()&apos; or &apos;list(elem.iter())&apos; instead.&quot;,</span><br><span class="line">            PendingDeprecationWarning, stacklevel=2</span><br><span class="line">        )</span><br><span class="line">        return list(self.iter(tag))</span><br><span class="line"></span><br><span class="line">    def itertext(self):</span><br><span class="line">        在当前节点的子孙中根据节点名称寻找所有指定的节点的内容，并返回一个迭代器（可以被for循环）。</span><br><span class="line">        &quot;&quot;&quot;Create text iterator.</span><br><span class="line"></span><br><span class="line">        The iterator loops over the element and all subelements in document</span><br><span class="line">        order, returning all inner text.</span><br><span class="line"></span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        tag = self.tag</span><br><span class="line">        if not isinstance(tag, str) and tag is not None:</span><br><span class="line">            return</span><br><span class="line">        if self.text:</span><br><span class="line">            yield self.text</span><br><span class="line">        for e in self:</span><br><span class="line">            yield from e.itertext()</span><br><span class="line">            if e.tail:</span><br><span class="line">                yield e.tail</span><br></pre></td></tr></table></figure><p>#configparser模块<br>configparser用于处理特定格式的文件，本质上是利用open来操作文件,主要用于配置文件分析用的</p><blockquote><p>配置文件如下</p></blockquote><pre><code># 注释1; 注释2[section1]k1 = v1k2:v2user=egonage=18is_admin=truesalary=31[section2]k1 = v1</code></pre><h2 id="读-写-改-查"><a href="#读-写-改-查" class="headerlink" title="读 写 改 查"></a>读 写 改 查</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">读取</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">import configparser</span><br><span class="line"> </span><br><span class="line">config=configparser.ConfigParser()</span><br><span class="line">config.read(&apos;a.cfg&apos;)</span><br><span class="line"> </span><br><span class="line">#查看所有的标题</span><br><span class="line">res=config.sections() #[&apos;section1&apos;, &apos;section2&apos;]</span><br><span class="line">print(res)</span><br><span class="line"> </span><br><span class="line">#查看标题section1下所有key=value的key</span><br><span class="line">options=config.options(&apos;section1&apos;)</span><br><span class="line">print(options) #[&apos;k1&apos;, &apos;k2&apos;, &apos;user&apos;, &apos;age&apos;, &apos;is_admin&apos;, &apos;salary&apos;]</span><br><span class="line"> </span><br><span class="line">#查看标题section1下所有key=value的(key,value)格式</span><br><span class="line">item_list=config.items(&apos;section1&apos;)</span><br><span class="line">print(item_list) #[(&apos;k1&apos;, &apos;v1&apos;), (&apos;k2&apos;, &apos;v2&apos;), (&apos;user&apos;, &apos;egon&apos;), (&apos;age&apos;, &apos;18&apos;), (&apos;is_admin&apos;, &apos;true&apos;), (&apos;salary&apos;, &apos;31&apos;)]</span><br><span class="line"> </span><br><span class="line">#查看标题section1下user的值=&gt;字符串格式</span><br><span class="line">val=config.get(&apos;section1&apos;,&apos;user&apos;)</span><br><span class="line">print(val) #egon</span><br><span class="line"> </span><br><span class="line">#查看标题section1下age的值=&gt;整数格式</span><br><span class="line">val1=config.getint(&apos;section1&apos;,&apos;age&apos;)</span><br><span class="line">print(val1) #18</span><br><span class="line"> </span><br><span class="line">#查看标题section1下is_admin的值=&gt;布尔值格式</span><br><span class="line">val2=config.getboolean(&apos;section1&apos;,&apos;is_admin&apos;)</span><br><span class="line">print(val2) #True</span><br><span class="line"> </span><br><span class="line">#查看标题section1下salary的值=&gt;浮点型格式</span><br><span class="line">val3=config.getfloat(&apos;section1&apos;,&apos;salary&apos;)</span><br><span class="line">print(val3) #31.0</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">改写</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">import configparser</span><br><span class="line"> </span><br><span class="line">config=configparser.ConfigParser()</span><br><span class="line">config.read(&apos;a.cfg&apos;,encoding=&apos;utf-8&apos;)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">#删除整个标题section2</span><br><span class="line">config.remove_section(&apos;section2&apos;)</span><br><span class="line"> </span><br><span class="line">#删除标题section1下的某个k1和k2</span><br><span class="line">config.remove_option(&apos;section1&apos;,&apos;k1&apos;)</span><br><span class="line">config.remove_option(&apos;section1&apos;,&apos;k2&apos;)</span><br><span class="line"> </span><br><span class="line">#判断是否存在某个标题</span><br><span class="line">print(config.has_section(&apos;section1&apos;))</span><br><span class="line"> </span><br><span class="line">#判断标题section1下是否有user</span><br><span class="line">print(config.has_option(&apos;section1&apos;,&apos;&apos;))</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">#添加一个标题</span><br><span class="line">config.add_section(&apos;egon&apos;)</span><br><span class="line"> </span><br><span class="line">#在标题egon下添加name=egon,age=18的配置</span><br><span class="line">config.set(&apos;egon&apos;,&apos;name&apos;,&apos;egon&apos;)</span><br><span class="line"># config.set(&apos;egon&apos;,&apos;age&apos;,18) #报错,必须是字符串</span><br><span class="line"> </span><br><span class="line">#最后将修改的内容写入文件,完成最终的修改</span><br><span class="line">config.write(open(&apos;a.cfg&apos;,&apos;w&apos;))</span><br></pre></td></tr></table></figure><h1 id="hashlib"><a href="#hashlib" class="headerlink" title="hashlib"></a>hashlib</h1><p>hash是一种算法（3.x里代替了md5模块和sha模块，主要提供 SHA1, SHA224, SHA256, SHA384, SHA512 ，MD5 算法），该算法接受传入的内容，经过运算得到一串hash值</p><h2 id="hash值的特点是"><a href="#hash值的特点是" class="headerlink" title="hash值的特点是"></a>hash值的特点是</h2><pre><code>只要传入的内容一样，得到的hash值必然一样不能由hash值返解成内容，不应该在网络传输明文密码只要使用的hash算法不变，无论校验的内容有多大，得到的hash值长度是固定</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&apos;&apos;&apos;</span><br><span class="line">注意：把一段很长的数据update多次，与一次update这段长数据，得到的结果一样</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">import hashlib</span><br><span class="line">m = hashlib.md5()  # m=hashlib.sha256()</span><br><span class="line">m.update(&apos;hello&apos;.encode(&apos;utf8&apos;))</span><br><span class="line">print(m.hexdigest())  # 5d41402abc4b2a76b9719d911017c592</span><br><span class="line">m.update(&apos;world&apos;.encode(&apos;utf8&apos;))</span><br><span class="line">print(m.hexdigest())  # fc5e038d38a57032085441e7fe7010b0</span><br><span class="line">m2 = hashlib.md5()</span><br><span class="line">m2.update(&apos;helloworld&apos;.encode(&apos;utf8&apos;))</span><br><span class="line">print(m2.hexdigest())  # fc5e038d38a57032085441e7fe7010b0</span><br></pre></td></tr></table></figure><h2 id="添加自定义key-加盐"><a href="#添加自定义key-加盐" class="headerlink" title="添加自定义key(加盐)"></a>添加自定义key(加盐)</h2><p>以上加密算法虽然依然非常厉害，但时候存在缺陷，即：通过撞库可以反解。所以，有必要对加密算法中添加自定义key再来做加密。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">对加密算法中添加自定义key再来做加密</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">import hashlib</span><br><span class="line">hash = hashlib.sha256(&apos;898oaFs09f&apos;.encode(&apos;utf8&apos;))</span><br><span class="line">hash.update(&apos;alvin&apos;.encode(&apos;utf8&apos;))</span><br><span class="line">print(hash.hexdigest())  # e79e68f070cdedcfe63eaf1a2e92c83b4cfb1b5c6bc452d214c1b7e77cdfd1c7</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">模拟撞库破解密码</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">import hashlib</span><br><span class="line">passwds=[</span><br><span class="line">    &apos;tom3714&apos;,</span><br><span class="line">    &apos;tom1313&apos;,</span><br><span class="line">    &apos;tom94139413&apos;,</span><br><span class="line">    &apos;tom123456&apos;,</span><br><span class="line">    &apos;1234567890&apos;,</span><br><span class="line">    &apos;a123sdsdsa&apos;,</span><br><span class="line">    ]</span><br><span class="line">def make_passwd_dic(passwds):</span><br><span class="line">    dic=&#123;&#125;</span><br><span class="line">    for passwd in passwds:</span><br><span class="line">        m=hashlib.md5()</span><br><span class="line">        m.update(passwd.encode(&apos;utf-8&apos;))</span><br><span class="line">        dic[passwd]=m.hexdigest()</span><br><span class="line">    return dic</span><br><span class="line"> </span><br><span class="line">def break_code(cryptograph,passwd_dic):</span><br><span class="line">    for k,v in passwd_dic.items():</span><br><span class="line">        if v == cryptograph:</span><br><span class="line">            print(&apos;密码是===&gt;\033[46m%s\033[0m&apos; %k)</span><br><span class="line"> </span><br><span class="line">cryptograph=&apos;f19b50d5e3433e65e6879d0e66632664&apos;</span><br><span class="line">break_code(cryptograph,make_passwd_dic(passwds))</span><br></pre></td></tr></table></figure><p>suprocess模块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import  subprocess</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">Linux下:</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"># obj = subprocess.Popen(&apos;ls&apos;, shell=True,</span><br><span class="line">#                        stdout=subprocess.PIPE,</span><br><span class="line">#                        stderr=subprocess.PIPE)</span><br><span class="line"># stdout = obj.stdout.read()</span><br><span class="line"># stderr = obj.stderr.read()</span><br><span class="line">#</span><br><span class="line"># #=========================</span><br><span class="line"># res1=subprocess.Popen(&apos;ls&apos;,shell=True,stdout=subprocess.PIPE)</span><br><span class="line"># res=subprocess.Popen(&apos;grep txt$&apos;,shell=True,stdin=res1.stdout,</span><br><span class="line">#                  stdout=subprocess.PIPE)</span><br><span class="line"># print(res.stdout.read().decode(&apos;utf-8&apos;))</span><br><span class="line">#</span><br><span class="line"># #等同于上面,但是上面的优势在于,一个数据流可以和另外一个数据流交互,可以通过爬虫得到结果然后交给grep</span><br><span class="line"># res1=subprocess.Popen(&apos;ls |grep txt$&apos;,shell=True,stdout=subprocess.PIPE)</span><br><span class="line"># print(res1.stdout.read().decode(&apos;utf-8&apos;))</span><br><span class="line">a = subprocess.Popen(&apos;for i in $(seq 1 100);do sleep 1;echo $i &gt;&gt;/tmp/sleep.log;done&apos;,shell=True,stdout=subprocess.</span><br><span class="line">a.pid</span><br><span class="line">a.terminate()</span><br><span class="line">a.kill()</span><br><span class="line">a.communicate(b&apos;5&apos;)</span><br><span class="line">a.stdout</span><br><span class="line">a.stdout.read()</span><br><span class="line">a.send_signal(signal.SIGKILL)</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">windows下:</span><br><span class="line"># dir | findstr &apos;App*&apos;</span><br><span class="line"># dir | findstr &apos;App$&apos;</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">#Popen发起一个新进程</span><br><span class="line">import subprocess</span><br><span class="line">res1=subprocess.Popen(r&apos;dir C:\Windows&apos;,shell=True,stdout=subprocess.PIPE)</span><br><span class="line">res=subprocess.Popen(&apos;findstr App*&apos;,shell=True,stdin=res1.stdout,</span><br><span class="line">                 stdout=subprocess.PIPE)</span><br><span class="line"> </span><br><span class="line">print(res.stdout.read().decode(&apos;gbk&apos;)) #subprocess使用当前系统默认编码，得到结果为bytes类型，在windows下需要用gbk解码</span><br></pre></td></tr></table></figure></p><h1 id="logging模块"><a href="#logging模块" class="headerlink" title="logging模块"></a>logging模块</h1><p>Python的logging模块提供了通用的日志系统，可以方便第三方模块或者是应用使用。这个模块提供不同的日志级别，并可以采用不同的方式记录日志，比如文件，HTTP GET/POST，SMTP，Socket等，甚至可以自己实现具体的日志记录方式<br>logging模块可帮助更容易的记录日志。logging的日志可以分为debug(),info(),warning(),error()和crictical()5个级别。</p><h2 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h2><table><thead><tr><th>级别</th><th>数值</th><th>使用</th></tr></thead><tbody><tr><td>CRITICAL</td><td>50</td><td>严重错误，表示程序不能继续运行 FATAL=CRITICAL</td></tr><tr><td>ERROR</td><td>40</td><td>错误，表示程序不能运行某一个功能</td></tr><tr><td>WARNING</td><td>30</td><td>报警，表示程序出现意外情况，或者未来的问题。 软件仍然继续正常运行,WARN = WARNING</td></tr><tr><td>INFO</td><td>20</td><td>表示程序正常运行</td></tr><tr><td>DEBUG</td><td>10</td><td>详细信息，主要用于诊断问题</td></tr><tr><td>NOTSET</td><td>0</td></tr></tbody></table><ul><li>简单用法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import logging</span><br><span class="line">logging.basicConfig(filename=&apos;log_test.log&apos;,</span><br><span class="line">level=logging.DEBUG,</span><br><span class="line">format=&apos;%(asctime)s %(message)s&apos;,</span><br><span class="line">datefmt=&apos;%m/%d/%Y %I:%M:%S %p&apos;)</span><br><span class="line">logging.debug(&apos;DEBUG: This message should go to the log file&apos;)</span><br><span class="line">logging.warning(&quot;WARNING: user [david] tried to log in&quot;)</span><br><span class="line">logging.critical(&quot;CRITICAL: server is down&quot;)</span><br></pre></td></tr></table></figure></li></ul><h2 id="logging模块定义的格式字符串字段"><a href="#logging模块定义的格式字符串字段" class="headerlink" title="logging模块定义的格式字符串字段"></a>logging模块定义的格式字符串字段</h2><table><thead><tr><th>字段/属性名称</th><th>使用格式</th><th>描述</th></tr></thead><tbody><tr><td>asctime</td><td>%(asctime)s</td><td>日志事件发生的时间–人类可读时间，如：2003-07-08 16:49:45,896</td></tr><tr><td>created</td><td>%(created)f</td><td>日志事件发生的时间–时间戳，就是当时调用time.time()函数返回的值</td></tr><tr><td>relativeCreated</td><td>%(relativeCreated)d</td><td>日志事件发生的时间相对于logging模块加载时间的相对毫秒数</td></tr><tr><td>msecs</td><td>%(msecs)d</td><td>日志事件发生事件的毫秒部分</td></tr><tr><td>levelname</td><td>%(levelname)s</td><td>该日志记录的文字形式的日志级别（’DEBUG’, ‘INFO’, ‘WARNING’, ‘ERROR’, ‘CRITICAL’）</td></tr><tr><td>levelno</td><td>%(levelno)s</td><td>志记录的数字形式的日志级别（10, 20, 30, 40, 50）</td></tr><tr><td>name</td><td>%(name)s</td><td>所使用的日志器名称，默认是’root’，因为默认使用的是 rootLogger</td></tr><tr><td>message</td><td>%(message)s</td><td>日志记录的文本内容，通过 msg % args计算得到的</td></tr><tr><td>pathname</td><td>%(pathname)s</td><td>调用日志记录函数的源码文件的全路径</td></tr><tr><td>filename</td><td>%(filename)s</td><td>pathname的文件名部分，包含文件后缀</td></tr><tr><td>module</td><td>%(module)s</td><td>filename的名称部分，不包含后缀</td></tr><tr><td>lineno</td><td>%(lineno)d</td><td>调用日志记录函数的源代码所在的行号</td></tr><tr><td>funcName</td><td>%(funcName)s</td><td>调用日志记录函数的函数名</td></tr><tr><td>process</td><td>%(process)d</td><td>进程ID</td></tr><tr><td>processName</td><td>%(processName)s</td><td>进程名称，Python 3.1新增</td></tr><tr><td>thread</td><td>%(thread)d</td><td>线程ID</td></tr><tr><td>threadName</td><td>%(thread)s</td><td>线程名称</td></tr></tbody></table><p>#日志同时输出到屏幕和文件<br>如果同时把log打印在屏幕和文件，Python使用logging模块记录日志设计四个主要类，使用官方文档中的概括：</p><blockquote><p>logger提供了应用程序可以直接调用的接口。与调用logging是相同的<br>handler将（logger创建的）日志记录发送到合适的目的输出.一个handler对象只能绑定一个formatter对象，若执行多次setFormatter方法，则之前的 绑定都会被覆盖。<br>filter输出哪条日志记录，哪条不输出<br>formater决定了日志的记录的最终输出格式<br>logger对象可以绑定handler和filter，也可以进行添加和删除操作。</p></blockquote><img src="/2019/03/21/python-常用模块/logging.png"><h2 id="每个组件的主要功能"><a href="#每个组件的主要功能" class="headerlink" title="每个组件的主要功能"></a>每个组件的主要功能</h2><h3 id="logger"><a href="#logger" class="headerlink" title="logger"></a>logger</h3><p>可以绑定handler和filters<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Logger.setLevel(lev) #指定最低的日志级别</span><br><span class="line">Logger.addFilter(filt)、Logger.removeFilter(filt) #添加或删除指定的filter</span><br><span class="line">Logger.addHandler(hdlr)、Logger.removeHandler(hdlr) #添加或删除指定的handler</span><br></pre></td></tr></table></figure></p><blockquote><p>Logger.debug()、Logger.info()、Logger.warning()、Logger.error()、Logger.critical()可设置日志级别</p></blockquote><h3 id="handler"><a href="#handler" class="headerlink" title="handler"></a>handler</h3><p>handler负责发送相关的信息到指定的目的。如控制台、文件或网络上。还可以编写自己的Handler，通过addHandler()添加多个handler<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Handler.setLevel(lev) #低于lev级别的信息将被忽略</span><br><span class="line">Handler.setFormatter() #屏幕输出格式</span><br><span class="line">Handler.addFilter(filt)、Handler.remove(filt)</span><br></pre></td></tr></table></figure></p><ul><li>logging.StreamHandler</li><li>logging.handlers.RotatingFileHandler</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import logging</span><br><span class="line"># 1.生成 logger 对象</span><br><span class="line">logger = logging.getLogger（&quot;mylog&quot;)</span><br><span class="line"># 2.生成 handler 对象</span><br><span class="line">ch = logging.StreamHandler()</span><br><span class="line">fh = logging.FileHandler()</span><br><span class="line"># 3.把handler对象绑定到logger</span><br><span class="line">logger.addHandler(ch)</span><br><span class="line">logger.addHandler(fh)</span><br><span class="line"># 4. 生成formatter对象</span><br><span class="line">file_f = logging.Formatter(&apos;%(ascctime)s - %(name)s&apos;)</span><br><span class="line">console_f = logging.Formatter(&apos;%(asctime)s - %(levelname)s&apos;)</span><br><span class="line">ch.setFormater(console_f)</span><br><span class="line">fh.setFormater(file_f)</span><br><span class="line">logger.debug(&quot;test log&quot;) #不设置日志级别，默认为warning</span><br><span class="line">logger.info(&quot;test log&quot;)</span><br><span class="line"></span><br><span class="line"># 2.</span><br></pre></td></tr></table></figure><h3 id="为logging模块指定全局配置，针对所有logger有效，控制打印到文件中"><a href="#为logging模块指定全局配置，针对所有logger有效，控制打印到文件中" class="headerlink" title="为logging模块指定全局配置，针对所有logger有效，控制打印到文件中"></a>为logging模块指定全局配置，针对所有logger有效，控制打印到文件中</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import logging</span><br><span class="line">logging.basicConfig(filename=&apos;access.log&apos;,</span><br><span class="line">                    format=&apos;%(asctime)s - %(name)s - %(levelname)s -%(module)s:  %(message)s&apos;,</span><br><span class="line">                    datefmt=&apos;%Y-%m-%d %H:%M:%S %p&apos;,</span><br><span class="line">                    level=10)</span><br><span class="line"> </span><br><span class="line">logging.debug(&apos;调试debug&apos;)</span><br><span class="line">logging.info(&apos;消息info&apos;)</span><br><span class="line">logging.warning(&apos;警告warn&apos;)</span><br><span class="line">logging.error(&apos;错误error&apos;)</span><br><span class="line">logging.critical(&apos;严重critical&apos;)</span><br></pre></td></tr></table></figure><h3 id="Logger与Handler的级别-logger是第一级过滤，然后才能到handler"><a href="#Logger与Handler的级别-logger是第一级过滤，然后才能到handler" class="headerlink" title="Logger与Handler的级别(logger是第一级过滤，然后才能到handler)"></a>Logger与Handler的级别(logger是第一级过滤，然后才能到handler)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import logging</span><br><span class="line">form=logging.Formatter(&apos;%(asctime)s - %(name)s - %(levelname)s -%(module)s:  %(message)s&apos;,</span><br><span class="line">                    datefmt=&apos;%Y-%m-%d %H:%M:%S %p&apos;,)</span><br><span class="line"> </span><br><span class="line">ch=logging.StreamHandler()</span><br><span class="line">ch.setFormatter(form)</span><br><span class="line"># ch.setLevel(10)</span><br><span class="line">ch.setLevel(20)</span><br><span class="line"> </span><br><span class="line">log1=logging.getLogger(&apos;root&apos;)</span><br><span class="line"># log1.setLevel(20)</span><br><span class="line">log1.setLevel(40)</span><br><span class="line">log1.addHandler(ch)</span><br><span class="line"> </span><br><span class="line">log1.debug(&apos;log1 debug&apos;)</span><br><span class="line">log1.info(&apos;log1 info&apos;)</span><br><span class="line">log1.warning(&apos;log1 warning&apos;)</span><br><span class="line">log1.error(&apos;log1 error&apos;)</span><br><span class="line">log1.critical(&apos;log1 critical&apos;)</span><br></pre></td></tr></table></figure><h3 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#core/logger.py</span><br><span class="line">import os</span><br><span class="line">import logging</span><br><span class="line">from conf import settings</span><br><span class="line"> </span><br><span class="line">def logger(log_type):</span><br><span class="line"> </span><br><span class="line">    logger = logging.getLogger(log_type)</span><br><span class="line">    logger.setLevel(settings.LOG_LEVEL)</span><br><span class="line"> </span><br><span class="line">    ch = logging.StreamHandler()  #屏幕</span><br><span class="line">    ch.setLevel(settings.LOG_LEVEL)</span><br><span class="line"> </span><br><span class="line">    log_dir = &quot;%s/log&quot; % (settings.BASE_DIR)</span><br><span class="line">    if not os.path.exists(log_dir):</span><br><span class="line">        os.makedirs(log_dir)</span><br><span class="line">    log_file = &quot;%s/log/%s&quot; %(settings.BASE_DIR, settings.LOG_TYPES[log_type])</span><br><span class="line">    fh = logging.FileHandler(log_file)  #文件</span><br><span class="line">    fh.setLevel(settings.LOG_LEVEL)</span><br><span class="line"> </span><br><span class="line">    formatter = logging.Formatter(&apos;%(asctime)s - %(name)s - %(levelname)s - %(message)s&apos;)</span><br><span class="line"> </span><br><span class="line">    ch.setFormatter(formatter)</span><br><span class="line">    fh.setFormatter(formatter)</span><br><span class="line"> </span><br><span class="line">    logger.addHandler(ch)</span><br><span class="line">    logger.addHandler(fh)</span><br><span class="line"> </span><br><span class="line">    return logger</span><br><span class="line"> </span><br><span class="line">#core/main.py  调用</span><br><span class="line">from core import logger</span><br><span class="line">trans_logger = logger.logger(&apos;transaction&apos;)</span><br><span class="line">access_logger = logger.logger(&apos;access&apos;)</span><br><span class="line"> </span><br><span class="line">def run():</span><br><span class="line">    trans_logger.debug(&apos;trans_logger debug&apos;)</span><br><span class="line">    trans_logger.info(&apos;trans_logger info&apos;)</span><br><span class="line">    trans_logger.warning(&apos;trans_logger warning&apos;)</span><br><span class="line">    trans_logger.error(&apos;trans_logger error&apos;)</span><br><span class="line">    trans_logger.critical(&apos;trans_logger critical&apos;)</span><br><span class="line"> </span><br><span class="line">    access_logger.debug(&apos;access_logger debug&apos;)</span><br><span class="line">    access_logger.info(&apos;access_logger info&apos;)</span><br><span class="line">    access_logger.warning(&apos;access_logger warning&apos;)</span><br><span class="line">    access_logger.error(&apos;access_logger error&apos;)</span><br><span class="line">    access_logger.critical(&apos;access_logger critical&apos;)</span><br><span class="line">run()</span><br><span class="line"> </span><br><span class="line">#conf/setting.py</span><br><span class="line">import os</span><br><span class="line">import logging</span><br><span class="line">BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))</span><br><span class="line"> </span><br><span class="line">LOG_LEVEL = logging.INFO</span><br><span class="line">LOG_TYPES = &#123;</span><br><span class="line">    &apos;transaction&apos;: &apos;transactions.log&apos;,</span><br><span class="line">    &apos;access&apos;: &apos;access.log&apos;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>全局级别默认为warning，全局设置为漏斗，其它handler级别高于全局设置将不生效 </p></blockquote><h3 id="filter-组件"><a href="#filter-组件" class="headerlink" title="filter 组件"></a>filter 组件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import logging</span><br><span class="line">class BacFilter(logging.Filter):</span><br><span class="line">##忽略带db的日志</span><br><span class="line">def filter(self, record):</span><br><span class="line">return &quot;db&quot; not in record.getMessage()</span><br><span class="line">logger.addFilter(BacFilter())</span><br><span class="line">logger.debug(&quot;test log db&quot;)</span><br></pre></td></tr></table></figure><h3 id="日志的截断"><a href="#日志的截断" class="headerlink" title="日志的截断"></a>日志的截断</h3><blockquote><p>logging.handlers.RotatingFileHandler<br>    管理文件大小，达到一定大小后，另存文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from logging import handlers</span><br><span class="line">f = handlers.RotatingFileHandler(&quot;test.log&quot;, maxBytes=10, backupCount=3)</span><br><span class="line">&gt; logging.handlers.TimeRotatingFileHandler(filename [,when [,interval [,backupCount]]])</span><br><span class="line">管理文件大小，达到一定大小后，另存文件</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>logging.handlers.TimeRotatingFileHandler</p></blockquote><h1 id="re模块"><a href="#re模块" class="headerlink" title="re模块"></a>re模块</h1><h2 id="re的匹配函数"><a href="#re的匹配函数" class="headerlink" title="re的匹配函数"></a>re的匹配函数</h2><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>re.match</td><td>从字符传开头匹配</td></tr><tr><td>re.search</td><td>全局查找，找到第一个返回</td></tr><tr><td>re.findall</td><td>查找所有的匹配，当做列表返回</td></tr><tr><td>re.split</td><td>按数字分割（把数字去掉），[maxsplit = 0]当做列表返回</td></tr><tr><td>re.sub</td><td>匹配字符并替换</td></tr><tr><td>re.fullmatch</td><td>全部匹配 re.fullmatch(‘\w+@\w+.(com&#124;cn&#124;edu)’,<a href="mailto:&#39;david@163.com" target="_blank" rel="noopener">&#39;david@163.com</a>‘)</td></tr><tr><td>re.compile</td><td>匹配字符并替换 pattern = re.compile(‘\w+@\w+.(com&#124;cn&#124;edu)’),pattern.fullmatch(<a href="mailto:&#39;david@163.com" target="_blank" rel="noopener">&#39;david@163.com</a>‘)</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">match_res = re.search(&apos;[0]&apos;,s)</span><br><span class="line">if match_res:</span><br><span class="line">match_res.group()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line">ss = &apos;abcdei23aa45&apos;</span><br><span class="line">re.match(&apos;[0-9]&apos;,ss)</span><br><span class="line">#返回None</span><br><span class="line">re.match(&apos;[0-9]&apos;,ss)</span><br><span class="line">#全局查找，找到就返回</span><br><span class="line">re.search(&apos;[0-9]&apos;,ss)</span><br></pre></td></tr></table></figure><h2 id="常用的匹配"><a href="#常用的匹配" class="headerlink" title="常用的匹配"></a>常用的匹配</h2><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>‘.’</td><td>匹配任意字符</td></tr><tr><td>‘^’</td><td>匹配开头</td></tr><tr><td>‘$’</td><td>匹配结尾</td></tr><tr><td>‘*’</td><td>匹配*前面的字符0次或多次</td></tr><tr><td>‘+’</td><td>匹配+前面的字符1次或多次</td></tr><tr><td>‘?’</td><td>匹配？前面的字符0次或1次</td></tr><tr><td>‘{m}’</td><td>匹配前面的字符m次</td></tr><tr><td>‘{n,m}’</td><td>匹配前面的字符n-m次</td></tr><tr><td>‘[0-9a-z]’</td><td>任意一个字符</td></tr><tr><td>‘&#124;’</td><td>匹配左或右的字符</td></tr><tr><td>‘(…)’</td><td>分组匹配re.search(“(abc){2}a(123</td><td>45).group</td></tr><tr><td>‘\A’</td><td>从字符串开头字符,同^</td></tr><tr><td>‘\Z’</td><td>从字符串开头字符,同$</td></tr><tr><td>‘\d’</td><td>匹配数字0-9</td></tr><tr><td>‘\D’</td><td>匹配非数字</td></tr><tr><td>‘\w’</td><td>匹配[A-Za-z0-9]</td></tr><tr><td>‘\W’</td><td>匹配非[A-Za-z0-9],即特殊字符</td></tr><tr><td>‘\s’</td><td>匹配空白字符，\t,\r,\n</td></tr><tr><td>‘(?P<name>…’</name></td><td>分组匹配，re.search(“(?P<province>[0-9]{4}))</province></td></tr></tbody></table><h2 id="分组匹配"><a href="#分组匹配" class="headerlink" title="分组匹配"></a>分组匹配</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line">re.search(&apos;([a-z]+)([[0-9]+])&apos;,&apos;alex123&apos;).groups</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = &apos;130704200005250613&apos;</span><br><span class="line">res = re.search(&apos;(?P&lt;province&gt;\d&#123;3&#125;)(?P&lt;city&gt;\d&#123;3&#125;)&apos;)</span><br><span class="line">res.groupdict()</span><br></pre></td></tr></table></figure><h3 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h3><p>特殊字符需要转义<br>匹配|, ‘|‘<br>匹配\, ‘\\‘</p><h3 id="Flags标识符"><a href="#Flags标识符" class="headerlink" title="Flags标识符"></a>Flags标识符</h3><blockquote><p>re.I 忽略大小写<br>re.M 多行模式<br>re.S 使用re.S参数以后，正则表达式会将这个字符串作为一个整体，在整体中进行匹配<br>re.X 可以在表达式中写注释<br><code>`re.search(&#39;foo.$&#39;,&#39;foo1\nfoo2\n&#39;,re.M)</code></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;模块&quot;&gt;&lt;a href=&quot;#模块&quot; class=&quot;headerlink&quot; title=&quot;模块&quot;&gt;&lt;/a&gt;模块&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;python中，一个py文件就是一个模块
避免函数名和变量名冲突。提高代码可维护性，可重用
&lt;/code&gt;&lt;/pre&gt;&lt;h1
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
      <category term="模块" scheme="http://yoursite.com/categories/Python/%E6%A8%A1%E5%9D%97/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Ch2" scheme="http://yoursite.com/tags/Ch2/"/>
    
      <category term="常用模块" scheme="http://yoursite.com/tags/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>python 函数</title>
    <link href="http://yoursite.com/2019/03/21/python-%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2019/03/21/python-函数/</id>
    <published>2019-03-21T10:32:36.000Z</published>
    <updated>2019-04-26T01:56:26.372Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实参形参"><a href="#实参形参" class="headerlink" title="实参形参"></a>实参形参</h1><pre><code>形参只在函数内部有效</code></pre><img src="/2019/03/21/python-函数/实参形参.png"><h1 id="默认参数-放在参数后面"><a href="#默认参数-放在参数后面" class="headerlink" title="默认参数(放在参数后面)"></a>默认参数(放在参数后面)</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def hello_world(sex,age, name=&quot;david&quot;):</span><br><span class="line">print(name)</span><br></pre></td></tr></table></figure><h1 id="关键参数（实参输入时，不想按顺序传参，必须放在位置参数后面）"><a href="#关键参数（实参输入时，不想按顺序传参，必须放在位置参数后面）" class="headerlink" title="关键参数（实参输入时，不想按顺序传参，必须放在位置参数后面）"></a>关键参数（实参输入时，不想按顺序传参，必须放在位置参数后面）</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello_world(&apos;m&apos;,age=22)</span><br></pre></td></tr></table></figure><h1 id="非固定参数"><a href="#非固定参数" class="headerlink" title="非固定参数"></a>非固定参数</h1><ul><li><p>打包数据为元组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def send_alert(msg,*args):</span><br><span class="line">for u in args:</span><br><span class="line">print(&apos;send alert to:&apos; u)</span><br><span class="line">send_alert(&apos;cpu&apos;,&apos;alex&apos;)</span><br><span class="line">send_alert(&apos;memory&apos;,&apos;alex&apos;,&apos;david&apos;)</span><br><span class="line">#如果想传列表中的元素，</span><br><span class="line">send_alert(&apos;hard_disk&apos;, *[&apos;alex&apos;,&apos;david&apos;])</span><br></pre></td></tr></table></figure></li><li><p>打包数据为字典(未定义的关键字参数)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def send_alert(msg,*args,**kwargs):</span><br><span class="line">print(name,args,kwargs)</span><br><span class="line">for u in args:</span><br><span class="line">print(&apos;send alert to:&apos; u)</span><br><span class="line">send_alert(&apos;cpu&apos;,&apos;alex&apos;,22,addr=&apos;山东&apos;,num=110)</span><br></pre></td></tr></table></figure></li></ul><h1 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h1><pre><code>return #返回结果，一个函数的终止</code></pre><h1 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h1><pre><code>定义在函数内部的变量函数内部可调用外部变量，不可以修改全局变量</code></pre><h1 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h1><pre><code>一级代码的变量</code></pre><h1 id="函数里修改全局变量"><a href="#函数里修改全局变量" class="headerlink" title="函数里修改全局变量"></a>函数里修改全局变量</h1><pre><code>global name = &quot;change to david&quot;一般不使用global</code></pre><h1 id="嵌套函数"><a href="#嵌套函数" class="headerlink" title="嵌套函数"></a>嵌套函数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def func1():</span><br><span class="line">print(&apos;david&apos;)</span><br><span class="line"></span><br><span class="line">def func2():</span><br><span class="line">print(&apos;eric&apos;)</span><br><span class="line">func2</span><br><span class="line"># 1. func1()</span><br><span class="line"># 函数内部可定义函数</span><br><span class="line"># 函数需要被调用才执行</span><br><span class="line"># 从内到外一级一级找变量</span><br></pre></td></tr></table></figure><h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><pre><code>一个函数就是一个作用域</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def func1():</span><br><span class="line">age = 18</span><br><span class="line">def func2():</span><br><span class="line">print(age)</span><br><span class="line">return func2</span><br><span class="line">#return func2()</span><br><span class="line">val = func1</span><br><span class="line">val()</span><br><span class="line">#函数名可以作为返回值</span><br></pre></td></tr></table></figure><h1 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h1><ul><li>匿名函数的关键字为lambda，冒号前面是行参 冒号后面是返回值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func = lambda x,y:x*y if x &lt; y else x/y# 声明一个匿名函数(最多三元运算),用一次就不用了</span><br><span class="line">data = [i for i in range(10)]</span><br><span class="line">list(map(lambda x:x*x, data))</span><br></pre></td></tr></table></figure></li></ul><h2 id="匿名函数的默认参数"><a href="#匿名函数的默认参数" class="headerlink" title="匿名函数的默认参数"></a>匿名函数的默认参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 匿名函数的默认参数(y=2)</span><br><span class="line">f = lambda x,y=2:x**y</span><br><span class="line">print(f(3))</span><br><span class="line">print(f(2,4))  ##如果传值则默认参数值不生效</span><br></pre></td></tr></table></figure><h2 id="匿名函数的可变参数：-args（可接收多个值）"><a href="#匿名函数的可变参数：-args（可接收多个值）" class="headerlink" title="匿名函数的可变参数： *args（可接收多个值）"></a>匿名函数的可变参数： *args（可接收多个值）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f = lambda *args:sum(args)</span><br><span class="line">print(f(1,2,3,45,6))</span><br></pre></td></tr></table></figure><h2 id="匿名函数的关键字参数：参数为字典"><a href="#匿名函数的关键字参数：参数为字典" class="headerlink" title="匿名函数的关键字参数：参数为字典"></a>匿名函数的关键字参数：参数为字典</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f = lambda **kwargs:kwargs.values()</span><br><span class="line">print(f(name=&apos;fentiao&apos;,age=10))</span><br></pre></td></tr></table></figure><h1 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h1><pre><code>函数作为参数,返回一个函数</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def func(x,y)</span><br><span class="line">return x*y</span><br><span class="line">def calc(x):</span><br><span class="line">#pass</span><br><span class="line">return x</span><br><span class="line">f = cal(func)</span><br><span class="line">print(f(5,9)</span><br></pre></td></tr></table></figure><h1 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h1><pre><code>import syssys.getrecursionlimit()sys.setrecursionlimit(1500)</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def recursion(n):</span><br><span class="line">print(n)</span><br><span class="line">recursion(n+1)</span><br></pre></td></tr></table></figure><pre><code>每执行一次函数，变量压到栈里，栈溢出</code></pre><img src="/2019/03/21/python-函数/函数调用的栈结构.png"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def cal(n):</span><br><span class="line">    v = int(n / 2)</span><br><span class="line">    print(v)</span><br><span class="line">    if v == 0:</span><br><span class="line">        return &quot;done&quot;</span><br><span class="line">    cal(v)</span><br><span class="line">    print(v)</span><br></pre></td></tr></table></figure><pre><code>1. 必须有明确的结束条件2. 进入更深一层递归，问题规模比上一次递归应减少3. 效率不高，会导致溢出</code></pre><h1 id="尾递归优化"><a href="#尾递归优化" class="headerlink" title="尾递归优化"></a>尾递归优化</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def cal1(n):</span><br><span class="line">    #n += 1</span><br><span class="line">    print(n)</span><br><span class="line">    if n &lt; 10:</span><br><span class="line">        return(cal1(n+1)) #返回函数本身，下一层递归跟上一层没有关系</span><br><span class="line">#    print(n)</span><br></pre></td></tr></table></figure><h1 id="内置方法"><a href="#内置方法" class="headerlink" title="内置方法"></a>内置方法</h1><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>abs()</td><td>dict()</td><td>help()</td><td>min()</td><td>setattr()</td></tr><tr><td>all()</td><td>dir()</td><td>hex()</td><td>next()</td><td>slice()</td></tr><tr><td>any()</td><td>divmod()</td><td>id()</td><td>object()</td><td>sorted()</td></tr><tr><td>ascii()</td><td>enumerate()</td><td>input()</td><td>oct()</td><td>staticmethod()</td></tr><tr><td>bin()</td><td>dir()</td><td>hex()</td><td>next()</td><td>slice()</td></tr><tr><td>bool()</td><td>exec()</td><td>isinstance()</td><td>ord()</td><td>sum()</td></tr><tr><td>bytearray()</td><td>filter()</td><td>issubclass()</td><td>pow()</td><td>super()</td></tr><tr><td>bytes()</td><td>float()</td><td>iter()</td><td>print()</td><td>tuple()</td></tr><tr><td>callable()</td><td>format()</td><td>len()</td><td>property()</td><td>type()</td></tr><tr><td>chr()</td><td>frozenset()</td><td>list()</td><td>range()</td><td>vars()</td></tr><tr><td>classmethod()</td><td>getattr()</td><td>locals()</td><td>repr()</td><td>zip()</td></tr><tr><td>compile()</td><td>globals()</td><td>map()</td><td>reversed()</td><td><strong>import</strong>()</td></tr><tr><td>complex()</td><td>hasattr()</td><td>max()</td><td>round()</td><td></td></tr><tr><td>delattr()</td><td>has()</td><td>memoryview()</td><td>set()</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">d= &#123;&#125;</span><br><span class="line">for i in range(20):</span><br><span class="line">d[i] = i-50</span><br><span class="line">d.items()</span><br><span class="line">sorted(d.items(),key = lambda x:x[1])</span><br></pre></td></tr></table></figure><ul><li><p>eval #处理单行代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f = &quot;1+3/2&quot;</span><br><span class="line">eval(f)</span><br></pre></td></tr></table></figure></li><li><p>exec #可执行多行代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code =</span><br></pre></td></tr></table></figure><p>  if x = 20:</p><pre><code>print(x)</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec(code)</span><br></pre></td></tr></table></figure></li><li><p>callable() 判断变量是否是函数</p></li><li>vars()    打印所有变量</li><li>locals()    打印局部变量</li><li>globals()</li><li>repr()    显示为字符串</li></ul><h1 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h1><ul><li>locals：包括局部变量和形参</li><li>globals： 全局变量</li><li>builtin：dir(<strong>builtins</strong>)内置模块的名字空间<br>  局部范围： 临时存活，局部有效<h1 id="作用域-1"><a href="#作用域-1" class="headerlink" title="作用域"></a>作用域</h1></li><li>LEGB 代表名字查找顺序：locals -&gt; enclosing function -&gt; globals -&gt; <strong>builtins</strong><br>  L:    locals是函数内的名字空间，包括局部变量和形参<br>  E:    enclosing 外部嵌套函数的名字空间<br>  G:    globals 全局变量，函数定义所在模块的名字空间<br>  B： builtins 内置模块的名字空间<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1>  内嵌子函数，返回子函数对象，该外层函数优先使用外层函数的作用域，但参数，内部变量并不释放。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def func():</span><br><span class="line"></span><br><span class="line">n = 10</span><br><span class="line">def func2():</span><br><span class="line">print(&quot;func2:&quot;, n)</span><br><span class="line">return func2</span><br><span class="line">f = func()</span><br><span class="line">print(f)</span><br><span class="line">f()</span><br></pre></td></tr></table></figure></li></ul><h1 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h1><pre><code>开放：对现有的功能的扩展开放封闭：对以实现的功能代码块不应该被修改</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">user_status = False</span><br><span class="line">def login():</span><br><span class="line">pass</span><br><span class="line">def home():</span><br><span class="line">print(&quot;首页&quot;)</span><br><span class="line">def america():</span><br><span class="line">login()#更改了函数，违反了“开放-封闭”原则</span><br><span class="line">print(&quot;美国&quot;)</span><br><span class="line">def japan():</span><br><span class="line">print(&quot;---日本---&quot;)</span><br></pre></td></tr></table></figure><pre><code>把要执行的函数作为参数传递</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def login(func):</span><br><span class="line">func()#改变了调用方式</span><br><span class="line">pass</span><br><span class="line">login(america)</span><br></pre></td></tr></table></figure><pre><code>匿名函数</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def login(func):</span><br><span class="line">func()#改变了调用方式</span><br><span class="line">pass</span><br><span class="line">america = login(america)</span><br><span class="line">#用户调用时</span><br><span class="line">america()</span><br><span class="line">#还是会触发执行login</span><br></pre></td></tr></table></figure><pre><code>嵌套函数</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def login(func):</span><br><span class="line">def inner():</span><br><span class="line">pass</span><br><span class="line">return inner</span><br><span class="line">america = login(america) # inner</span><br><span class="line">america()</span><br><span class="line"># 更简单的方法@login</span><br><span class="line">#def home():</span><br><span class="line">#print(&quot;首页&quot;)</span><br><span class="line">#@longin</span><br><span class="line">#def america():</span><br><span class="line">#print(&quot;美国&quot;)</span><br></pre></td></tr></table></figure><ul><li><p>带参数的装饰器(不固定参数)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def login():</span><br><span class="line">def inner(*args,**kwargs):</span><br><span class="line">pass</span><br><span class="line">return inner(*args,*kwargs)</span><br></pre></td></tr></table></figure></li><li><p>login带参数login(auth_type)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def login(auth_type):</span><br><span class="line">def outer(func):</span><br><span class="line">def inner(*args,*kwargs):</span><br><span class="line">pass</span><br><span class="line">return inner(*args,*kwargs)</span><br><span class="line">return outer()</span><br><span class="line">@login(&apos;qq)</span><br><span class="line">def japan():</span><br><span class="line">print(&quot;---日本---&quot;)</span><br></pre></td></tr></table></figure></li><li><p>@wraps()<br>将被装饰函数的<strong>name</strong>以及<strong>doc</strong>等属性绑定到了原函数的上面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from functools import wraps</span><br><span class="line">def wrapper(func):</span><br><span class="line">    print(&quot;this is a wrapper&quot;)</span><br><span class="line">    @wraps(func)</span><br><span class="line">    def inner():</span><br><span class="line">        print(func.__name__)</span><br><span class="line">        return func()</span><br><span class="line">    return inner</span><br><span class="line"></span><br><span class="line">@wrapper</span><br><span class="line">def work():</span><br><span class="line">    return 123</span><br><span class="line"></span><br><span class="line">print(work.__name__) # 显示work，去掉wrap显示inner</span><br><span class="line">work() # 显示work</span><br></pre></td></tr></table></figure></li></ul><h1 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h1><ul><li><p>列表生成式<br>  需求：列表[0, 1, 2, 3, 4, 5],每个值都加1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = [0, 1, 2, 3, 4, 5]</span><br><span class="line">a = [i+1 for i in a]</span><br></pre></td></tr></table></figure></li><li><p>生成器</p><blockquote><p>生成器是一个公式, 可支持复杂的算法</p></blockquote>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a2 = (i for i in range(100))</span><br><span class="line">next(a2)</span><br><span class="line">for i in a2: #不会报错</span><br><span class="line">print(i)</span><br></pre></td></tr></table></figure></li><li><p>Fibonacci<br>  1,1,2,3,5,8,13,21,34,…</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def fib(max):</span><br><span class="line">n, a, b = 0, 0, 1</span><br><span class="line">while n &lt; max:</span><br><span class="line">yield b #把函数执行过程冻结在这一步， 并且把b的值返回</span><br><span class="line">a, b = b, a + b</span><br><span class="line">n = n + 1</span><br><span class="line">return &apos;done&apos;</span><br><span class="line">f = fib(15)</span><br><span class="line">next(f)</span><br><span class="line">for i in f:</span><br><span class="line">print(i)</span><br></pre></td></tr></table></figure><p>  函数有了yield之后，函数就得到了一个生成器<br>  return在生成器中，代表生成器的终止，直接报错</p></li><li>生成器终止<br>  send 唤醒并继续执行，发送一个信息到生成器内部，send(None)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sign = yield count</span><br><span class="line">if sign == &apos;stop&apos;:</span><br><span class="line">break</span><br><span class="line">func.send(&apos;stop&apos;)</span><br></pre></td></tr></table></figure></li></ul><h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><ul><li><p>Iterable<br>  可以直接用于for循环的情形有以下几种<br>  字符串    str<br>  集合数据类型， 如 list、tuple、dict、set<br>  generator，包括生成器和带yield的generator function<br>  这些统称为可迭代对象：Iterable<br>  可以使用isinstance()是否是Iterable对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">form collections import Iterable</span><br><span class="line">isinstance(1,Iterable)</span><br></pre></td></tr></table></figure></li><li><p>Iterator<br>  可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from collections import Iterator</span><br><span class="line">isinstance((x for x in range(10), Iterator)</span><br><span class="line">isinstance([], Iterator)</span><br></pre></td></tr></table></figure></li><li><p>把list、dict、str变成迭代器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iter(&apos;abc&apos;)</span><br></pre></td></tr></table></figure><p>  迭代器是一个数据流，没有终止，不能提前知道序列的长度，是惰性的计算，通过next()计算下一个数据。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;实参形参&quot;&gt;&lt;a href=&quot;#实参形参&quot; class=&quot;headerlink&quot; title=&quot;实参形参&quot;&gt;&lt;/a&gt;实参形参&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;形参只在函数内部有效
&lt;/code&gt;&lt;/pre&gt;&lt;img src=&quot;/2019/03/21/python-函
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
      <category term="函数" scheme="http://yoursite.com/categories/Python/%E5%87%BD%E6%95%B0/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Ch2" scheme="http://yoursite.com/tags/Ch2/"/>
    
      <category term="函数" scheme="http://yoursite.com/tags/%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>你的问题</title>
    <link href="http://yoursite.com/2019/03/21/%E4%BD%A0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/03/21/你的问题/</id>
    <published>2019-03-21T10:32:36.000Z</published>
    <updated>2019-04-24T03:17:34.813Z</updated>
    
    <content type="html"><![CDATA[<h1 id="你的问题是想法太多读书太少"><a href="#你的问题是想法太多读书太少" class="headerlink" title="你的问题是想法太多读书太少"></a>你的问题是想法太多读书太少</h1><h1 id="战术上的勤奋掩盖不了战略上的错误"><a href="#战术上的勤奋掩盖不了战略上的错误" class="headerlink" title="战术上的勤奋掩盖不了战略上的错误"></a>战术上的勤奋掩盖不了战略上的错误</h1><ul><li><p>个人的成长</p></li><li><p>公司的成长</p></li><li><p>反思</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;你的问题是想法太多读书太少&quot;&gt;&lt;a href=&quot;#你的问题是想法太多读书太少&quot; class=&quot;headerlink&quot; title=&quot;你的问题是想法太多读书太少&quot;&gt;&lt;/a&gt;你的问题是想法太多读书太少&lt;/h1&gt;&lt;h1 id=&quot;战术上的勤奋掩盖不了战略上的错误&quot;&gt;&lt;a 
      
    
    </summary>
    
      <category term="人生" scheme="http://yoursite.com/categories/%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="杂谈" scheme="http://yoursite.com/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>python 总结2</title>
    <link href="http://yoursite.com/2019/03/21/python-%E6%80%BB%E7%BB%932/"/>
    <id>http://yoursite.com/2019/03/21/python-总结2/</id>
    <published>2019-03-21T10:32:36.000Z</published>
    <updated>2019-06-05T01:06:54.377Z</updated>
    
    <content type="html"><![CDATA[<h1 id="函数定义方式"><a href="#函数定义方式" class="headerlink" title="函数定义方式"></a>函数定义方式</h1><pre><code>函数名，形参，实参，返回值</code></pre><h1 id="函数调用方式"><a href="#函数调用方式" class="headerlink" title="函数调用方式"></a>函数调用方式</h1><h2 id="第一种：参数按顺序从第一个参数往后排-标准调用"><a href="#第一种：参数按顺序从第一个参数往后排-标准调用" class="headerlink" title="第一种：参数按顺序从第一个参数往后排#标准调用"></a>第一种：参数按顺序从第一个参数往后排#标准调用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: UTF-8 -*-  </span><br><span class="line">def normal_invoke(x, y):  </span><br><span class="line">    print &quot;--normal_invoke:--&quot;  </span><br><span class="line">    print &quot;x is %d&quot; %x  </span><br><span class="line">    print &quot;y is %d&quot; %y </span><br><span class="line">#标准调用  </span><br><span class="line">normal_invoke(1, 2)</span><br></pre></td></tr></table></figure><h2 id="第二种：-关键字调用"><a href="#第二种：-关键字调用" class="headerlink" title="第二种：#关键字调用"></a>第二种：#关键字调用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def keyword_invoke(x, y):  </span><br><span class="line">    print &quot;--keyword_invoke--:&quot;  </span><br><span class="line">    print &quot;x is %d&quot; % x  </span><br><span class="line">    print &quot;y is %d&quot; % y </span><br><span class="line"></span><br><span class="line">#关键字调用  </span><br><span class="line">keyword_invoke(y=1, x=2) </span><br><span class="line">注意：关键调用从哪开始的，从哪以后都必须使用关键字调用除了‘*’收集参数。不能写成这样的：keyword_invoke(y=1, 2)，这样就会报错。</span><br></pre></td></tr></table></figure><h2 id="第三种：-非关键字可变长参数-tuple"><a href="#第三种：-非关键字可变长参数-tuple" class="headerlink" title="第三种：#非关键字可变长参数(tuple)"></a>第三种：#非关键字可变长参数(tuple)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def normal_tuple_invoke(x, y=2, *values):  </span><br><span class="line">print &quot;--normal_tuple_invoke--&quot;  </span><br><span class="line">print &quot;x is %d&quot; % x  </span><br><span class="line">print &quot;y is %d&quot; % y  </span><br><span class="line">for value in values:  </span><br><span class="line">print &quot;tuple&apos;s value has&quot;, value</span><br><span class="line">#非关键字可变长参数(tuple)  </span><br><span class="line">　normal_tuple_invoke(1, 3, &apos;xyz&apos;, 123.4)</span><br></pre></td></tr></table></figure><h2 id="第四种：-关键字可变长参数-dict"><a href="#第四种：-关键字可变长参数-dict" class="headerlink" title="第四种：#关键字可变长参数(dict)"></a>第四种：#关键字可变长参数(dict)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def keyword_dict_invoke(x, y=2, **value_dict):  </span><br><span class="line">    print &quot;--keyword_dict_invoke--&quot;  </span><br><span class="line">    print &quot;x is %d&quot; % x  </span><br><span class="line">    print &quot;y is %d&quot; % y  </span><br><span class="line">    for key in value_dict:  </span><br><span class="line">        print &quot;key is &quot;, key  </span><br><span class="line">        print &quot;value is &quot;, value_dict[key] </span><br><span class="line"></span><br><span class="line">#关键字可变长参数(dict)  </span><br><span class="line">　keyword_dict_invoke(y=1, x=2, arg2=&apos;def&apos;, arg1=&apos;put at the last&apos;)</span><br></pre></td></tr></table></figure><h2 id="第五种：整个函数为参数传回来"><a href="#第五种：整个函数为参数传回来" class="headerlink" title="第五种：整个函数为参数传回来"></a>第五种：整个函数为参数传回来</h2><h1 id="函数参数类型"><a href="#函数参数类型" class="headerlink" title="函数参数类型"></a>函数参数类型</h1><pre><code>函数的参数类型可分为：必须参数、默认参数、可变参数（不定长参数）、关键字参数、组合参数，总共5种。</code></pre><h1 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h1><pre><code>它有一个隐含的 return 语句，返回值是 None，类型也是 &apos;NoneType&apos;。</code></pre><h1 id="函数作用域-LEGB"><a href="#函数作用域-LEGB" class="headerlink" title="函数作用域 LEGB"></a>函数作用域 LEGB</h1><p>Python中变量作用域分4种情况：</p><p>L: local，局部作用域，即函数中定义的变量。<br>E: enclosing,父级函数的局部作用域，即此函数的上级函数的局部作用域。<br>G: globa,全局变量<br>B: build-in,系统模块，如:int,max函数等<br>优先级顺序为：局部作用域(L)&gt;父级函数作用域(E)&gt;全局作用域(G)&gt;系统模块(B)<br>从内到外一级一级找变量</p><h1 id="函数的嵌套"><a href="#函数的嵌套" class="headerlink" title="函数的嵌套"></a>函数的嵌套</h1><p>　　在一个函数中定义了另外一个函数</p><p>def outer():</p><p>　　def inner():</p><p>　　　　print(‘inner’)</p><p>　　print(‘outer’)</p><p>　　inner()<br>outer()</p><h1 id="闭包函数"><a href="#闭包函数" class="headerlink" title="闭包函数"></a>闭包函数</h1><p>　在一个外函数中定义了一个内函数，内函数里运用了外函数的临时变量，并且外函数的返回值是内函数的引用。这样就构成了一个闭包。</p><p>一般情况下，在我们认知当中，如果一个函数结束，函数的内部所有东西都会释放掉，还给内存，局部变量都会消失。但是闭包是一种特殊情况，如果外函数在结束的时候发现有自己的临时变量将来会在内部函数中用到，就把这个临时变量绑定给了内部函数，然后自己再结束。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#闭包函数的实例</span><br><span class="line"># outer是外部函数 a和b都是外函数的临时变量</span><br><span class="line">def outer( a ):</span><br><span class="line">    b = 10</span><br><span class="line">    # inner是内函数</span><br><span class="line">    def inner():</span><br><span class="line">        #在内函数中 用到了外函数的临时变量</span><br><span class="line">        print(a+b)</span><br><span class="line">    # 外函数的返回值是内函数的引用</span><br><span class="line">    return inner</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    # 在这里我们调用外函数传入参数5</span><br><span class="line">    #此时外函数两个临时变量 a是5 b是10 ，并创建了内函数，然后把内函数的引用返回存给了demo</span><br><span class="line">    # 外函数结束的时候发现内部函数将会用到自己的临时变量，这两个临时变量就不会释放，会绑定给这个内部函数</span><br><span class="line">    demo = outer(5)</span><br><span class="line">    # 我们调用内部函数，看一看内部函数是不是能使用外部函数的临时变量</span><br><span class="line">    # demo存了外函数的返回值，也就是inner函数的引用，这里相当于执行inner函数</span><br><span class="line">    demo() # 15</span><br><span class="line"></span><br><span class="line">    demo2 = outer(7)</span><br><span class="line">    demo2()#17</span><br></pre></td></tr></table></figure></p><h1 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h1><p>递归函数就是函数在内部调用自身。</p><p>必须有一个明确的递归结束条件，称为递归出口。</p><p>注意： 切勿忘记递归出口，避免函数无限调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def fact(n):</span><br><span class="line">     if n == 1:</span><br><span class="line">             return 1</span><br><span class="line">    else:</span><br><span class="line">             return  n * fact( n-1 )</span><br></pre></td></tr></table></figure></p><h1 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h1><p>函数本身可以赋值给变量；func = math.sqrt<br>允许将函数本身作为参数传入另一个函数；<br>允许返回一个函数</p><h1 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h1><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><pre><code>map(fun, lst)，将传入的函数变量func作用到lst变量的每个元素中，并将结果组成新的列表返回</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># li = [1,2,3,5,5,6,7,8,9,9,8,3] 利用生成器功能，写一个所有数值乘以2的功能。</span><br><span class="line">list(map(lambda x:x*2,li))</span><br><span class="line">def odd(x):</span><br><span class="line">return x%2 ==1</span><br><span class="line">filter(odd,li)</span><br><span class="line">list(filter(lambda x:x&gt;7,li))</span><br></pre></td></tr></table></figure><h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><pre><code>filter（func, lst），将func作用于lst的每个元素，然后根据返回值是True或False判断是保留还是丢弃该元素。</code></pre><h2 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h2><pre><code>sorted() 函数对所有可迭代的对象进行排序操作。sorted 语法：</code></pre><p>sorted(iterable[, cmp[, key[, reverse]]])</p><p>参数说明：</p><p>iterable – 可迭代对象。<br>cmp – 比较的函数，这个具有两个参数，参数的值都是从可迭代对象中取出，此函数必须遵守的规则为，大于则返回1，小于则返回-1，等于则返回0。<br>key – 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。<br>reverse – 排序规则，reverse = True 降序 ， reverse = False 升序（默认）。</p><p> L=[(‘b’,2),(‘a’,1),(‘c’,3),(‘d’,4)]</p><blockquote><blockquote><blockquote><p>sorted(L, cmp=lambda x,y:cmp(x[1],y[1])) # 利用cmp函数</p></blockquote></blockquote></blockquote><h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h2><pre><code>reduce（func（x,y），lst），其中func必须有两个参数。每次func计算的结果继续和序列的下一个元素做累积计算。</code></pre><h2 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h2><h1 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h1><p>sorted 常用， map reduce 建议用列表推导式<br>lambda函数的语法只包含一个语句，如下：</p><p>lambda [arg1 [,arg2,…..argn]]:expression<br>lambda 表达式与 def 的主要不同点:</p><p>可以立刻传递(无需变量)<br>在内部只能包含一行代码<br>自动返回结果<br>既没有文档字符串, 也没有名称<br>使用了不同且不常见的语法</p><p>如下实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line"> </span><br><span class="line"># 可写函数说明</span><br><span class="line">sum = lambda arg1, arg2: arg1 + arg2;</span><br></pre></td></tr></table></figure></p><h1 id="三元运算"><a href="#三元运算" class="headerlink" title="三元运算"></a>三元运算</h1><p>res = “真大王” if name == “alex” else “假大王”<br>非python： 判断条件（返回布尔值）？为真时的结果：为假时的结果</p><h1 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h1><pre><code>列表推导式，使用一句表达式构造一个新列表，可包含过滤、转换等操作。</code></pre><p>语法：[exp for item in collection if codition]</p><h1 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h1><p>相比列表表达式，只不过将[]换成了()，更加省内存。生成器表达式并不真正的创建数字列表，而是返回一个生成器对象，此对象在每次计算出一个条目后，把这个条目”产生”(yield)出来。生成器表达式使用了”惰性计算”或称作”延时求值”的机制。<br>g=l=(‘egg%s’ %i for i in range(10000))<br>print(next(g))</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#取出单价&gt;10000</span><br><span class="line">with open(&apos;b.txt&apos;) as f:</span><br><span class="line">    res=(line.split() for line in f)</span><br><span class="line">    # print(res)</span><br><span class="line">    dic_g=(&#123;&apos;name&apos;:i[0],&apos;price&apos;:i[1],&apos;count&apos;:i[2]&#125; for i in res if float(i[1]) &gt; 10000)</span><br><span class="line">    print(dic_g)&lt;br&gt;----&gt; &lt;generator object &lt;genexpr&gt; at 0x0000000001E05888&gt;</span><br><span class="line">    print(list(dic_g))&lt;br&gt;----&gt; [&#123;&apos;name&apos;: &apos;tesla&apos;, &apos;price&apos;: &apos;1000000&apos;, &apos;count&apos;: &apos;1&apos;&#125;, &#123;&apos;name&apos;: &apos;lenovo&apos;, &apos;price&apos;: &apos;30000&apos;, &apos;count&apos;: &apos;3&apos;&#125;]</span><br></pre></td></tr></table></figure><h1 id="生成器函数"><a href="#生成器函数" class="headerlink" title="生成器函数"></a>生成器函数</h1><p>当生成器执行到最后时，它就产生一个 StopIteration 异常，然后就停止了，当生成器函数中有return时， 这个异常的值就是return的值，如果没有return，异常的值为空；</p><h2 id="生成器-相关操作"><a href="#生成器-相关操作" class="headerlink" title="生成器 相关操作"></a>生成器 相关操作</h2><h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>一个实现了iter方法的对象时可迭代的，一个实现next方法的对象是迭代器</p><p>可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。</p><p>可以使用isinstance()判断一个对象是否是Iterator对象：</p><blockquote><blockquote><blockquote><p>from collections import Iterator<br>isinstance((x for x in range(10)), Iterator)<br>True<br>isinstance([], Iterator)<br>False<br>isinstance({}, Iterator)<br>False<br>isinstance(‘abc’, Iterator)<br>False　　</p></blockquote></blockquote></blockquote><p>生成器都是Iterator对象，但list、dict、str虽然是Iterable（可迭代对象），却不是Iterator（迭代器）。</p><p>把list、dict、str等Iterable变成Iterator可以使用iter()函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">s=&apos;hello&apos;     #字符串是可迭代对象，但不是迭代器</span><br><span class="line">l=[1,2,3,4]     #列表是可迭代对象，但不是迭代器</span><br><span class="line">t=(1,2,3)       #元组是可迭代对象，但不是迭代器</span><br><span class="line">d=&#123;&apos;a&apos;:1&#125;        #字典是可迭代对象，但不是迭代器</span><br><span class="line">set=&#123;1,2,3&#125;     #集合是可迭代对象，但不是迭代器</span><br><span class="line"># *************************************</span><br><span class="line">f=open(&apos;test.txt&apos;) #文件是可迭代对象，是迭代器</span><br><span class="line"> </span><br><span class="line">#如何判断是可迭代对象，只有__iter__方法，执行该方法得到的迭代器对象。</span><br><span class="line"># 及可迭代对象通过__iter__转成迭代器对象</span><br><span class="line">from collections import Iterator  #迭代器</span><br><span class="line">from collections import Iterable  #可迭代对象</span><br><span class="line"> </span><br><span class="line">print(isinstance(s,Iterator))     #判断是不是迭代器</span><br><span class="line">print(isinstance(s,Iterable))       #判断是不是可迭代对象</span><br><span class="line"> </span><br><span class="line">#把可迭代对象转换为迭代器</span><br></pre></td></tr></table></figure><h1 id="协程函数"><a href="#协程函数" class="headerlink" title="协程函数"></a>协程函数</h1><p>在使用装饰器时，在碰到yield时，停止执行，并返回yield的返回值。协程函数可以对yield的返回值进行赋值，  装饰器使用send()函数。<br>def test(name):<br>    print(‘%s welcome’ %name)<br>    while True:<br>        age=yield<br>        print(‘%s is %s’ %(name,age))</p><p>t=test(‘andy’)</p><h1 id="初始化，必须先进行初始化，否则会报错"><a href="#初始化，必须先进行初始化，否则会报错" class="headerlink" title="初始化，必须先进行初始化，否则会报错"></a>初始化，必须先进行初始化，否则会报错</h1><p>next(t)</p><h1 id="使用send-给yield传值-yield将得到的值赋值给age"><a href="#使用send-给yield传值-yield将得到的值赋值给age" class="headerlink" title="使用send() 给yield传值,yield将得到的值赋值给age"></a>使用send() 给yield传值,yield将得到的值赋值给age</h1><p>print(t.send(‘22’))<br>print(‘=========’)<br>print(t.send(‘33’))</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 首先获得Iterator对象:</span><br><span class="line">it = iter([1, 2, 3, 4, 5])</span><br><span class="line"># 循环:</span><br><span class="line">while True:</span><br><span class="line">    try:</span><br><span class="line">        # 获得下一个值:</span><br><span class="line">        x = next(it)</span><br><span class="line">    except StopIteration:</span><br><span class="line">        # 遇到StopIteration就退出循环</span><br><span class="line">        break</span><br></pre></td></tr></table></figure><h1 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#### 编写装饰器，为每个函数加上统计运行时间的功能</span><br><span class="line">     提示：在函数开始执行时加上start=time.time()就可纪录当前执行的时间戳，函数执行结束后在time.time() - start就可以拿到执行所用时间</span><br><span class="line">import time</span><br><span class="line">def time_decorator(func):</span><br><span class="line">def inner(*args,**kwargs):</span><br><span class="line">start = time.time()</span><br><span class="line">res = func(*args,**kwargs):</span><br><span class="line">end = time.time()</span><br><span class="line">return res</span><br><span class="line">return inner</span><br></pre></td></tr></table></figure><h1 id="常用模块"><a href="#常用模块" class="headerlink" title="常用模块"></a>常用模块</h1><h2 id="time"><a href="#time" class="headerlink" title="time"></a>time</h2><h2 id="datetime"><a href="#datetime" class="headerlink" title="datetime"></a>datetime</h2><h2 id="random"><a href="#random" class="headerlink" title="random"></a>random</h2><h2 id="os"><a href="#os" class="headerlink" title="os"></a>os</h2><h2 id="sys"><a href="#sys" class="headerlink" title="sys"></a>sys</h2><h2 id="json"><a href="#json" class="headerlink" title="json"></a>json</h2><h2 id="pickle"><a href="#pickle" class="headerlink" title="pickle"></a>pickle</h2><h2 id="shelve"><a href="#shelve" class="headerlink" title="shelve"></a>shelve</h2><h2 id="xml"><a href="#xml" class="headerlink" title="xml"></a>xml</h2><h2 id="hashlib"><a href="#hashlib" class="headerlink" title="hashlib"></a>hashlib</h2><h2 id="logging"><a href="#logging" class="headerlink" title="logging"></a>logging</h2><h2 id="re"><a href="#re" class="headerlink" title="re"></a>re</h2><h2 id="shutil"><a href="#shutil" class="headerlink" title="shutil"></a>shutil</h2><p><a href="https://www.cnblogs.com/wj-1314/p/8490822.html" target="_blank" rel="noopener">https://www.cnblogs.com/wj-1314/p/8490822.html</a></p><h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><p>python中的文件对象：<br>文件对象不仅可以用来访问普通的磁盘文件, 而且也可以访问任何其它类型抽象层面上的”文<br>件”. 一旦设置了合适的”钩子”, 你就可以访问具有文件类型接口的其它对象, 就好像访问的是普<br>通文件一样.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">open(&apos;filename&apos;)</span><br><span class="line">with open(&apos;filename&apos;) as f:</span><br><span class="line">         pass</span><br></pre></td></tr></table></figure><p>open函数使用一个文件名作为唯一的强制参数，然后返回一个文件对象。模式和缓冲参数都是可选的，默认为只读模式打开文件。使用with即使发生错误可以关闭文件，<br>下面列出文件对象的访问的模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">文件模式   操作</span><br><span class="line">r  以只读方式打开</span><br><span class="line">rU 或 Ua 以读方式打开, 同时提供通用换行符支持 (PEP 278)</span><br><span class="line">w  以写方式打开 (必要时清空)</span><br><span class="line">a  以追加模式打开 (从 EOF 开始, 必要时创建新文件)</span><br><span class="line">r+ 以读写模式打开</span><br><span class="line">w+ 以读写模式打开 (参见 w )</span><br><span class="line">a+ 以读写模式打开 (参见 a )</span><br><span class="line">rb 以二进制读模式打开</span><br><span class="line">wb 以二进制写模式打开 (参见 w )</span><br><span class="line">ab 以二进制追加模式打开 (参见 a )</span><br><span class="line">rb+ 以二进制读写模式打开 (参见 r+ )</span><br><span class="line">wb+ 以二进制读写模式打开 (参见 w+ )</span><br><span class="line">ab+ 以二进制读写模式打开 (参见 a+ )</span><br><span class="line">x    如果文件存在报错，不存在则创建</span><br><span class="line">***加b模式打开，不可以在指定encoding，切写入时也需要转换为字节写入文件</span><br><span class="line"></span><br><span class="line">下面是一些打开文件的例子:</span><br><span class="line">f = open(&apos;/etc/motd&apos;) # 以读方式打开</span><br><span class="line">f = open(&apos;test&apos;, &apos;w&apos;) # 以写方式打开</span><br><span class="line">f = open(&apos;data&apos;, &apos;r+&apos;) # 以读写方式打开</span><br><span class="line">f = open(&apos;io.sys&apos;, &apos;rb&apos;) # 以二进制读模式打开</span><br><span class="line"></span><br><span class="line">bytes 字符串转换字节类型</span><br><span class="line">n=bytes(李杰,encoding=&apos;utf-8&apos;)[转换的字符，可以是变量，转换后的编码]</span><br><span class="line">字节转换为字符串</span><br><span class="line">str(bytes(李杰,encoding=&apos;utf-8&apos;),encoding=&apos;utf-8)</span><br><span class="line">文件操作</span><br></pre></td></tr></table></figure><h1 id="文件方法可以分为四类-输入-输出-文件内移动-以及杂项操作"><a href="#文件方法可以分为四类-输入-输出-文件内移动-以及杂项操作" class="headerlink" title="文件方法可以分为四类: 输入, 输出, 文件内移动, 以及杂项操作."></a>文件方法可以分为四类: 输入, 输出, 文件内移动, 以及杂项操作.</h1><h1 id="读"><a href="#读" class="headerlink" title="读"></a>读</h1><p>read<br>readline<br>readlines</p><h1 id="写"><a href="#写" class="headerlink" title="写"></a>写</h1><p>write</p><h1 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h1><p>seek<br>truncate<br>tell</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">with open(&apos;a.txt&apos;,&apos;r&apos;,encoding=&apos;utf-8&apos;) as f_r,open(&apos;b.txt&apos;,&apos;w&apos;,encoding=&apos;utf-8&apos;) as f_w:</span><br><span class="line">for line in f_r:</span><br><span class="line">if &apos;不要回答&apos; in line:</span><br><span class="line">line = line.replace(&apos;不要回答&apos;,&apos;绝对不能回复&apos;)</span><br><span class="line">f_w.write(line)</span><br><span class="line">os.remove(&apos;a.txt&apos;)</span><br><span class="line">os.rename(&apos;b.txt&apos;,&apos;a.txt&apos;)</span><br></pre></td></tr></table></figure><h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">文件对象的方法 操作</span><br><span class="line">file.close() 关闭文件</span><br><span class="line">file.fileno() 返回文件的描述符(file descriptor ,FD, 整数值)</span><br><span class="line">file.flush() 刷新文件的内部缓冲区</span><br><span class="line">file.isatty() 判断 file 是否是一个类 tty 设备</span><br><span class="line">file.nexta() 返回文件的下一行(类似于 file.readline() ), 或在没有其它行时</span><br><span class="line">引发 StopIteration 异常</span><br><span class="line">file.read(size=-1) 从文件读取 size 个字节, 当未给定 size 或给定负值的时候, 读</span><br><span class="line">取剩余的所有字节, 然后作为字符串返回.如果打开模式无b,则read按字符读取，否则按字节读取</span><br><span class="line">file.readline(size=-1) 从文件中读取并返回一行(包括行结束符), 或返回最大 size</span><br><span class="line">file=open(&apos;test&apos;,&apos;ab&apos;)</span><br><span class="line">file.write(bytes(&apos;hehe&apos;,encoding=&apos;utf-8&apos;)) 向文件写入字符串  (会覆盖原有数据，坑</span><br><span class="line">file.close() 关闭文件</span><br><span class="line">file.tell获取当前指针的位置</span><br><span class="line">file.read()如果打开模式无b,则read按字符读取，否则按字节读取</span><br><span class="line">file.fileno文件描述符</span><br><span class="line">file.truncat 截断数据，清除文件指针之后的数据</span><br><span class="line">file.seek(off, whence=0) 在文件中移动文件指针, 从 whence ( 0 代表文件其始, 1代表当前位置, 2 代表文件末尾)偏移 off 字节,不论是否有中文，都以字节为单位</span><br><span class="line">file.truncate(size=file.tell()) 截取文件到最大 size 字节, 默认为当前文件位置</span><br><span class="line">file.writelines(seq) 向文件写入字符串序列 seq ; seq 应该是一个返回字符串的</span><br><span class="line">可迭代对象</span><br><span class="line">file.readlines(sizhint=0) 读取文件的所有行并作为一个列表返回(包含所有的行结束</span><br><span class="line">符);</span><br></pre></td></tr></table></figure><h1 id="文件系统访问"><a href="#文件系统访问" class="headerlink" title="文件系统访问"></a>文件系统访问</h1><p>os 模块的文件/目录访问函数</p><h1 id="文件处理"><a href="#文件处理" class="headerlink" title="文件处理"></a>文件处理</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mkfifo()/mknod()a 创建命名管道/创建文件系统节点</span><br><span class="line">remove()/unlink() Delete file 删除文件</span><br><span class="line">rename()/renames()b 重命名文件</span><br><span class="line">*statc() 返回文件信息</span><br><span class="line">symlink() 创建符号链接</span><br><span class="line">utime() 更新时间戳</span><br><span class="line">tmpfile() 创建并打开(&apos;w+b&apos;)一个新的临时文件</span><br><span class="line">walk()a 生成一个目录树下的所有文件名</span><br></pre></td></tr></table></figure><h1 id="目录文件夹"><a href="#目录文件夹" class="headerlink" title="目录文件夹"></a>目录文件夹</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 chdir()/fchdir()a 改变当前工作目录/通过一个文件描述符改变当前工作目录</span><br><span class="line">2 chroot()d 改变当前进程的根目录</span><br><span class="line">3 listdir() 列出指定目录的文件</span><br><span class="line">4 getcwd()/getcwdu()a返回当前工作目录/功能相同, 但返回一个 Unicode 对象</span><br><span class="line">5 mkdir()/makedirs() 创建目录/创建多层目录</span><br><span class="line">6 rmdir()/removedirs() 删除目录/删除多层目录</span><br></pre></td></tr></table></figure><h1 id="访问-权限"><a href="#访问-权限" class="headerlink" title="访问/权限"></a>访问/权限</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 access() 检验权限模式</span><br><span class="line">2 chmod() 改变权限模式</span><br><span class="line">3 chown()/lchown()a 改变 owner 和 group ID/功能相同, 但不会跟踪链接</span><br><span class="line">4 umask() 设置默认权限模式</span><br></pre></td></tr></table></figure><h1 id="文件描述符操作"><a href="#文件描述符操作" class="headerlink" title="文件描述符操作"></a>文件描述符操作</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 open() 底层的操作系统 open (对于文件, 使用标准的内建 open() 函数)</span><br><span class="line">2 read()/write() 根据文件描述符读取/写入数据</span><br><span class="line">3 dup()/dup2() 复制文件描述符号/功能相同, 但是是复制到另一个文件描述符</span><br></pre></td></tr></table></figure><h1 id="设备号"><a href="#设备号" class="headerlink" title="设备号"></a>设备号</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 makedev()a 从 major 和 minor 设备号创建一个原始设备号</span><br><span class="line">2 major()a /minor()a 从原始设备号获得 major/minor 设备号</span><br></pre></td></tr></table></figure><h1 id="路径名的操作"><a href="#路径名的操作" class="headerlink" title="路径名的操作"></a>路径名的操作</h1><p>os.path 可以完成一些针对路径名的操作. 它提供的函数可以完成管理和操作文<br>件路径名中的各个部分, 获取文件或子目录信息, 文件路径查询等操作<br>os.path 模块中的路径名访问函数</p><h1 id="分割"><a href="#分割" class="headerlink" title="分割"></a>分割</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 basename() 去掉目录路径, 返回文件名</span><br><span class="line">2 dirname() 去掉文件名, 返回目录路径</span><br><span class="line">3 join() 将分离的各部分组合成一个路径名</span><br><span class="line">4 split() 返回 (dirname(), basename()) 元组</span><br><span class="line">5 splitdrive() 返回 (drivename, pathname) 元组</span><br><span class="line">6 splitext() 返回 (filename, extension) 元组</span><br></pre></td></tr></table></figure><h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 getatime() 返回最近访问时间</span><br><span class="line">2 getctime() 返回文件创建时间</span><br><span class="line">3 getmtime() 返回最近文件修改时间</span><br><span class="line">4 getsize() 返回文件大小(以字节为单位)</span><br></pre></td></tr></table></figure><h1 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">exists() 指定路径(文件或目录)是否存在</span><br><span class="line">isabs() 指定路径是否为绝对路径</span><br><span class="line">isdir() 指定路径是否存在且为一个目录</span><br><span class="line">isfile() 指定路径是否存在且为一个文件</span><br><span class="line">islink() 指定路径是否存在且为一个符号链接</span><br><span class="line">ismount() 指定路径是否存在且为一个挂载点</span><br><span class="line">samefile() 两个路径名是否指向同个文件</span><br></pre></td></tr></table></figure><h1 id="其它模块"><a href="#其它模块" class="headerlink" title="其它模块"></a>其它模块</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">base64 提供二进制字符串和文本字符串间的编码/解码操作</span><br><span class="line">binascii 提供二进制和 ASCII 编码的二进制字符串间的编码/解码操作</span><br><span class="line">bz2a 访问 BZ2 格式的压缩文件</span><br><span class="line">csv  访问 csv 文件(逗号分隔文件)</span><br><span class="line">filecmpb 用于比较目录和文件</span><br><span class="line">fileinput 提供多个文本文件的行迭代器</span><br><span class="line">getopt/optparsea 提供了命令行参数的解析/处理</span><br><span class="line">glob/fnmatch 提供 Unix 样式的通配符匹配的功能</span><br><span class="line">gzip/zlib 读写 GNU zip( gzip) 文件(压缩需要 zlib 模块)</span><br><span class="line">shutil 提供高级文件访问功能</span><br><span class="line">c/StringIO 对字符串对象提供类文件接口</span><br><span class="line">tarfilea 读写 TAR 归档文件, 支持压缩文件</span><br><span class="line">tempfile 创建一个临时文件(名)</span><br><span class="line">uu   格式的编码和解码</span><br><span class="line">zipfilec 用于读取 ZIP 归档文件的工具</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">with open(&apos;db1&apos;, &apos;r&apos;, encoding=&quot;utf-8&quot;) as f1, open(&quot;db2&quot;, &apos;w&apos;,encoding=&quot;utf-8&quot;) as f2:</span><br><span class="line">    times = 0</span><br><span class="line">    for line in f1:         </span><br><span class="line">        times += 1 </span><br><span class="line">        if times &lt;=10:</span><br><span class="line">            f2.write(line)</span><br><span class="line">        else:</span><br><span class="line">            break</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;函数定义方式&quot;&gt;&lt;a href=&quot;#函数定义方式&quot; class=&quot;headerlink&quot; title=&quot;函数定义方式&quot;&gt;&lt;/a&gt;函数定义方式&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;函数名，形参，实参，返回值
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;函数调用方式&quot;&gt;&lt;a 
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
      <category term="函数" scheme="http://yoursite.com/categories/Python/%E5%87%BD%E6%95%B0/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="函数模块" scheme="http://yoursite.com/tags/%E5%87%BD%E6%95%B0%E6%A8%A1%E5%9D%97/"/>
    
      <category term="总结" scheme="http://yoursite.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>python 文件处理</title>
    <link href="http://yoursite.com/2019/03/21/python%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/"/>
    <id>http://yoursite.com/2019/03/21/python文件读写/</id>
    <published>2019-03-21T10:32:36.000Z</published>
    <updated>2019-04-23T07:25:58.318Z</updated>
    
    <content type="html"><![CDATA[<h1 id="三元运算"><a href="#三元运算" class="headerlink" title="三元运算"></a>三元运算</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = 2</span><br><span class="line">b = 3</span><br><span class="line">val = a if a &lt; b else b</span><br></pre></td></tr></table></figure><h1 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f = open(file=&apos;d:/hello.txt&apos;,mode=&apos;r,encoding=&apos;utf-8&apos;)</span><br><span class="line">data = f.read()</span><br><span class="line">f.close</span><br></pre></td></tr></table></figure><ul><li>二进制模式<br>  mode = b</li></ul><h1 id="智能检测编码-chardet"><a href="#智能检测编码-chardet" class="headerlink" title="智能检测编码 chardet"></a>智能检测编码 chardet</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import chardet</span><br><span class="line">f = open(&apos;log&apos;,mode=&apos;rb&apos;)</span><br><span class="line">data = f.read()</span><br><span class="line">f.close()</span><br><span class="line">result = chardet.detect(data)</span><br><span class="line">print(result)</span><br><span class="line">data.decode(&quot;gb2312&quot;)</span><br></pre></td></tr></table></figure><ul><li>安装<br>  pip3 install chardet<h1 id="大文件处理"><a href="#大文件处理" class="headerlink" title="大文件处理"></a>大文件处理</h1></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f = open(&quot;log&quot;,&apos;r&apos;,encoding=&quot;gbk&quot;)</span><br><span class="line">for line in f:</span><br><span class="line">print(line)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><h1 id="写文件-创建新文件，清空数据"><a href="#写文件-创建新文件，清空数据" class="headerlink" title="写文件(创建新文件，清空数据)"></a>写文件(创建新文件，清空数据)</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f = open(&apos;log&apos;,&apos;w&apos;,encoding=&apos;gbk&apos;)</span><br><span class="line">f.write(&quot;helow&quot;)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><ul><li>二进制写</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f = open(&apos;log&apos;,&apos;wb&apos;)</span><br><span class="line">f.write(&quot;helow&quot;,encoding=&apos;gbk&apos;)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><h1 id="追加文件"><a href="#追加文件" class="headerlink" title="追加文件"></a>追加文件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f = open(&apos;log&apos;,&apos;ab&apos;)</span><br><span class="line">f.write(&quot;hellow&quot;,encoding=&apos;gbk&apos;)</span><br><span class="line">f.close</span><br></pre></td></tr></table></figure><h1 id="混合读写"><a href="#混合读写" class="headerlink" title="混合读写"></a>混合读写</h1><ul><li><p>读写模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f = open(&apos;log&apos;, &apos;r+&apos;)</span><br><span class="line">f.read()</span><br><span class="line">f.write(&quot;hello&quot;)</span><br></pre></td></tr></table></figure></li><li><p>写读模式（清空原文件），几乎无用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f = open(&apos;log&apos;, &apos;w+&apos;)</span><br><span class="line">f.read()</span><br><span class="line">f.write(&quot;hello&quot;)</span><br></pre></td></tr></table></figure></li></ul><h1 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h1><p>flush    #强制把内存刷新到硬盘<br>read    #按字符读<br>tell    #当前文件光标位置，按字节来度<br>seek    #改变光标位置，按字节读<br>truncate    #按当前位置截断文件（3,6） 6-&gt;从头开始截取6个</p><h1 id="文件修改（占内存或占硬盘）"><a href="#文件修改（占内存或占硬盘）" class="headerlink" title="文件修改（占内存或占硬盘）"></a>文件修改（占内存或占硬盘）</h1><ul><li><p>占硬盘<br>f1 = “log.txt”<br>f_new = “log_new.txt”<br>old_str = “alex”<br>new_str = “david”<br>f = open(f1,”r”,encoding=”utf-8”)<br>f_new = open(f_new,”w”,encoding=”utf-8”)<br>for line in f:<br>  if old_str in line:</p><pre><code>line = line.replace(old_str,new_str)</code></pre><p>  f_new.write(line)<br>f.close()<br>f_new.close()<br>os.rename(f_new,f1)</p></li><li><p>占内存</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;三元运算&quot;&gt;&lt;a href=&quot;#三元运算&quot; class=&quot;headerlink&quot; title=&quot;三元运算&quot;&gt;&lt;/a&gt;三元运算&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="文件" scheme="http://yoursite.com/tags/%E6%96%87%E4%BB%B6/"/>
    
      <category term="Ch2" scheme="http://yoursite.com/tags/Ch2/"/>
    
  </entry>
  
  <entry>
    <title>python的两种注释方式</title>
    <link href="http://yoursite.com/2019/03/20/python%E6%B3%A8%E9%87%8A/"/>
    <id>http://yoursite.com/2019/03/20/python注释/</id>
    <published>2019-03-20T10:32:36.000Z</published>
    <updated>2019-04-18T06:11:30.168Z</updated>
    
    <content type="html"><![CDATA[<p>为程序添加注释可以用来解释程序某些部分的作用和功能，提高程序的可读性。除此之外，注释也是调试程序的重要方式。在某些时候，我们不希望编译、执行程序中的某些代码，这时就可以将这些代码注释掉。<br>Python 语言允许在任何地方插入空字符或注释，但不能插入到标识符和字符串中间。<br>Python 源代码的注释有两种形式，分别是单行注释和多行注释：</p><h1 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h1><p>Python 使用井号（＃）表示单行注释的开始，跟在“＃”号后面直到这行结束为止的代码都将被解释器忽略。单行注释就是在程序中注释一行代码，在Python 程序中将井号（＃）放在需要注释的内容之前就可以了。</p><h1 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h1><p>多行注释是指一次性将程序中的多行代码注释掉，在 Python 程序中使用三个单引号或三个双引号将注释的内容括起来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#这是一行简单的注释</span><br><span class="line">print (&quot;Hello World!&quot;)</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">这里面的内容全部是多行注释</span><br><span class="line">Python语言真的很简单</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line"># print(&quot;这行代码被注释了，将不会被编译、执行！&quot;)</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">这是用三个双引号括起来的多行注释</span><br><span class="line">Python 同样是允许的</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;为程序添加注释可以用来解释程序某些部分的作用和功能，提高程序的可读性。除此之外，注释也是调试程序的重要方式。在某些时候，我们不希望编译、执行程序中的某些代码，这时就可以将这些代码注释掉。&lt;br&gt;Python 语言允许在任何地方插入空字符或注释，但不能插入到标识符和字符串中间
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python 注释" scheme="http://yoursite.com/tags/Python-%E6%B3%A8%E9%87%8A/"/>
    
  </entry>
  
  <entry>
    <title>python 元组</title>
    <link href="http://yoursite.com/2019/03/20/python%E5%85%83%E7%BB%84/"/>
    <id>http://yoursite.com/2019/03/20/python元组/</id>
    <published>2019-03-20T10:32:36.000Z</published>
    <updated>2019-04-18T06:11:30.189Z</updated>
    
    <content type="html"><![CDATA[<pre><code>元组是有序的不可变</code></pre><h1 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(1,2,3,4)[2:5]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;元组是有序的不可变
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;切片&quot;&gt;&lt;a href=&quot;#切片&quot; class=&quot;headerlink&quot; title=&quot;切片&quot;&gt;&lt;/a&gt;切片&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python 元组" scheme="http://yoursite.com/tags/Python-%E5%85%83%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>python 字符串函数</title>
    <link href="http://yoursite.com/2019/03/20/python%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://yoursite.com/2019/03/20/python字符串/</id>
    <published>2019-03-20T10:32:36.000Z</published>
    <updated>2019-04-18T21:08:07.948Z</updated>
    
    <content type="html"><![CDATA[<pre><code>字符串是有序的字符集合有序不可变</code></pre><h1 id="判断是否是数字"><a href="#判断是否是数字" class="headerlink" title="判断是否是数字"></a>判断是否是数字</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;3&apos;.isdigit()</span><br><span class="line">&apos;33.3&apos;.isdecimal()</span><br></pre></td></tr></table></figure><h1 id="全部小写"><a href="#全部小写" class="headerlink" title="全部小写"></a>全部小写</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;aB&apos;.casefold()</span><br></pre></td></tr></table></figure><h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;aB&apos;.find(&apos;o&apos;)</span><br></pre></td></tr></table></figure><h1 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = &quot; hello &#123;name&#125;&quot;</span><br><span class="line">a.format(name=&apos;david&apos;)</span><br></pre></td></tr></table></figure><h1 id="返回索引"><a href="#返回索引" class="headerlink" title="返回索引"></a>返回索引</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = &quot; hello world&quot;</span><br><span class="line">a.index(&apos;o&apos;,5,6)</span><br><span class="line">#不存在索引，则报错</span><br><span class="line">a.index(&apos;x&apos;)</span><br></pre></td></tr></table></figure><h1 id="合法变量"><a href="#合法变量" class="headerlink" title="合法变量"></a>合法变量</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = &quot; hello&quot;</span><br><span class="line">a.isidentifier()</span><br></pre></td></tr></table></figure><h1 id="列表字符串拼接"><a href="#列表字符串拼接" class="headerlink" title="列表字符串拼接"></a>列表字符串拼接</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = [&apos;1&apos;,&apos;2&apos;,&apos;3&apos;]</span><br><span class="line">&apos;+&apos;.join(a)</span><br></pre></td></tr></table></figure><h1 id="居中"><a href="#居中" class="headerlink" title="居中"></a>居中</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = &quot;hello&quot;</span><br><span class="line">a.center(20,&quot;*&quot;)</span><br></pre></td></tr></table></figure><h1 id="大小写"><a href="#大小写" class="headerlink" title="大小写"></a>大小写</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = &quot;hello&quot;</span><br><span class="line">a.lower()</span><br><span class="line">a.upper()</span><br></pre></td></tr></table></figure><h1 id="去掉转义字符空格"><a href="#去掉转义字符空格" class="headerlink" title="去掉转义字符空格"></a>去掉转义字符空格</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = &quot;hello /r/n&quot;</span><br><span class="line">a.strip()</span><br></pre></td></tr></table></figure><h1 id="maketrans-amp-translate"><a href="#maketrans-amp-translate" class="headerlink" title="maketrans&amp;translate"></a>maketrans&amp;translate</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = &quot;hello8888&quot;</span><br><span class="line">b = &quot;ddid##@@@&quot;</span><br><span class="line">table = str.maketrans(a,b)</span><br><span class="line">a.translate(table)</span><br></pre></td></tr></table></figure><h1 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = &quot;hello&quot;</span><br><span class="line">a.replace(&apos;h&apos;,&apos;H&apos;)</span><br><span class="line">a.replace(&apos;l&apos;,&apos;o&apos;,2)</span><br></pre></td></tr></table></figure><h1 id="分割"><a href="#分割" class="headerlink" title="分割"></a>分割</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = &quot;hello&quot;</span><br><span class="line">a.split(&apos;l&apos;,1)</span><br><span class="line">a.rsplit(&apos;l&apos;,1)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;字符串是有序的字符集合
有序
不可变
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;判断是否是数字&quot;&gt;&lt;a href=&quot;#判断是否是数字&quot; class=&quot;headerlink&quot; title=&quot;判断是否是数字&quot;&gt;&lt;/a&gt;判断是否是数字&lt;/h1&gt;&lt;figure cl
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python 字符串" scheme="http://yoursite.com/tags/Python-%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
</feed>
