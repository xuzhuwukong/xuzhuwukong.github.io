<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-05-27T23:18:50.715Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>David</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python 类和对象</title>
    <link href="http://yoursite.com/2019/05/18/python-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2019/05/18/python-类和对象/</id>
    <published>2019-05-18T04:32:36.000Z</published>
    <updated>2019-05-27T23:18:50.715Z</updated>
    
    <content type="html"><![CDATA[<blockquote><blockquote><blockquote><p>class ListNode(object):<br>…     def <strong>init</strong>(self,value):<br>…             self.val = value<br>…             self.next = None<br>…</p><p>a = ListNode(1)</p></blockquote></blockquote></blockquote><p>a.val</p><blockquote><blockquote><blockquote><p>class Li(ListNode):<br>…     a = 3<br>…     def <strong>init</strong>(self,value,a):<br>…             ListNode.<strong>init</strong>(self,value)<br>…             self.a = a<br>…</p></blockquote><p>Li.a</p></blockquote></blockquote><p><a href="https://www.cnblogs.com/magicking/p/8971740.html" target="_blank" rel="noopener">https://www.cnblogs.com/magicking/p/8971740.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;class ListNode(object):&lt;br&gt;…     def &lt;strong&gt;init&lt;/strong&gt;(self,value):&lt;br&gt;…             self.val 
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="类" scheme="http://yoursite.com/tags/%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>python 数学函数</title>
    <link href="http://yoursite.com/2019/05/18/python-%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2019/05/18/python-数学函数/</id>
    <published>2019-05-18T04:32:36.000Z</published>
    <updated>2019-05-27T13:29:53.451Z</updated>
    
    <content type="html"><![CDATA[<h1 id="四舍五入"><a href="#四舍五入" class="headerlink" title="四舍五入"></a>四舍五入</h1><pre><code>round(4.54,1)</code></pre><h1 id="向上取整"><a href="#向上取整" class="headerlink" title="向上取整"></a>向上取整</h1><pre><code>import mathmath.ceil(4.1) = 5</code></pre><h1 id="向下取整"><a href="#向下取整" class="headerlink" title="向下取整"></a>向下取整</h1><pre><code>math.floor(4.9) = 4</code></pre><h1 id="忽略小数点"><a href="#忽略小数点" class="headerlink" title="忽略小数点"></a>忽略小数点</h1><pre><code>int(3.215)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;四舍五入&quot;&gt;&lt;a href=&quot;#四舍五入&quot; class=&quot;headerlink&quot; title=&quot;四舍五入&quot;&gt;&lt;/a&gt;四舍五入&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;round(4.54,1)
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;向上取整&quot;&gt;&lt;a href=&quot;#向上取
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="数学函数" scheme="http://yoursite.com/tags/%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>python pstuil</title>
    <link href="http://yoursite.com/2019/05/18/python-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97psutil/"/>
    <id>http://yoursite.com/2019/05/18/python-常用模块psutil/</id>
    <published>2019-05-18T04:32:36.000Z</published>
    <updated>2019-05-23T03:21:39.685Z</updated>
    
    <content type="html"><![CDATA[<h1 id="psutil模块介绍"><a href="#psutil模块介绍" class="headerlink" title="psutil模块介绍"></a>psutil模块介绍</h1><p>psutil是一个跨平台库（<a href="http://code.google.com/p/psutil/），能够轻松实现获取系统运行的进程和系统利用率（包括CPU、内存、磁盘、网络等）信息。它主要应用于系统监控，分析和限制系统资源及进程的管理。" target="_blank" rel="noopener">http://code.google.com/p/psutil/），能够轻松实现获取系统运行的进程和系统利用率（包括CPU、内存、磁盘、网络等）信息。它主要应用于系统监控，分析和限制系统资源及进程的管理。</a><br>它实现了同等命令行工具提供的功能，如ps、top、lsof、netstat、ifconfig、who、df、kill、free、nice、ionice、iostat、iotop、uptime、pidof、tty、taskset、pmap等。<br>目前支持32位和64位的Linux、Windows、OS X、FreeBSD和Sun Solaris等操作系统。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><pre><code>wget https://pypi.python.org/packages/source/p/psutil/psutil-2.0.0.tar.gztar -xzvf psutil-2.0.0.tar.gzcd psutil-2.0.0python setup.py install</code></pre><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>获取系统性能信息（CPU,内存，磁盘，网络）</p><h2 id="CPU相关"><a href="#CPU相关" class="headerlink" title="CPU相关"></a>CPU相关</h2><p>查看cpu信息</p><p>import Psutil<br>查看cpu所有信息</p><blockquote><blockquote><blockquote><p>psutil.cpu_times()<br>scputimes(user=11677.09, nice=57.93, system=148675.58, idle=2167147.79, iowait=260828.48, irq=7876.28, softirq=0.0, steal=3694.59, guest=0.0, guest_nice=0.0)<br>显示cpu所有逻辑信息</p></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><p>psutil.cpu_times(percpu=True)<br>[scputimes(user=11684.17, nice=57.93, system=148683.01, idle=2168982.08, iowait=260833.18, irq=7882.35, softirq=0.0, steal=3697.3, guest=0.0, guest_nice=0.0)]<br>查看用户的cpu时间比</p></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><p>psutil.cpu_times().user<br>11684.4<br>查看cpu逻辑个数</p></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><p>psutil.cpu_count()<br>1<br>查看cpu物理个数</p></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><p>psutil.cpu_count(logical=False)<br>1</p></blockquote></blockquote></blockquote><h2 id="查看系统内存"><a href="#查看系统内存" class="headerlink" title="查看系统内存"></a>查看系统内存</h2><blockquote><blockquote><blockquote><p>import psutil<br>mem = psutil.virtual_memory()<br>mem</p></blockquote></blockquote></blockquote><h2 id="系统内存的所有信息"><a href="#系统内存的所有信息" class="headerlink" title="系统内存的所有信息"></a>系统内存的所有信息</h2><p>svmem(total=1040662528, available=175054848, percent=83.2, used=965718016, free=74944512, active=566755328, inactive=59457536, buffers=9342976, cached=90767360)<br>系统总计内存</p><blockquote><blockquote><blockquote><p>mem.total<br>1040662528<br>系统已经使用内存</p></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><p>mem.used<br>965718016<br>系统空闲内存</p></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><p>mem.free<br>112779264<br>获取swap内存信息</p></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><p>psutil.swap_memory()<br>sswap(total=0, used=0, free=0, percent=0, sin=0, sout=0)</p></blockquote></blockquote></blockquote><h2 id="读取磁盘参数"><a href="#读取磁盘参数" class="headerlink" title="读取磁盘参数"></a>读取磁盘参数</h2><p>磁盘利用率使用psutil.disk_usage方法获取，</p><p>磁盘IO信息包括read_count(读IO数)，write_count(写IO数)<br>read_bytes(IO写字节数)，read_time(磁盘读时间)，write_time(磁盘写时间),这些IO信息用</p><p>psutil.disk_io_counters()<br>获取磁盘的完整信息</p><p>psutil.disk_partitions()<br>获取分区表的参数</p><p>psutil.disk_usage(‘/‘)   #获取/分区的状态<br>获取硬盘IO总个数</p><p>psutil.disk_io_counters()<br>获取单个分区IO个数</p><p>psutil.disk_io_counters(perdisk=True)    #perdisk=True参数获取单个分区IO个数</p><h2 id="读取网络信息"><a href="#读取网络信息" class="headerlink" title="读取网络信息"></a>读取网络信息</h2><p>网络信息与磁盘IO信息类似,涉及到几个关键点，包括byes_sent(发送字节数),byte_recv=xxx(接受字节数),<br>pack-ets_sent=xxx(发送数据包数),pack-ets_recv=xxx(接收数据包数)。</p><p>获取网络总IO信息</p><p>psutil.net_io_counters()<br>输出网络每个接口信息</p><p>psutil.net_io_counters(pernic=True)     #pernic=True<br>获取当前系统用户登录信息</p><p>psutil.users()<br>获取开机时间</p><p>psutil.boot_time() #以linux时间格式返回</p><p>datetime.datetime.fromtimestamp(psutil.boot_time ()).strftime(“%Y-%m-%d %H: %M: %S”) #转换成自然时间格式</p><h2 id="系统进程管理"><a href="#系统进程管理" class="headerlink" title="系统进程管理"></a>系统进程管理</h2><p>获取当前系统的进程信息,获取当前程序的运行状态,包括进程的启动时间,查看设置CPU亲和度,内存使用率,IO信息<br>socket连接,线程数等<br>获取进程信息</p><p>查看系统全部进程</p><p>psutil.pids()<br>查看单个进程</p><p>p = psutil.Process(2423)<br>p.name()   #进程名<br>p.exe()    #进程的bin路径<br>p.cwd()    #进程的工作目录绝对路径<br>p.status()   #进程状态<br>p.create_time()  #进程创建时间<br>p.uids()    #进程uid信息<br>p.gids()    #进程的gid信息<br>p.cpu_times()   #进程的cpu时间信息,包括user,system两个cpu信息<br>p.cpu_affinity()  #get进程cpu亲和度,如果要设置cpu亲和度,将cpu号作为参考就好<br>p.memory_percent()  #进程内存利用率<br>p.memory_info()    #进程内存rss,vms信息<br>p.io_counters()    #进程的IO信息,包括读写IO数字及参数<br>p.connectios()   #返回进程列表<br>p.num_threads()  #进程开启的线程数<br>听过psutil的Popen方法启动应用程序，可以跟踪程序的相关信息<br>from subprocess import PIPE<br>p = psutil.Popen([“/usr/bin/python”, “-c”, “print(‘hello’)”],stdout=PIPE)<br>p.name()<br>p.username()</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;psutil模块介绍&quot;&gt;&lt;a href=&quot;#psutil模块介绍&quot; class=&quot;headerlink&quot; title=&quot;psutil模块介绍&quot;&gt;&lt;/a&gt;psutil模块介绍&lt;/h1&gt;&lt;p&gt;psutil是一个跨平台库（&lt;a href=&quot;http://code.goo
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python psutil" scheme="http://yoursite.com/tags/Python-psutil/"/>
    
  </entry>
  
  <entry>
    <title>python 线程</title>
    <link href="http://yoursite.com/2019/05/18/python-%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/05/18/python-线程/</id>
    <published>2019-05-18T04:32:36.000Z</published>
    <updated>2019-05-19T15:41:20.698Z</updated>
    
    <content type="html"><![CDATA[<h1 id="子线程强制终止"><a href="#子线程强制终止" class="headerlink" title="子线程强制终止"></a>子线程强制终止</h1><p>子线程的强制性终止是我们实际应用时经常需要用到的，然而python官方并没有给出相关的函数来处理这种情况。<br><a href="http://stackoverflow.com/questions/323972/is-there-any-way-to-kill-a-thread-in-python" target="_blank" rel="noopener">http://stackoverflow.com/questions/323972/is-there-any-way-to-kill-a-thread-in-python</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def _async_raise(tid, exctype):</span><br><span class="line">    &quot;&quot;&quot;raises the exception, performs cleanup if needed&quot;&quot;&quot;</span><br><span class="line">    tid = ctypes.c_long(tid)</span><br><span class="line">    if not inspect.isclass(exctype):</span><br><span class="line">        exctype = type(exctype)</span><br><span class="line">    res = ctypes.pythonapi.PyThreadState_SetAsyncExc(tid, ctypes.py_object(exctype))</span><br><span class="line">    if res == 0:</span><br><span class="line">        raise ValueError(&quot;invalid thread id&quot;)</span><br><span class="line">    elif res != 1:</span><br><span class="line">        # &quot;&quot;&quot;if it returns a number greater than one, you&apos;re in trouble,</span><br><span class="line">        # and you should call it again with exc=NULL to revert the effect&quot;&quot;&quot;</span><br><span class="line">        ctypes.pythonapi.PyThreadState_SetAsyncExc(tid, None)</span><br><span class="line">        raise SystemError(&quot;PyThreadState_SetAsyncExc failed&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def stop_thread(thread):</span><br><span class="line">    _async_raise(thread.ident, SystemExit)</span><br></pre></td></tr></table></figure></p><h1 id="线程的暂停-恢复-退出"><a href="#线程的暂停-恢复-退出" class="headerlink" title="线程的暂停, 恢复, 退出"></a>线程的暂停, 恢复, 退出</h1><p>我们都知道python中可以是threading模块实现多线程, 但是模块并没有提供暂停, 恢复和停止线程的方法, 一旦线程对象调用start方法后, 只能等到对应的方法函数运行完毕.<br>也就是说一旦start后, 线程就属于失控状态. 不过, 我们可以自己实现这些. 一般的方法就是循环地判断一个标志位, 一旦标志位到达到预定的值, 就退出循环. 这样就能做到退出线程了.<br>但暂停和恢复线程就有点难了, 我一直也不清除有什么好的方法, 直到我看到threading中Event对象的wait方法的描述时.<br>    Block until the internal flag is true. If the internal flag is true on entry, return immediately. Otherwise, block until another thread calls set() to set the flag to true, or until the optional timeout occurs.<br>    阻塞, 直到内部的标志位为True时. 如果在内部的标志位在进入时为True时, 立即返回. 否则, 阻塞直到其他线程调用set()方法将标准位设为True, 或者到达了可选的timeout时间.</p><pre><code>When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof).当给定了timeout参数且不为None, 它应该是一个浮点数，以秒为单位指定操作的超时（或是分数）。This method returns the internal flag on exit, so it will always return True except if a timeout is given and the operation times out.此方法在退出时返回内部标志，因此除非给定了超时且操作超时，否则它将始终返回True。Changed in version 2.7: Previously, the method always returned None. 2.7版本以前, 这个方法总会返回None.</code></pre><p>利用wait的阻塞机制, 就能够实现暂停和恢复了, 再配合循环判断标识位, 就能实现退出了, 下面是代码示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Job(threading.Thread):</span><br><span class="line">    def __init__(self, *args, **kwargs):</span><br><span class="line">        super(Job, self).__init__(*args, **kwargs)</span><br><span class="line">        self.__flag = threading.Event()  # 用于暂停线程的标识</span><br><span class="line">        self.__flag.set()  # 设置为True</span><br><span class="line">        self.__running = threading.Event()  # 用于停止线程的标识</span><br><span class="line">        self.__running.set()  # 将running设置为True</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        while self.__running.isSet():</span><br><span class="line">            self.__flag.wait()  # 为True时立即返回, 为False时阻塞直到内部的标识位为True后返回</span><br><span class="line">            print(time.time())</span><br><span class="line">            time.sleep(1)</span><br><span class="line"></span><br><span class="line">    def pause(self):</span><br><span class="line">        self.__flag.clear()  # 设置为False, 让线程阻塞</span><br><span class="line"></span><br><span class="line">    def resume(self):</span><br><span class="line">        self.__flag.set()  # 设置为True, 让线程停止阻塞</span><br><span class="line"></span><br><span class="line">    def stop(self):</span><br><span class="line">        self.__flag.set()  # 将线程从暂停状态恢复, 如何已经暂停的话</span><br><span class="line">        self.__running.clear()  # 设置为False</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a.start()</span><br><span class="line">time.sleep(3)</span><br><span class="line">a.pause()</span><br><span class="line">time.sleep(3)</span><br><span class="line">a.resume()</span><br><span class="line">time.sleep(3)</span><br><span class="line">a.pause()</span><br><span class="line">time.sleep(2)</span><br><span class="line">a.stop()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;子线程强制终止&quot;&gt;&lt;a href=&quot;#子线程强制终止&quot; class=&quot;headerlink&quot; title=&quot;子线程强制终止&quot;&gt;&lt;/a&gt;子线程强制终止&lt;/h1&gt;&lt;p&gt;子线程的强制性终止是我们实际应用时经常需要用到的，然而python官方并没有给出相关的函数来处理这种
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python 线程" scheme="http://yoursite.com/tags/Python-%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>python 网络通信</title>
    <link href="http://yoursite.com/2019/05/18/python-%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"/>
    <id>http://yoursite.com/2019/05/18/python-网络通信/</id>
    <published>2019-05-18T04:32:36.000Z</published>
    <updated>2019-05-26T05:01:51.816Z</updated>
    
    <content type="html"><![CDATA[<pre><code>网络编程中有两个主要的问题：如何准确的定位网络上一台或多台主机找到主机后如何可靠高效的进行数据传输</code></pre><h1 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h1><img src="/2019/05/18/python-网络通信/tcp.jpg"><h1 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h1><img src="/2019/05/18/python-网络通信/socket.jpg"><h2 id="创建套接字"><a href="#创建套接字" class="headerlink" title="创建套接字"></a>创建套接字</h2><pre><code>socket.socket([family[, type[, proto]]])family: 套接字家族可以使AF_UNIX或者AF_INETtype: 套接字类型可以根据是面向连接的还是非连接分为SOCK_STREAM（基于TCP）或SOCK_DGRAM（基于UDP）protocol: 一般不填默认为0.</code></pre><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><p>sk.bind(address)</p><p>　　s.bind(address) 将套接字绑定到地址。address地址的格式取决于地址族。在AF_INET下，以元组（host,port）的形式表示地址。</p><p>sk.listen(backlog)</p><p>　　开始监听传入连接。backlog指定在拒绝连接之前，可以挂起的最大连接数量。</p><pre><code>backlog等于5，表示内核已经接到了连接请求，但服务器还没有调用accept进行处理的连接个数最大为5这个值不能无限大，因为要在内核中维护连接队列</code></pre><p>sk.accept()</p><p>　　接受连接并返回（conn,address）,其中conn是新的套接字对象，可以用来接收和发送数据。address是连接客户端的地址。</p><p>　　接收TCP 客户的连接（阻塞式）等待连接的到来</p><p>sk.connect(address)</p><p>　　连接到address处的套接字。一般，address的格式为元组（hostname,port）,如果连接出错，返回socket.error错误。</p><p>sk.close()</p><p>　　关闭套接字</p><p>sk.recv(bufsize[,flag])</p><p>　　接受套接字的数据。数据以字符串形式返回，bufsize指定最多可以接收的数量。flag提供有关消息的其他信息，通常可以忽略。</p><p>sk.send(string[,flag])</p><p>　　将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。即：可能未将指定内容全部发送。</p><h1 id="struct模块"><a href="#struct模块" class="headerlink" title="struct模块"></a>struct模块</h1><p>有的时候需要用python处理二进制数据，比如，存取文件，socket操作时.这时候，可以使用python的struct模块来完成.可以用 struct来处理c语言中的结构体.<br>一个字节 = 2个十六进制<br>struct模块中最重要的三个函数是pack(), unpack(), calcsize()</p><p>pack(fmt, v1, v2, …)     按照给定的格式(fmt)，把数据封装成字符串(实际上是类似于c结构体的字节流)</p><p>unpack(fmt, string)       按照给定的格式(fmt)解析字节流string，返回解析出来的tuple</p><p>calcsize(fmt)                 计算给定的格式(fmt)占用多少字节的内存</p><p>struct中支持的格式如下表：</p><table><thead><tr><th>Format</th><th>C Type</th><th>Python</th><th>字节数</th></tr></thead><tbody><tr><td>x</td><td>pad byte</td><td>no value</td><td>1</td></tr><tr><td>c</td><td>char</td><td>string of length 1</td><td>1</td></tr><tr><td>b</td><td>signed char</td><td>integer</td><td>1</td></tr><tr><td>B</td><td>unsigned char</td><td>integer</td><td>1</td></tr><tr><td>?</td><td>_Bool</td><td>bool</td><td>1</td></tr><tr><td>h</td><td>short</td><td>integer</td><td>2</td></tr><tr><td>H</td><td>unsigned short</td><td>integer</td><td>2</td></tr><tr><td>i</td><td>int</td><td>string of length 1</td><td>1</td></tr><tr><td>I</td><td>unsigned int</td><td>string of length 1</td><td>1</td></tr><tr><td>l</td><td>long</td><td>integer</td><td>4</td></tr><tr><td>L</td><td>unsigned long</td><td>long</td><td>4</td></tr><tr><td>q</td><td>long long</td><td>long</td><td>8</td></tr><tr><td>Q</td><td>unsigned long long</td><td>long</td><td>8</td></tr><tr><td>f</td><td>float</td><td>float</td><td>4</td></tr><tr><td>d</td><td>double</td><td>float</td><td>8</td></tr><tr><td>s</td><td>char[]</td><td>string</td><td>1</td></tr><tr><td>p</td><td>char[]</td><td>string</td><td>1</td></tr><tr><td>P</td><td>void *</td><td>long</td><td>?</td></tr></tbody></table><p>注1.q和Q只在机器支持64位操作时有意思</p><p>注2.每个格式前可以有一个数字，表示个数</p><p>注3.s格式表示一定长度的字符串，4s表示长度为4的字符串，但是p表示的是pascal字符串</p><p>注4.P用来转换一个指针，其长度和机器字长相关</p><p>注5.最后一个可以用来表示指针类型的，占4个字节</p><p>为了同c中的结构体交换数据，还要考虑有的c或c++编译器使用了字节对齐，通常是以4个字节为单位的32位系统，故而struct根据本地机器字节顺序转换.可以用格式中的第一个字符来改变对齐方式.定义如下：</p><table><thead><tr><th>Character</th><th>Byte order</th><th>Size and alignment</th></tr></thead><tbody><tr><td>@</td><td>native</td><td>native            凑够4个字节</td></tr><tr><td>=</td><td>native</td><td>standard        按原字节数</td></tr><tr><td>&lt;</td><td>little-endian</td><td>standard        按原字节数</td></tr><tr><td>&gt;</td><td>big-endian</td><td>standard        按原字节数</td></tr><tr><td>!</td><td>network (= big-endian)</td><td>standard        按原字节数</td></tr></tbody></table><p>示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import struct</span><br><span class="line">&gt;&gt;&gt; struct.pack(&apos;&lt;HH&apos;, 1,2)</span><br><span class="line">b&apos;\x01\x00\x02\x00&apos;</span><br><span class="line">&gt;&gt;&gt; struct.unpack(&apos;&lt;hh&apos;, bytes(b&apos;\x01\x00\x00\x00&apos;))</span><br><span class="line">(1, 0)</span><br><span class="line">&gt;&gt;&gt; struct.unpack(&apos;&lt;h&apos;, bytes(b&apos;\x03\x00&apos;))</span><br><span class="line">(3,)</span><br></pre></td></tr></table></figure></p><p>示例一：</p><p>比如有一个结构体</p><p>struct Header</p><p>{</p><pre><code>unsigned short id;char[4] tag;unsigned int version;unsigned int count;</code></pre><p>}</p><p>通过socket.recv接收到了一个上面的结构体数据，存在字符串s中，现在需要把它解析出来，可以使用unpack()函数.</p><p>import struct</p><p>id, tag, version, count = struct.unpack(“!H4s2I”, s)</p><p>上面的格式字符串中，!表示我们要使用网络字节顺序解析，因为我们的数据是从网络中接收到的，在网络上传送的时候它是网络字节顺序的.后面的H表示 一个unsigned short的id,4s表示4字节长的字符串，2I表示有两个unsigned int类型的数据.</p><p>就通过一个unpack，现在id, tag, version, count里已经保存好我们的信息了.</p><p>同样，也可以很方便的把本地数据再pack成struct格式.</p><p>ss = struct.pack(“!H4s2I”, id, tag, version, count);</p><p>pack函数就把id, tag, version, count按照指定的格式转换成了结构体Header，ss现在是一个字符串(实际上是类似于c结构体的字节流)，可以通过 socket.send(ss)把这个字符串发送出去.</p><p>示例二：</p><p>import struct</p><p>a=12.34</p><p>#将a变为二进制</p><p>bytes=struct.pack(‘i’,a)</p><p>此时bytes就是一个string字符串，字符串按字节同a的二进制存储内容相同。</p><p>再进行反操作</p><p>现有二进制数据bytes，（其实就是字符串），将它反过来转换成python的数据类型：</p><p>a,=struct.unpack(‘i’,bytes)</p><p>注意，unpack返回的是tuple</p><p>所以如果只有一个变量的话：</p><p>bytes=struct.pack(‘i’,a)</p><p>那么，解码的时候需要这样</p><p>a,=struct.unpack(‘i’,bytes) 或者 (a,)=struct.unpack(‘i’,bytes)</p><p>如果直接用a=struct.unpack(‘i’,bytes)，那么 a=(12.34,) ，是一个tuple而不是原来的浮点数了。</p><p>如果是由多个数据构成的，可以这样：</p><p>a=’hello’</p><p>b=’world!’</p><p>c=2</p><p>d=45.123</p><p>bytes=struct.pack(‘5s6sif’,a,b,c,d)</p><p>此时的bytes就是二进制形式的数据了，可以直接写入文件比如 binfile.write(bytes)</p><p>然后，当我们需要时可以再读出来，bytes=binfile.read()</p><p>再通过struct.unpack()解码成python变量</p><p>a,b,c,d=struct.unpack(‘5s6sif’,bytes)</p><p>‘5s6sif’这个叫做fmt，就是格式化字符串，由数字加字符构成，5s表示占5个字符的字符串，2i，表示2个整数等等，下面是可用的字符及类型，ctype表示可以与python中的类型一一对应。</p><p>注意：二进制文件处理时会碰到的问题</p><p>我们使用处理二进制文件时，需要用如下方法</p><p>binfile=open(filepath,’rb’)    读二进制文件</p><p>binfile=open(filepath,’wb’)    写二进制文件</p><p>那么和binfile=open(filepath,’r’)的结果到底有何不同呢？</p><p>不同之处有两个地方：</p><p>第一，使用’r’的时候如果碰到’0x1A’，就会视为文件结束，这就是EOF。使用’rb’则不存在这个问题。即，如果你用二进制写入再用文本读出的话，如果其中存在’0X1A’，就只会读出文件的一部分。使用’rb’的时候会一直读到文件末尾。</p><p>第二，对于字符串x=’abc\ndef’，我们可用len(x)得到它的长度为7，\n我们称之为换行符，实际上是’0X0A’。当我们用’w’即文本方式写的时候，在windows平台上会自动将’0X0A’变成两个字符’0X0D’，’0X0A’，即文件长度实际上变成8.。当用’r’文本方式读取时，又自动的转换成原来的换行符。如果换成’wb’二进制方式来写的话，则会保持一个字符不变，读取时也是原样读取。所以如果用文本方式写入，用二进制方式读取的话，就要考虑这多出的一个字节了。’0X0D’又称回车符。linux下不会变。因为linux只使用’0X0A’来表示换行。</p><h2 id="大小端以及字节序的问题"><a href="#大小端以及字节序的问题" class="headerlink" title="大小端以及字节序的问题"></a>大小端以及字节序的问题</h2><p>网络字节顺序NBO（Network Byte Order）：按从高到低的顺序存储，在网络上使用统一的网络字节顺序，可以避免兼容性问题。</p><p>The order in which the bytes of a multi-byte number are transmitted on a network - most significant byte first (as in “big-endian” storage). </p><p>主机字节顺序（HBO，Host Byte Order）：不同的机器HBO不相同，与CPU设计有关计算机数据存储有两种字节优先顺序：高位字节优先和低位字节优先。</p><p>[struct] (<a href="https://docs.python.org/3/library/struct.html" target="_blank" rel="noopener">https://docs.python.org/3/library/struct.html</a>)<br>[关于int，unsigned int , short的关系与跨平台应用及char,int,float等类型在不同平台下所占字节数] (<a href="https://blog.csdn.net/bzhxuexi/article/details/19551979" target="_blank" rel="noopener">https://blog.csdn.net/bzhxuexi/article/details/19551979</a>)</p><h1 id="单线程通信"><a href="#单线程通信" class="headerlink" title="单线程通信"></a>单线程通信</h1><p>　　该实例中，只能 client 发一句， server回一句（先启动server，后启动client）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"></span><br><span class="line">import socket</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  #ipv4, TCP</span><br><span class="line">    sock.bind((&apos;0.0.0.0&apos;,5000))  #元组,相当于一个参数</span><br><span class="line">    sock.listen(10)   #同时保持是十个人的连接</span><br><span class="line">    conn, addr = sock.accept()</span><br><span class="line">    while True:</span><br><span class="line">        data = conn.recv(1024)   #最多1K的数据</span><br><span class="line">        print(data)</span><br><span class="line">        if data == &apos;bye&apos;:</span><br><span class="line">            break</span><br><span class="line">        else:</span><br><span class="line">            msg = raw_input(&quot;&gt;&gt;&quot;)</span><br><span class="line">            conn.send(msg)</span><br><span class="line">    sock.close()</span><br><span class="line">    print(&apos;Bye!!&apos;)</span><br></pre></td></tr></table></figure><p>Client<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"></span><br><span class="line">import socket, time</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    sock.connect((&apos;localhost&apos;,5000))</span><br><span class="line">    while True:</span><br><span class="line">        msg = raw_input(&quot;&gt;&gt;&quot;)</span><br><span class="line">        if msg == &quot;bye&quot;:</span><br><span class="line">            sock.send(msg)</span><br><span class="line">            sock.close()</span><br><span class="line">            break</span><br><span class="line">        else:</span><br><span class="line">            sock.send(msg)</span><br><span class="line">            data = sock.recv(1024)</span><br></pre></td></tr></table></figure></p><h1 id="多线程通信"><a href="#多线程通信" class="headerlink" title="多线程通信"></a>多线程通信</h1><p>　　在该实例中可以自由发送和接收信息（先启动server，后启动client）</p><p>　　利用threading，多线程进行接受消息和发送消息</p><p>　　callback_recv函数负责接受信息的功能<br>　　callback_send函数负责发送信息的功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"></span><br><span class="line">import socket, threading, sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def callback_send(conn):</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">    :param sq:</span><br><span class="line">    :return:</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    while True:                #为了维持持续的发送</span><br><span class="line">        msg = raw_input(&quot;&gt;&gt;&quot;)</span><br><span class="line">        conn.send(msg)</span><br><span class="line"></span><br><span class="line">def callback_recv(conn):</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">    :param sock:</span><br><span class="line">    :return:</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    while True:               #为了维持持续的接收</span><br><span class="line">        data = conn.recv(1024)</span><br><span class="line">        print(data)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    sock.bind((&apos;0.0.0.0&apos;,5000))  #元组,相当于一个参数</span><br><span class="line">    sock.listen(10)   #同时保持是十个人的连接</span><br><span class="line">    conn, addr = sock.accept()</span><br><span class="line"></span><br><span class="line">    thread_send = threading.Thread(target=callback_send, args=(conn, ))</span><br><span class="line">    thread_recv = threading.Thread(target=callback_recv, args=(conn, ))</span><br><span class="line"></span><br><span class="line">    thread_send.start()</span><br><span class="line">    thread_recv.start()</span><br><span class="line"></span><br><span class="line">    sock.close()</span><br></pre></td></tr></table></figure><p>client</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"></span><br><span class="line">import socket, time, threading, sys</span><br><span class="line"></span><br><span class="line">def callback_send(sock):</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">    :param sq:</span><br><span class="line">    :return:</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    while True:</span><br><span class="line">        msg = raw_input(&quot;&gt;&gt;&quot;)</span><br><span class="line">        sock.send(msg)</span><br><span class="line">        # if msg in [&apos;bye&apos;, &apos;quit&apos;]:</span><br><span class="line">        #     sock.close</span><br><span class="line">        #     break</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def callback_recv(sock):</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">    :param sock:</span><br><span class="line">    :return:</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    while True:</span><br><span class="line">        data = sock.recv(1024)</span><br><span class="line">        print(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    sock.connect((&apos;localhost&apos;,5000))</span><br><span class="line"></span><br><span class="line">    thread_send = threading.Thread(target=callback_send, args=(sock, ))</span><br><span class="line">    thread_recv = threading.Thread(target=callback_recv, args=(sock, ))</span><br><span class="line"></span><br><span class="line">    thread_send.start()</span><br><span class="line">    thread_recv.start()</span><br><span class="line"></span><br><span class="line">    while True:</span><br><span class="line">        pass</span><br><span class="line">    sock.close()</span><br></pre></td></tr></table></figure><h1 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h1><img src="/2019/05/18/python-网络通信/UDP.jpg"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">import socket</span><br><span class="line">def send_msg(udp_socket):</span><br><span class="line">    # 获取输入</span><br><span class="line">    msg = input(&quot;请输入要发送的数据：&quot;)</span><br><span class="line">    # 输入对方IP</span><br><span class="line">    dest_ip = input(&quot;请输入对方ip：&quot;)</span><br><span class="line">    # 输入对方port</span><br><span class="line">    dest_port = int(input(&quot;请输入对方端口：&quot;))</span><br><span class="line">    # 编码</span><br><span class="line">    udp_b = msg.encode(&apos;utf-8&apos;)</span><br><span class="line">    # 发送数据</span><br><span class="line">    udp_socket.sendto(udp_b,(dest_ip,dest_port))</span><br><span class="line"></span><br><span class="line">def recv_msg(udp_socket):</span><br><span class="line">    recv_msg = udp_socket.recvfrom(1024)</span><br><span class="line">    # 解码</span><br><span class="line">    # udp_j = recv_msg.decode(&apos;utf-8&apos;)</span><br><span class="line">    # 显示</span><br><span class="line">    recv_msg = recv_msg[0].decode(&apos;utf-8&apos;)</span><br><span class="line">    print(recv_msg)</span><br><span class="line">def main():</span><br><span class="line">    # 创建套接字</span><br><span class="line">    udp_socket = socket.socket(socket.AF_INET,socket.SOCK_DGRAM)</span><br><span class="line">    # 绑定本地信息</span><br><span class="line">    udp_socket.bind((&quot;&quot;,7789))</span><br><span class="line">    while True:</span><br><span class="line">        print(&quot;=&quot; * 30)</span><br><span class="line">        print(&quot;1.发送消息&quot;)</span><br><span class="line">        print(&quot;2.接收消息&quot;)</span><br><span class="line">        print(&quot;0.退出聊天&quot;)</span><br><span class="line">        op_num = input(&quot;请输入要操作的功能：&quot;)</span><br><span class="line">        if op_num == &quot;1&quot;:</span><br><span class="line">            send_msg(udp_socket)</span><br><span class="line">        elif op_num == &quot;2&quot;:</span><br><span class="line">            recv_msg(udp_socket)</span><br><span class="line">        elif op_num == &quot;0&quot;:</span><br><span class="line">            break</span><br><span class="line">        else:</span><br><span class="line">            print(&quot;输入有误，请重新输入&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    udp_socket.close()</span><br><span class="line"></span><br><span class="line">if __name__== main():</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><img src="/2019/05/18/python-网络通信/HTTP.jpg"><h1 id="int与IP转换"><a href="#int与IP转换" class="headerlink" title="int与IP转换"></a>int与IP转换</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import socket,struct</span><br><span class="line">&gt;&gt;&gt; int_ip = 123456789</span><br><span class="line">&gt;&gt;&gt; socket.inet_ntoa(struct.pack(‘I’,socket.htonl(int_ip)))#整数转换为ip地址</span><br><span class="line">’7.91.205.21′</span><br><span class="line">&gt;&gt;&gt; str(socket.ntohl(struct.unpack(“I”,socket.inet_aton(“255.255.255.255″))[0]))#ip地址转换为整数</span><br><span class="line">’4294967295′</span><br><span class="line">实际上也就是进制数的转换</span><br><span class="line">用lambda的方式，int2ip一行代码搞定</span><br><span class="line">&gt;&gt;&gt; int2ip = lambda x: &apos;.&apos;.join([str(x/(256**i)%256) for i in range(3,-1,-1)])</span><br><span class="line">&gt;&gt;&gt; int2ip(123456789)</span><br><span class="line">’7.91.205.21′</span><br><span class="line">用lambda的方式，ip2int</span><br><span class="line">&gt;&gt;&gt; ip2int = lambda x:sum([256**j*int(i) for j,i in enumerate(x.split(&apos;.&apos;)[::-1])])</span><br><span class="line">&gt;&gt;&gt; ip2int(&apos;7.91.205.21&apos;)</span><br><span class="line">123456789</span><br></pre></td></tr></table></figure><h1 id="request模块"><a href="#request模块" class="headerlink" title="request模块"></a>request模块</h1><p>requests模块是python的一个第三方模块，它是基于python自带的urllib模块封装的，用来发送http请求和获取返回的结果，操作很简单。需要自己安装  pip install requests</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> pa = &#123;&apos;query&apos;:&apos;&apos;&apos;&#123;</span><br><span class="line">...     id</span><br><span class="line">...     name</span><br><span class="line">...     age</span><br><span class="line">...     isKid</span><br><span class="line">...     &#125;</span><br><span class="line">... &apos;&apos;&apos;&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; res = requests.post(url=url, params=pa)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; res.content</span><br><span class="line">b&apos;&#123;&quot;data&quot;:&#123;&quot;id&quot;:123,&quot;name&quot;:&quot;jack&quot;,&quot;age&quot;:10,&quot;isKid&quot;:true&#125;&#125;&apos;</span><br><span class="line">&gt;&gt;&gt; res.cookies</span><br><span class="line">&lt;RequestsCookieJar[]&gt;</span><br><span class="line">&gt;&gt;&gt; res.json</span><br><span class="line">&lt;bound method Response.json of &lt;Response [200]&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; res.json()</span><br><span class="line">&#123;&apos;data&apos;: &#123;&apos;age&apos;: 10, &apos;id&apos;: 123, &apos;isKid&apos;: True, &apos;name&apos;: &apos;jack&apos;&#125;&#125;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;网络编程中有两个主要的问题：
如何准确的定位网络上一台或多台主机
找到主机后如何可靠高效的进行数据传输
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;TCP-IP&quot;&gt;&lt;a href=&quot;#TCP-IP&quot; class=&quot;headerlink&quot; title=&quot;TCP/
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python 网络通信" scheme="http://yoursite.com/tags/Python-%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>项目管理计划</title>
    <link href="http://yoursite.com/2019/04/19/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E8%AE%A1%E5%88%92/"/>
    <id>http://yoursite.com/2019/04/19/项目管理-项目管理计划/</id>
    <published>2019-04-19T04:08:36.000Z</published>
    <updated>2019-04-25T08:00:40.586Z</updated>
    
    <content type="html"><![CDATA[<h1 id="项目管理计划"><a href="#项目管理计划" class="headerlink" title="项目管理计划"></a>项目管理计划</h1><img src="/2019/04/19/项目管理-项目管理计划/项目管理计划.png">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;项目管理计划&quot;&gt;&lt;a href=&quot;#项目管理计划&quot; class=&quot;headerlink&quot; title=&quot;项目管理计划&quot;&gt;&lt;/a&gt;项目管理计划&lt;/h1&gt;&lt;img src=&quot;/2019/04/19/项目管理-项目管理计划/项目管理计划.png&quot;&gt;

      
    
    </summary>
    
      <category term="项目管理" scheme="http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="项目管理计划" scheme="http://yoursite.com/tags/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>项目整合管理</title>
    <link href="http://yoursite.com/2019/04/19/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E8%BF%87%E7%A8%8B%E7%BB%84%E5%92%8C%E7%9F%A5%E8%AF%86%E9%A2%86%E5%9F%9F/"/>
    <id>http://yoursite.com/2019/04/19/项目管理-过程组和知识领域/</id>
    <published>2019-04-19T04:08:36.000Z</published>
    <updated>2019-04-19T05:20:55.973Z</updated>
    
    <content type="html"><![CDATA[<hr><table><br>    <tr><br>        <th rowspan="2">知识领域</th><br>        <th colspan="5" style="text-align:center">项目管理过程组</th><br>    </tr><br>    <tr><br>        <th>启动过程组<br>        </th><th>规划过程组<br>        </th><th>执行过程组<br>        </th><th>监控过程组<br>        </th><th>收尾过程组<br>    </th></tr><br>    <tr><br>        <td>项目整合管理</td><br>        <td>制定项目章程</td><br>        <td>制定项目管理计划</td><br>        <td><br>            指导与管理项目工作<br>            管理项目知识<br>        </td><br>        <td><br>            监控项目工作<br>            实施整体变更控制<br>        </td><br>        <td><br>            结束项目或阶段<br>        </td><br>    </tr><br>    <tr><br>        <td>项目范围管理</td><br>        <td></td><br>        <td><br>            规划范围管理<br>            收集需求<br>            定义范围<br>            创建WBS<br>        </td><br>        <td><br>        </td><br>        <td><br>            确认范围<br>            控制范围<br>        </td><br>        <td></td><br>    </tr><br>    <tr><br>        <td>项目进度管理</td><br>        <td></td><br>        <td><br>            规划进度管理<br>            定义活动<br>            排列活动次序<br>            估算活动持续时间<br>            制定进度计划<br>        </td><br>        <td><br>        </td><br>        <td><br>            控制进度<br>        </td><br>        <td></td><br>    </tr><br>    <tr><br>        <td>项目成本管理</td><br>        <td><br>        </td><br>        <td><br>            规划成本管理<br>            估算成本<br>            制定预算<br>        </td><br>        <td></td><br>        <td><br>            控制成本<br>        </td><br>        <td></td><br>    </tr><br>    <tr><br>        <td>项目质量管理</td><br>        <td></td><br>        <td><br>            规划质量管理<br>        </td><br>        <td><br>            管理质量<br>        </td><br>        <td><br>            控制质量<br>        </td><br>        <td></td><br>    </tr><br>    <tr><br>        <td>项目资源管理</td><br>        <td></td><br>        <td><br>            规划资源管理<br>            估算活动资源<br>        </td><br>        <td><br>            获取资源<br>            建设团队<br>            管理团队<br>        </td><br>        <td><br>            控制资源<br>        </td><br>        <td></td><br>    </tr><br>    <tr><br>        <td>项目沟通管理</td><br>        <td></td><br>        <td>规划沟通管理</td><br>        <td>管理沟通</td><br>        <td>监督沟通</td><br>        <td></td><br>    </tr><br>    <tr><br>        <td>项目风险管理</td><br>        <td></td><br>        <td><br>            规划风险管理<br>            识别风险<br>            实施定性风险分析<br>            实施定量风险分析<br>            规划风险应对<br>        </td><br>        <td><br>            实施风险应对<br>        </td><br>        <td><br>            监督风险<br>        </td><br>        <td></td><br>    </tr><br>    <tr><br>        <td>项目采购管理</td><br>        <td></td><br>        <td>规划采购管理</td><br>        <td>实施采购</td><br>        <td>控制采购</td><br>        <td></td><br>    </tr><br>    <tr><br>        <td>项目相关方管理</td><br>        <td>识别相关方</td><br>        <td>规划相关方参与</td><br>        <td>管理相关方参与</td><br>        <td>监督相关方参与</td><br>        <td></td><br>    </tr><br></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;table&gt;&lt;br&gt;    &lt;tr&gt;&lt;br&gt;        &lt;th rowspan=&quot;2&quot;&gt;知识领域&lt;/th&gt;&lt;br&gt;        &lt;th colspan=&quot;5&quot; style=&quot;text-align:center&quot;&gt;项目管理过程组&lt;/th&gt;&lt;br&gt;    &lt;/tr&gt;
      
    
    </summary>
    
      <category term="项目管理" scheme="http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="过程组" scheme="http://yoursite.com/tags/%E8%BF%87%E7%A8%8B%E7%BB%84/"/>
    
      <category term="知识领域" scheme="http://yoursite.com/tags/%E7%9F%A5%E8%AF%86%E9%A2%86%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>挣值分析</title>
    <link href="http://yoursite.com/2019/04/19/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E6%8C%A3%E5%80%BC%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2019/04/19/项目管理-挣值分析/</id>
    <published>2019-04-19T04:08:36.000Z</published>
    <updated>2019-04-22T05:46:34.653Z</updated>
    
    <content type="html"><![CDATA[<h1 id="挣值分析"><a href="#挣值分析" class="headerlink" title="挣值分析"></a>挣值分析</h1><p>挣值分析的三个基本参数包括: 计划值（PV）、实际成本（AC）、和挣值（EV）。四个评价指标包括:进度偏差（SV）、成本偏差（CV）、成本执行指标(CPI)和进度执行指标（SPI）。</p><h1 id="基本参数"><a href="#基本参数" class="headerlink" title="基本参数"></a>基本参数</h1><p>1、 计划价值（Plan Value）。又叫（BCWS,Budgeted Cost for work scheduled)计划工作量的预算费用。是指项目实施过程中某阶段计划要求完成的工作量所需的预算工时（或费用）。<br>    计算公式 PV = BCWS = 计划工作量 <em> 计划单价。<br>    PV的总和有时被称为绩效测量基准（PMB）。项目的总计划价值又被称为完工预算（BAC）<br>2、 实际成本（Actual Cost）。又叫（ACWP, Actual Cost for Work Performed）。是指项目实施过程中某阶段实际完成的工作量所消耗的工时（或费用）。<br>    AC = ACWP = 已完成工作量 </em> 实际单价<br>3、 挣值（EV，Earned Value），又叫（BCWP，Budgeted Cost for Work Performed）已完成工作量的预算成本。<br>    EV = BCWP = 已完成工作量 * 计划单价</p><h1 id="评价指标"><a href="#评价指标" class="headerlink" title="评价指标"></a>评价指标</h1><p>挣值分析法的四个评价指标：进度偏差（SV）、成本偏差（CV）、成本执行指标（CPI）和进度执行指标（SPI）：<br>1、进度偏差（SV，Schedule Variance）SV是指检查日期EV和PV之间的差异：<br>SV=EV-PV=BCWP-BCWS<br>当SV为正值时，表示进度提前；<br>当SV等于零时，表示实际与计划相符。<br>当SV为负值时，表示进度延误。<br>2、成本偏差（CV，Cost Variance）。CV是指检查期间EV和AC之间的差异：<br>CV=EV-AC=BCWP-ACWP<br>当CV为正值时，表示实际消耗的人工（或费用）低于预算值，即有结余或效率高；<br>当CV等于零时，表示实际消耗的人工（或费用）等于预算值；<br>当CV为负值时，表示实际消耗的人工（或费用）超出预算值或超支。<br>3、成本执行指标（CPI，Cost Performed Index）。指项目挣值与实际费用之比（或工时值之比）：<br>CPI=EV/AC=BCWP/ACWP<br>当CPI&gt;1时，表示低于预算，即实际费用低于预算费用；<br>当CPI=1时，表示实际费用与预算费用吻合；<br>当CPI&lt;1时，表示超出预算，即实际费用高于预算费用；<br>4、进度绩效指标（Schedule Performed Index）。指项目挣值与计划值之比：<br>SPI=EV/PV=BCWP/BCWS<br>当SPI&gt;1时，表示进度超前<br>当SPI=1时，表示实际进度与计划进度相同<br>当SPI&lt;1时，表示进度延误<br>挣值管理是项目管理的一种方法，主要用于项目成本和进度的监控<br>挣值通过项目开始时的计划与所完成的工作进行比较，给出了一个项目何时完工的估算，通过从项目已经完工的部分进行推算，项目经理可以估计出项目完工的时候，将会花费多少资源。<br>这项技术基于关键路径的概念。另一个项目绩效测量和管理技术是关键链，它使用的是缓冲管理。原因是挣值管理方法不能区别基于项目约束（例如：项目的关键链）的进度和基于非约束（例如：项目路径网络中的其他路径）的进度，这在某些时候会造成项目经理为了追求更好的挣值测量，而以关键任务成本来急于完成非关键的任务，导致项目完工的推延。这是一个局部最优的例子，问题在于缺乏局部测量与整体测量的从属关系。<br>为了在项目中应用挣值方法，项目经理需要下列首要数据：<br>工作分解结构 (WBS): 以层次化分解的所有任务的列表。<br>项目主进度计划(PMS): 关于那些任务将完成以及谁完成的甘特图<br>计划完成的工作的预计成本(计划值): 每一个周期预计当前完成的工作的预算。<br>实际完成的工作的预计成本(挣值): 每一个周期当前实际完成的工作的预算。<br>实际完成的工作的实际成本(实际成本): 每一个周期工作的实际成本。<br>项目总预算(BAC): 预计用于完成项目所花费的总预算。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;挣值分析&quot;&gt;&lt;a href=&quot;#挣值分析&quot; class=&quot;headerlink&quot; title=&quot;挣值分析&quot;&gt;&lt;/a&gt;挣值分析&lt;/h1&gt;&lt;p&gt;挣值分析的三个基本参数包括: 计划值（PV）、实际成本（AC）、和挣值（EV）。四个评价指标包括:进度偏差（SV）、成本偏差
      
    
    </summary>
    
      <category term="项目管理" scheme="http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="挣值分析" scheme="http://yoursite.com/tags/%E6%8C%A3%E5%80%BC%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>python 多分支判断</title>
    <link href="http://yoursite.com/2019/03/22/python-%E5%A4%9A%E5%88%86%E6%94%AF%E5%88%A4%E6%96%AD/"/>
    <id>http://yoursite.com/2019/03/22/python-多分支判断/</id>
    <published>2019-03-22T10:32:36.000Z</published>
    <updated>2019-04-30T23:44:43.446Z</updated>
    
    <content type="html"><![CDATA[<p>python中没有switch语句，可以考虑字典的映射关系来实现多分支判断。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">swtich_dic=&#123;</span><br><span class="line">&quot;add&quot;:add_info,</span><br><span class="line">&quot;del&quot;:del_info,</span><br><span class="line">&quot;find&quot;:find_info,</span><br><span class="line">&quot;update&quot;:update_info</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">cmd=input(&apos;&gt;&gt;：&apos;).strip().lower().split()</span><br><span class="line">if not cmd:continue</span><br><span class="line">if cmd in func_dic:</span><br><span class="line">func = switch_dic.get(cmd)</span><br><span class="line">func()</span><br></pre></td></tr></table></figure><pre><code>实现功能以后,可以用极限法看看代码有没有优化的地方,就比如这个分支判断，如果用极限法放大分支数量,就会发现用字典的优势了,还有数据,如果数据量比较大的话,也是一样的</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;python中没有switch语句，可以考虑字典的映射关系来实现多分支判断。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="多分支判断" scheme="http://yoursite.com/tags/%E5%A4%9A%E5%88%86%E6%94%AF%E5%88%A4%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>python 高阶函数的使用</title>
    <link href="http://yoursite.com/2019/03/22/python-%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>http://yoursite.com/2019/03/22/python-高阶函数的应用/</id>
    <published>2019-03-22T10:32:36.000Z</published>
    <updated>2019-05-01T00:09:47.375Z</updated>
    
    <content type="html"><![CDATA[<p>zip,map,filter,reduce,sorted，列表推导式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">columns = [&apos;id&apos;,&apos;name&apos;,&apos;age&apos;,&apos;phone&apos;,&apos;dept&apos;,&apos;enrolled_date&apos;]</span><br><span class="line"></span><br><span class="line">with open(r&apos;staff_db.txt&apos;,&apos;r&apos;,encoding=&apos;utf-8&apos;) as fp:</span><br><span class="line"></span><br><span class="line">staff_list = [line.strip().split(&apos;,&apos;) for line in fp] # 列表结构形式员工信息</span><br><span class="line"></span><br><span class="line">data = dict(zip(columns, map(list, zip(*staff_list)))) # 将员工信息存到如下结构中</span><br><span class="line"></span><br><span class="line">data=&#123;&apos;id&apos;: [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;],</span><br><span class="line">&apos;name&apos;: [&apos;Li&apos;, &apos;Wang&apos;, &apos;Rain&apos;],</span><br><span class="line">&apos;age&apos;: [&apos;22&apos;, &apos;28&apos;, &apos;21&apos;],</span><br><span class="line">&apos;phone&apos;: [&apos;13651054608&apos;, &apos;13451024608&apos;, &apos;13451054608&apos;],</span><br><span class="line">&apos;dept&apos;: [&apos;IT&apos;, &apos;HR&apos;, &apos;IT&apos;],</span><br><span class="line">&apos;enrolled_date&apos;: [&apos;2013-04-01&apos;, &apos;2015-01-07&apos;, &apos;2017-04-01&apos;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">info=list(zip(data[&apos;age&apos;],data[&apos;phone&apos;],data[&apos;dept&apos;],data[&apos;enrolled_date&apos;],data[&apos;name&apos;],data[&apos;id&apos;]))</span><br><span class="line"></span><br><span class="line">res=(&apos; &apos;.join(info[0]))</span><br></pre></td></tr></table></figure><pre><code>字典的查询速度是比较快的</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;zip,map,filter,reduce,sorted，列表推导式。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="高阶函数" scheme="http://yoursite.com/tags/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>python 增删改查操作</title>
    <link href="http://yoursite.com/2019/03/22/python-%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/"/>
    <id>http://yoursite.com/2019/03/22/python-增删改查/</id>
    <published>2019-03-22T10:32:36.000Z</published>
    <updated>2019-04-30T04:12:51.113Z</updated>
    
    <content type="html"><![CDATA[<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="查找find"><a href="#查找find" class="headerlink" title="查找find"></a>查找find</h2><h2 id="替换replace"><a href="#替换replace" class="headerlink" title="替换replace"></a>替换replace</h2><h2 id="strip"><a href="#strip" class="headerlink" title="strip()"></a>strip()</h2><h2 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h2><h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h2 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h2><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><h2 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h2><h2 id="增加-1"><a href="#增加-1" class="headerlink" title="增加"></a>增加</h2><h2 id="更新-1"><a href="#更新-1" class="headerlink" title="更新"></a>更新</h2><h2 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h2><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="查找-2"><a href="#查找-2" class="headerlink" title="查找"></a>查找</h2><h2 id="增加-2"><a href="#增加-2" class="headerlink" title="增加"></a>增加</h2><h2 id="更新-2"><a href="#更新-2" class="headerlink" title="更新"></a>更新</h2><h2 id="删除-2"><a href="#删除-2" class="headerlink" title="删除"></a>删除</h2><h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><h2 id="查找-3"><a href="#查找-3" class="headerlink" title="查找"></a>查找</h2><h2 id="增加-3"><a href="#增加-3" class="headerlink" title="增加"></a>增加</h2><h2 id="更新-3"><a href="#更新-3" class="headerlink" title="更新"></a>更新</h2><h2 id="删除-3"><a href="#删除-3" class="headerlink" title="删除"></a>删除</h2><h1 id="Json"><a href="#Json" class="headerlink" title="Json"></a>Json</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;字符串&quot;&gt;&lt;a href=&quot;#字符串&quot; class=&quot;headerlink&quot; title=&quot;字符串&quot;&gt;&lt;/a&gt;字符串&lt;/h1&gt;&lt;h2 id=&quot;查找find&quot;&gt;&lt;a href=&quot;#查找find&quot; class=&quot;headerlink&quot; title=&quot;查找find&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="增删改查" scheme="http://yoursite.com/tags/%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/"/>
    
  </entry>
  
  <entry>
    <title>python 项目目录</title>
    <link href="http://yoursite.com/2019/03/22/python-%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95/"/>
    <id>http://yoursite.com/2019/03/22/python-项目目录/</id>
    <published>2019-03-22T10:32:36.000Z</published>
    <updated>2019-04-30T04:05:07.443Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一般项目的目录结构"><a href="#一般项目的目录结构" class="headerlink" title="一般项目的目录结构"></a>一般项目的目录结构</h1><p>project_name<br>    log<br>    conf<br>    project_name     #core<br>    libs/modules<br>    docs<br>    README<br>        install<br>            python3 setup.py install<br>    setup.py<br>    bin/<br>        start_project.py<br>    requirements.txt    #pip install requirements</p><blockquote><p>pip freeze #列出所有的模块</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一般项目的目录结构&quot;&gt;&lt;a href=&quot;#一般项目的目录结构&quot; class=&quot;headerlink&quot; title=&quot;一般项目的目录结构&quot;&gt;&lt;/a&gt;一般项目的目录结构&lt;/h1&gt;&lt;p&gt;project_name&lt;br&gt;    log&lt;br&gt;    conf&lt;br&gt;   
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="项目目录" scheme="http://yoursite.com/tags/%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>python 函数</title>
    <link href="http://yoursite.com/2019/03/21/python-%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2019/03/21/python-函数/</id>
    <published>2019-03-21T10:32:36.000Z</published>
    <updated>2019-04-26T01:56:26.372Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实参形参"><a href="#实参形参" class="headerlink" title="实参形参"></a>实参形参</h1><pre><code>形参只在函数内部有效</code></pre><img src="/2019/03/21/python-函数/实参形参.png"><h1 id="默认参数-放在参数后面"><a href="#默认参数-放在参数后面" class="headerlink" title="默认参数(放在参数后面)"></a>默认参数(放在参数后面)</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def hello_world(sex,age, name=&quot;david&quot;):</span><br><span class="line">print(name)</span><br></pre></td></tr></table></figure><h1 id="关键参数（实参输入时，不想按顺序传参，必须放在位置参数后面）"><a href="#关键参数（实参输入时，不想按顺序传参，必须放在位置参数后面）" class="headerlink" title="关键参数（实参输入时，不想按顺序传参，必须放在位置参数后面）"></a>关键参数（实参输入时，不想按顺序传参，必须放在位置参数后面）</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello_world(&apos;m&apos;,age=22)</span><br></pre></td></tr></table></figure><h1 id="非固定参数"><a href="#非固定参数" class="headerlink" title="非固定参数"></a>非固定参数</h1><ul><li><p>打包数据为元组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def send_alert(msg,*args):</span><br><span class="line">for u in args:</span><br><span class="line">print(&apos;send alert to:&apos; u)</span><br><span class="line">send_alert(&apos;cpu&apos;,&apos;alex&apos;)</span><br><span class="line">send_alert(&apos;memory&apos;,&apos;alex&apos;,&apos;david&apos;)</span><br><span class="line">#如果想传列表中的元素，</span><br><span class="line">send_alert(&apos;hard_disk&apos;, *[&apos;alex&apos;,&apos;david&apos;])</span><br></pre></td></tr></table></figure></li><li><p>打包数据为字典(未定义的关键字参数)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def send_alert(msg,*args,**kwargs):</span><br><span class="line">print(name,args,kwargs)</span><br><span class="line">for u in args:</span><br><span class="line">print(&apos;send alert to:&apos; u)</span><br><span class="line">send_alert(&apos;cpu&apos;,&apos;alex&apos;,22,addr=&apos;山东&apos;,num=110)</span><br></pre></td></tr></table></figure></li></ul><h1 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h1><pre><code>return #返回结果，一个函数的终止</code></pre><h1 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h1><pre><code>定义在函数内部的变量函数内部可调用外部变量，不可以修改全局变量</code></pre><h1 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h1><pre><code>一级代码的变量</code></pre><h1 id="函数里修改全局变量"><a href="#函数里修改全局变量" class="headerlink" title="函数里修改全局变量"></a>函数里修改全局变量</h1><pre><code>global name = &quot;change to david&quot;一般不使用global</code></pre><h1 id="嵌套函数"><a href="#嵌套函数" class="headerlink" title="嵌套函数"></a>嵌套函数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def func1():</span><br><span class="line">print(&apos;david&apos;)</span><br><span class="line"></span><br><span class="line">def func2():</span><br><span class="line">print(&apos;eric&apos;)</span><br><span class="line">func2</span><br><span class="line"># 1. func1()</span><br><span class="line"># 函数内部可定义函数</span><br><span class="line"># 函数需要被调用才执行</span><br><span class="line"># 从内到外一级一级找变量</span><br></pre></td></tr></table></figure><h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><pre><code>一个函数就是一个作用域</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def func1():</span><br><span class="line">age = 18</span><br><span class="line">def func2():</span><br><span class="line">print(age)</span><br><span class="line">return func2</span><br><span class="line">#return func2()</span><br><span class="line">val = func1</span><br><span class="line">val()</span><br><span class="line">#函数名可以作为返回值</span><br></pre></td></tr></table></figure><h1 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h1><ul><li>匿名函数的关键字为lambda，冒号前面是行参 冒号后面是返回值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func = lambda x,y:x*y if x &lt; y else x/y# 声明一个匿名函数(最多三元运算),用一次就不用了</span><br><span class="line">data = [i for i in range(10)]</span><br><span class="line">list(map(lambda x:x*x, data))</span><br></pre></td></tr></table></figure></li></ul><h2 id="匿名函数的默认参数"><a href="#匿名函数的默认参数" class="headerlink" title="匿名函数的默认参数"></a>匿名函数的默认参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 匿名函数的默认参数(y=2)</span><br><span class="line">f = lambda x,y=2:x**y</span><br><span class="line">print(f(3))</span><br><span class="line">print(f(2,4))  ##如果传值则默认参数值不生效</span><br></pre></td></tr></table></figure><h2 id="匿名函数的可变参数：-args（可接收多个值）"><a href="#匿名函数的可变参数：-args（可接收多个值）" class="headerlink" title="匿名函数的可变参数： *args（可接收多个值）"></a>匿名函数的可变参数： *args（可接收多个值）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f = lambda *args:sum(args)</span><br><span class="line">print(f(1,2,3,45,6))</span><br></pre></td></tr></table></figure><h2 id="匿名函数的关键字参数：参数为字典"><a href="#匿名函数的关键字参数：参数为字典" class="headerlink" title="匿名函数的关键字参数：参数为字典"></a>匿名函数的关键字参数：参数为字典</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f = lambda **kwargs:kwargs.values()</span><br><span class="line">print(f(name=&apos;fentiao&apos;,age=10))</span><br></pre></td></tr></table></figure><h1 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h1><pre><code>函数作为参数,返回一个函数</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def func(x,y)</span><br><span class="line">return x*y</span><br><span class="line">def calc(x):</span><br><span class="line">#pass</span><br><span class="line">return x</span><br><span class="line">f = cal(func)</span><br><span class="line">print(f(5,9)</span><br></pre></td></tr></table></figure><h1 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h1><pre><code>import syssys.getrecursionlimit()sys.setrecursionlimit(1500)</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def recursion(n):</span><br><span class="line">print(n)</span><br><span class="line">recursion(n+1)</span><br></pre></td></tr></table></figure><pre><code>每执行一次函数，变量压到栈里，栈溢出</code></pre><img src="/2019/03/21/python-函数/函数调用的栈结构.png"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def cal(n):</span><br><span class="line">    v = int(n / 2)</span><br><span class="line">    print(v)</span><br><span class="line">    if v == 0:</span><br><span class="line">        return &quot;done&quot;</span><br><span class="line">    cal(v)</span><br><span class="line">    print(v)</span><br></pre></td></tr></table></figure><pre><code>1. 必须有明确的结束条件2. 进入更深一层递归，问题规模比上一次递归应减少3. 效率不高，会导致溢出</code></pre><h1 id="尾递归优化"><a href="#尾递归优化" class="headerlink" title="尾递归优化"></a>尾递归优化</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def cal1(n):</span><br><span class="line">    #n += 1</span><br><span class="line">    print(n)</span><br><span class="line">    if n &lt; 10:</span><br><span class="line">        return(cal1(n+1)) #返回函数本身，下一层递归跟上一层没有关系</span><br><span class="line">#    print(n)</span><br></pre></td></tr></table></figure><h1 id="内置方法"><a href="#内置方法" class="headerlink" title="内置方法"></a>内置方法</h1><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>abs()</td><td>dict()</td><td>help()</td><td>min()</td><td>setattr()</td></tr><tr><td>all()</td><td>dir()</td><td>hex()</td><td>next()</td><td>slice()</td></tr><tr><td>any()</td><td>divmod()</td><td>id()</td><td>object()</td><td>sorted()</td></tr><tr><td>ascii()</td><td>enumerate()</td><td>input()</td><td>oct()</td><td>staticmethod()</td></tr><tr><td>bin()</td><td>dir()</td><td>hex()</td><td>next()</td><td>slice()</td></tr><tr><td>bool()</td><td>exec()</td><td>isinstance()</td><td>ord()</td><td>sum()</td></tr><tr><td>bytearray()</td><td>filter()</td><td>issubclass()</td><td>pow()</td><td>super()</td></tr><tr><td>bytes()</td><td>float()</td><td>iter()</td><td>print()</td><td>tuple()</td></tr><tr><td>callable()</td><td>format()</td><td>len()</td><td>property()</td><td>type()</td></tr><tr><td>chr()</td><td>frozenset()</td><td>list()</td><td>range()</td><td>vars()</td></tr><tr><td>classmethod()</td><td>getattr()</td><td>locals()</td><td>repr()</td><td>zip()</td></tr><tr><td>compile()</td><td>globals()</td><td>map()</td><td>reversed()</td><td><strong>import</strong>()</td></tr><tr><td>complex()</td><td>hasattr()</td><td>max()</td><td>round()</td><td></td></tr><tr><td>delattr()</td><td>has()</td><td>memoryview()</td><td>set()</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">d= &#123;&#125;</span><br><span class="line">for i in range(20):</span><br><span class="line">d[i] = i-50</span><br><span class="line">d.items()</span><br><span class="line">sorted(d.items(),key = lambda x:x[1])</span><br></pre></td></tr></table></figure><ul><li><p>eval #处理单行代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f = &quot;1+3/2&quot;</span><br><span class="line">eval(f)</span><br></pre></td></tr></table></figure></li><li><p>exec #可执行多行代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code =</span><br></pre></td></tr></table></figure><p>  if x = 20:</p><pre><code>print(x)</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec(code)</span><br></pre></td></tr></table></figure></li><li><p>callable() 判断变量是否是函数</p></li><li>vars()    打印所有变量</li><li>locals()    打印局部变量</li><li>globals()</li><li>repr()    显示为字符串</li></ul><h1 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h1><ul><li>locals：包括局部变量和形参</li><li>globals： 全局变量</li><li>builtin：dir(<strong>builtins</strong>)内置模块的名字空间<br>  局部范围： 临时存活，局部有效<h1 id="作用域-1"><a href="#作用域-1" class="headerlink" title="作用域"></a>作用域</h1></li><li>LEGB 代表名字查找顺序：locals -&gt; enclosing function -&gt; globals -&gt; <strong>builtins</strong><br>  L:    locals是函数内的名字空间，包括局部变量和形参<br>  E:    enclosing 外部嵌套函数的名字空间<br>  G:    globals 全局变量，函数定义所在模块的名字空间<br>  B： builtins 内置模块的名字空间<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1>  内嵌子函数，返回子函数对象，该外层函数优先使用外层函数的作用域，但参数，内部变量并不释放。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def func():</span><br><span class="line"></span><br><span class="line">n = 10</span><br><span class="line">def func2():</span><br><span class="line">print(&quot;func2:&quot;, n)</span><br><span class="line">return func2</span><br><span class="line">f = func()</span><br><span class="line">print(f)</span><br><span class="line">f()</span><br></pre></td></tr></table></figure></li></ul><h1 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h1><pre><code>开放：对现有的功能的扩展开放封闭：对以实现的功能代码块不应该被修改</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">user_status = False</span><br><span class="line">def login():</span><br><span class="line">pass</span><br><span class="line">def home():</span><br><span class="line">print(&quot;首页&quot;)</span><br><span class="line">def america():</span><br><span class="line">login()#更改了函数，违反了“开放-封闭”原则</span><br><span class="line">print(&quot;美国&quot;)</span><br><span class="line">def japan():</span><br><span class="line">print(&quot;---日本---&quot;)</span><br></pre></td></tr></table></figure><pre><code>把要执行的函数作为参数传递</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def login(func):</span><br><span class="line">func()#改变了调用方式</span><br><span class="line">pass</span><br><span class="line">login(america)</span><br></pre></td></tr></table></figure><pre><code>匿名函数</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def login(func):</span><br><span class="line">func()#改变了调用方式</span><br><span class="line">pass</span><br><span class="line">america = login(america)</span><br><span class="line">#用户调用时</span><br><span class="line">america()</span><br><span class="line">#还是会触发执行login</span><br></pre></td></tr></table></figure><pre><code>嵌套函数</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def login(func):</span><br><span class="line">def inner():</span><br><span class="line">pass</span><br><span class="line">return inner</span><br><span class="line">america = login(america) # inner</span><br><span class="line">america()</span><br><span class="line"># 更简单的方法@login</span><br><span class="line">#def home():</span><br><span class="line">#print(&quot;首页&quot;)</span><br><span class="line">#@longin</span><br><span class="line">#def america():</span><br><span class="line">#print(&quot;美国&quot;)</span><br></pre></td></tr></table></figure><ul><li><p>带参数的装饰器(不固定参数)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def login():</span><br><span class="line">def inner(*args,**kwargs):</span><br><span class="line">pass</span><br><span class="line">return inner(*args,*kwargs)</span><br></pre></td></tr></table></figure></li><li><p>login带参数login(auth_type)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def login(auth_type):</span><br><span class="line">def outer(func):</span><br><span class="line">def inner(*args,*kwargs):</span><br><span class="line">pass</span><br><span class="line">return inner(*args,*kwargs)</span><br><span class="line">return outer()</span><br><span class="line">@login(&apos;qq)</span><br><span class="line">def japan():</span><br><span class="line">print(&quot;---日本---&quot;)</span><br></pre></td></tr></table></figure></li><li><p>@wraps()<br>将被装饰函数的<strong>name</strong>以及<strong>doc</strong>等属性绑定到了原函数的上面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from functools import wraps</span><br><span class="line">def wrapper(func):</span><br><span class="line">    print(&quot;this is a wrapper&quot;)</span><br><span class="line">    @wraps(func)</span><br><span class="line">    def inner():</span><br><span class="line">        print(func.__name__)</span><br><span class="line">        return func()</span><br><span class="line">    return inner</span><br><span class="line"></span><br><span class="line">@wrapper</span><br><span class="line">def work():</span><br><span class="line">    return 123</span><br><span class="line"></span><br><span class="line">print(work.__name__) # 显示work，去掉wrap显示inner</span><br><span class="line">work() # 显示work</span><br></pre></td></tr></table></figure></li></ul><h1 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h1><ul><li><p>列表生成式<br>  需求：列表[0, 1, 2, 3, 4, 5],每个值都加1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = [0, 1, 2, 3, 4, 5]</span><br><span class="line">a = [i+1 for i in a]</span><br></pre></td></tr></table></figure></li><li><p>生成器</p><blockquote><p>生成器是一个公式, 可支持复杂的算法</p></blockquote>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a2 = (i for i in range(100))</span><br><span class="line">next(a2)</span><br><span class="line">for i in a2: #不会报错</span><br><span class="line">print(i)</span><br></pre></td></tr></table></figure></li><li><p>Fibonacci<br>  1,1,2,3,5,8,13,21,34,…</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def fib(max):</span><br><span class="line">n, a, b = 0, 0, 1</span><br><span class="line">while n &lt; max:</span><br><span class="line">yield b #把函数执行过程冻结在这一步， 并且把b的值返回</span><br><span class="line">a, b = b, a + b</span><br><span class="line">n = n + 1</span><br><span class="line">return &apos;done&apos;</span><br><span class="line">f = fib(15)</span><br><span class="line">next(f)</span><br><span class="line">for i in f:</span><br><span class="line">print(i)</span><br></pre></td></tr></table></figure><p>  函数有了yield之后，函数就得到了一个生成器<br>  return在生成器中，代表生成器的终止，直接报错</p></li><li>生成器终止<br>  send 唤醒并继续执行，发送一个信息到生成器内部，send(None)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sign = yield count</span><br><span class="line">if sign == &apos;stop&apos;:</span><br><span class="line">break</span><br><span class="line">func.send(&apos;stop&apos;)</span><br></pre></td></tr></table></figure></li></ul><h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><ul><li><p>Iterable<br>  可以直接用于for循环的情形有以下几种<br>  字符串    str<br>  集合数据类型， 如 list、tuple、dict、set<br>  generator，包括生成器和带yield的generator function<br>  这些统称为可迭代对象：Iterable<br>  可以使用isinstance()是否是Iterable对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">form collections import Iterable</span><br><span class="line">isinstance(1,Iterable)</span><br></pre></td></tr></table></figure></li><li><p>Iterator<br>  可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from collections import Iterator</span><br><span class="line">isinstance((x for x in range(10), Iterator)</span><br><span class="line">isinstance([], Iterator)</span><br></pre></td></tr></table></figure></li><li><p>把list、dict、str变成迭代器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iter(&apos;abc&apos;)</span><br></pre></td></tr></table></figure><p>  迭代器是一个数据流，没有终止，不能提前知道序列的长度，是惰性的计算，通过next()计算下一个数据。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;实参形参&quot;&gt;&lt;a href=&quot;#实参形参&quot; class=&quot;headerlink&quot; title=&quot;实参形参&quot;&gt;&lt;/a&gt;实参形参&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;形参只在函数内部有效
&lt;/code&gt;&lt;/pre&gt;&lt;img src=&quot;/2019/03/21/python-函
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
      <category term="函数" scheme="http://yoursite.com/categories/Python/%E5%87%BD%E6%95%B0/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Ch2" scheme="http://yoursite.com/tags/Ch2/"/>
    
      <category term="函数" scheme="http://yoursite.com/tags/%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>python 文件处理</title>
    <link href="http://yoursite.com/2019/03/21/python%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/"/>
    <id>http://yoursite.com/2019/03/21/python文件读写/</id>
    <published>2019-03-21T10:32:36.000Z</published>
    <updated>2019-04-23T07:25:58.318Z</updated>
    
    <content type="html"><![CDATA[<h1 id="三元运算"><a href="#三元运算" class="headerlink" title="三元运算"></a>三元运算</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = 2</span><br><span class="line">b = 3</span><br><span class="line">val = a if a &lt; b else b</span><br></pre></td></tr></table></figure><h1 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f = open(file=&apos;d:/hello.txt&apos;,mode=&apos;r,encoding=&apos;utf-8&apos;)</span><br><span class="line">data = f.read()</span><br><span class="line">f.close</span><br></pre></td></tr></table></figure><ul><li>二进制模式<br>  mode = b</li></ul><h1 id="智能检测编码-chardet"><a href="#智能检测编码-chardet" class="headerlink" title="智能检测编码 chardet"></a>智能检测编码 chardet</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import chardet</span><br><span class="line">f = open(&apos;log&apos;,mode=&apos;rb&apos;)</span><br><span class="line">data = f.read()</span><br><span class="line">f.close()</span><br><span class="line">result = chardet.detect(data)</span><br><span class="line">print(result)</span><br><span class="line">data.decode(&quot;gb2312&quot;)</span><br></pre></td></tr></table></figure><ul><li>安装<br>  pip3 install chardet<h1 id="大文件处理"><a href="#大文件处理" class="headerlink" title="大文件处理"></a>大文件处理</h1></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f = open(&quot;log&quot;,&apos;r&apos;,encoding=&quot;gbk&quot;)</span><br><span class="line">for line in f:</span><br><span class="line">print(line)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><h1 id="写文件-创建新文件，清空数据"><a href="#写文件-创建新文件，清空数据" class="headerlink" title="写文件(创建新文件，清空数据)"></a>写文件(创建新文件，清空数据)</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f = open(&apos;log&apos;,&apos;w&apos;,encoding=&apos;gbk&apos;)</span><br><span class="line">f.write(&quot;helow&quot;)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><ul><li>二进制写</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f = open(&apos;log&apos;,&apos;wb&apos;)</span><br><span class="line">f.write(&quot;helow&quot;,encoding=&apos;gbk&apos;)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><h1 id="追加文件"><a href="#追加文件" class="headerlink" title="追加文件"></a>追加文件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f = open(&apos;log&apos;,&apos;ab&apos;)</span><br><span class="line">f.write(&quot;hellow&quot;,encoding=&apos;gbk&apos;)</span><br><span class="line">f.close</span><br></pre></td></tr></table></figure><h1 id="混合读写"><a href="#混合读写" class="headerlink" title="混合读写"></a>混合读写</h1><ul><li><p>读写模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f = open(&apos;log&apos;, &apos;r+&apos;)</span><br><span class="line">f.read()</span><br><span class="line">f.write(&quot;hello&quot;)</span><br></pre></td></tr></table></figure></li><li><p>写读模式（清空原文件），几乎无用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f = open(&apos;log&apos;, &apos;w+&apos;)</span><br><span class="line">f.read()</span><br><span class="line">f.write(&quot;hello&quot;)</span><br></pre></td></tr></table></figure></li></ul><h1 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h1><p>flush    #强制把内存刷新到硬盘<br>read    #按字符读<br>tell    #当前文件光标位置，按字节来度<br>seek    #改变光标位置，按字节读<br>truncate    #按当前位置截断文件（3,6） 6-&gt;从头开始截取6个</p><h1 id="文件修改（占内存或占硬盘）"><a href="#文件修改（占内存或占硬盘）" class="headerlink" title="文件修改（占内存或占硬盘）"></a>文件修改（占内存或占硬盘）</h1><ul><li><p>占硬盘<br>f1 = “log.txt”<br>f_new = “log_new.txt”<br>old_str = “alex”<br>new_str = “david”<br>f = open(f1,”r”,encoding=”utf-8”)<br>f_new = open(f_new,”w”,encoding=”utf-8”)<br>for line in f:<br>  if old_str in line:</p><pre><code>line = line.replace(old_str,new_str)</code></pre><p>  f_new.write(line)<br>f.close()<br>f_new.close()<br>os.rename(f_new,f1)</p></li><li><p>占内存</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;三元运算&quot;&gt;&lt;a href=&quot;#三元运算&quot; class=&quot;headerlink&quot; title=&quot;三元运算&quot;&gt;&lt;/a&gt;三元运算&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="文件" scheme="http://yoursite.com/tags/%E6%96%87%E4%BB%B6/"/>
    
      <category term="Ch2" scheme="http://yoursite.com/tags/Ch2/"/>
    
  </entry>
  
  <entry>
    <title>python 常用模块</title>
    <link href="http://yoursite.com/2019/03/21/python-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    <id>http://yoursite.com/2019/03/21/python-常用模块/</id>
    <published>2019-03-21T10:32:36.000Z</published>
    <updated>2019-05-04T11:48:42.877Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><pre><code>python中，一个py文件就是一个模块避免函数名和变量名冲突。提高代码可维护性，可重用</code></pre><h1 id="模块分类"><a href="#模块分类" class="headerlink" title="模块分类"></a>模块分类</h1><p>模块分三种</p><ul><li>内置标准模块（又称标准库）执行help(‘modules’)查看所有python自带模块列表</li><li>第三方开源模块，可通过pip install 模块名 安装</li><li>自定义模块<br>  模块一旦被调用，执行了文件里的程序<h1 id="模块安装"><a href="#模块安装" class="headerlink" title="模块安装"></a>模块安装</h1></li><li>模块路径<br>  sys.path</li><li>卸载模块<br>  pip3 uninstall modules</li><li>国内源安装<br>  pip3 install -i <a href="http://pypi.douban.com/simple/" target="_blank" rel="noopener">http://pypi.douban.com/simple/</a> modules –trusted-host pypi.douban.com</li></ul><h1 id="模块导入"><a href="#模块导入" class="headerlink" title="模块导入"></a>模块导入</h1><pre><code>执行文件的目录为当前目录python2中文件夹中增加__init__.py,将文件夹变成包</code></pre><ul><li>导入路径，动态识别当前路径<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import sys,os</span><br><span class="line">print(dir())</span><br><span class="line">print(__file__)</span><br><span class="line">#相对路径</span><br><span class="line">#BASE_DIR = os.path.dirname(os.path.dirname(__file__))</span><br><span class="line">#sys.path.append()</span><br><span class="line">#绝对路径</span><br><span class="line">os.path.abspath(__file__)</span><br><span class="line">BASE_DIR = os.path.dirname(os.path.abspath(__file__))</span><br><span class="line">sys.path.append(BASE_DIR)</span><br><span class="line">#相对路径 </span><br><span class="line"># from . import models</span><br><span class="line"># 相对导入不能存在程序主入口</span><br></pre></td></tr></table></figure></li></ul><h1 id="time与datetime模块"><a href="#time与datetime模块" class="headerlink" title="time与datetime模块"></a>time与datetime模块</h1><p>在python中，通常3种时间的表示</p><ul><li>时间戳(timestamp)：通常来说，时间戳表示的是从1970年1月1日00:00:00开始按秒计算的偏移量。我们运行“type(time.time())”，返回的是float类型。</li><li>格式化的时间字符串(Format String)</li><li><p>结构化的时间(struct_time)：struct_time元组共有9个元素共九个元素:(年，月，日，时，分，秒，一年中第几周，一年中第几天，夏令时)</p><img src="/2019/03/21/python-常用模块/时间转换.jpg"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">print(time.time())</span><br><span class="line"># 时间戳:1546273960.5988934</span><br><span class="line"> </span><br><span class="line">print(time.localtime())</span><br><span class="line">#本地时区的struct_time  time.struct_time(tm_year=2019, tm_mon=1, tm_mday=1, tm_hour=0, tm_min=32, tm_sec=40, tm_wday=1, tm_yday=1, tm_isdst=0)</span><br><span class="line">print(time.localtime(1546273960.5988934))</span><br><span class="line">#time.struct_time(tm_year=2019, tm_mon=1, tm_mday=1, tm_hour=0, tm_min=32, tm_sec=40, tm_wday=1, tm_yday=1, tm_isdst=0)</span><br><span class="line"> </span><br><span class="line">print(time.gmtime())</span><br><span class="line">#UTC时区的struct_time   time.struct_time(tm_year=2018, tm_mon=12, tm_mday=31, tm_hour=16, tm_min=32, tm_sec=40, tm_wday=0, tm_yday=365, tm_isdst=0)</span><br><span class="line">print(time.gmtime(1546273960.5988934))</span><br><span class="line">#UTC时区的struct_time   time.struct_time(tm_year=2018, tm_mon=12, tm_mday=31, tm_hour=16, tm_min=32, tm_sec=40, tm_wday=0, tm_yday=365, tm_isdst=0)</span><br><span class="line"> </span><br><span class="line">print(time.mktime(time.localtime()))</span><br><span class="line">#将一个结构化struct_time转化为时间戳。#1546274313.0</span><br><span class="line"> </span><br><span class="line">print(time.strftime(&quot;%Y-%m-%d %X&quot;))</span><br><span class="line">#格式化的时间字符串:&apos;2019-01-01 00:32:40&apos;</span><br><span class="line">print(time.strftime(&quot;%Y-%m-%d %X&quot;, time.localtime()))</span><br><span class="line">#格式化的时间字符串:&apos;2019-01-01 00:32:40&apos;</span><br><span class="line"> </span><br><span class="line">print(time.strptime(&apos;2018-08-08 16:37:06&apos;, &apos;%Y-%m-%d %X&apos;))</span><br><span class="line">#把一个格式化时间字符串转化为struct_time。实际上它和strftime()是逆操作。 time.struct_time(tm_year=2018, tm_mon=8, tm_mday=8, tm_hour=16, tm_min=37, tm_sec=6, tm_wday=2, tm_yday=220, tm_isdst=-1)</span><br><span class="line">#%z</span><br><span class="line">#%Z</span><br><span class="line">#%w</span><br><span class="line">#%U</span><br><span class="line">#%p</span><br><span class="line">time.sleep(5)#线程推迟指定的时间运行，单位为秒。</span><br></pre></td></tr></table></figure></li><li><p>asctime/ctime</p><img src="/2019/03/21/python-常用模块/ctime.jpg"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">print(time.asctime())#Tue Jan  1 00:53:00 2019</span><br><span class="line">print(time.asctime(time.localtime()))#Tue Jan  1 00:55:00 2019</span><br><span class="line"> </span><br><span class="line">print(time.ctime())  # Tue Jan  1 00:53:00 2019</span><br><span class="line">print(time.ctime(time.time()))  # Tue Jan  1 00:53:00 2019</span><br></pre></td></tr></table></figure></li></ul><img src="/2019/03/21/python-常用模块/时间转换2.png"><ul><li>时间加减<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import datetime,time</span><br><span class="line"> </span><br><span class="line">print(datetime.datetime.now()) #返回 2019-01-01 00:56:58.771296</span><br><span class="line">print(datetime.date.fromtimestamp(time.time()) )  # 时间戳直接转成日期格式 2019-01-01</span><br><span class="line"> </span><br><span class="line">print(datetime.datetime.now() + datetime.timedelta(3)) #当前时间+3天  2019-01-04 00:56:58.771296</span><br><span class="line">print(datetime.datetime.now() + datetime.timedelta(-3)) #当前时间-3天 2018-12-29 00:56:58.771296</span><br><span class="line">print(datetime.datetime.now() + datetime.timedelta(hours=3)) #当前时间+3小时  2019-01-01 03:56:58.771296</span><br><span class="line">print(datetime.datetime.now() + datetime.timedelta(minutes=30)) #当前时间+30分  2019-01-01 01:26:58.771296</span><br><span class="line"> </span><br><span class="line">c_time  = datetime.datetime.now()</span><br><span class="line">print(c_time.replace(minute=3,hour=2)) #时间替换  2019-01-01 02:03:58.771296</span><br></pre></td></tr></table></figure></li></ul><h1 id="random模块"><a href="#random模块" class="headerlink" title="random模块"></a>random模块</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line">print(random.random())  # (0,1)----float    大于0且小于1之间的小数</span><br><span class="line">print(random.randint(1, 3))  # [1,3]    大于等于1且小于等于3之间的整数</span><br><span class="line">print(random.randrange(1, 3))  # [1,3)    大于等于1且小于3之间的整数</span><br><span class="line">print(random.choice([1, &apos;23&apos;, [4, 5]]))  # 1或者23或者[4,5]</span><br><span class="line">print(random.sample([1, &apos;23&apos;, [4, 5]], 2))  # 列表元素任意2个组合</span><br><span class="line">print(random.uniform(1, 3))  # 大于1小于3的小数，如1.927109612082716</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line">def make_code(n):</span><br><span class="line">    res=&apos;&apos;</span><br><span class="line">    for i in range(n):</span><br><span class="line">        alf=chr(random.randint(65,90))</span><br><span class="line">        num=str(random.randint(0,9))</span><br><span class="line">        res+=random.choice([alf,num])</span><br><span class="line">    return res</span><br><span class="line"> </span><br><span class="line">print(make_code(6))</span><br></pre></td></tr></table></figure><h1 id="os模块"><a href="#os模块" class="headerlink" title="os模块"></a>os模块</h1><p>os模块是与操作系统交互的一个接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">os.getcwd() 获取当前工作目录，即当前python脚本工作的目录路径</span><br><span class="line">os.chdir(&quot;dirname&quot;)  改变当前脚本工作目录；相当于shell下cd</span><br><span class="line">os.curdir  返回当前目录: (&apos;.&apos;)</span><br><span class="line">os.pardir  获取当前目录的父目录字符串名：(&apos;..&apos;)</span><br><span class="line">os.makedirs(&apos;dirname1/dirname2&apos;)    可生成多层递归目录</span><br><span class="line">os.removedirs(&apos;dirname1&apos;)    若目录为空，则删除，并递归到上一级目录，如若也为空，则删除，依此类推</span><br><span class="line">os.mkdir(&apos;dirname&apos;)    生成单级目录；相当于shell中mkdir dirname ，默认权限777</span><br><span class="line">os.rmdir(&apos;dirname&apos;)    删除单级空目录，若目录不为空则无法删除，报错；相当于shell中rmdir dirname</span><br><span class="line">os.listdir(&apos;dirname&apos;)    列出指定目录下的所有文件和子目录，包括隐藏文件，并以列表方式打印</span><br><span class="line">os.remove()  删除一个文件</span><br><span class="line">os.rename(&quot;oldname&quot;,&quot;newname&quot;)  重命名文件/目录， 无返回值</span><br><span class="line">os.stat(&apos;path/filename&apos;)  获取文件/目录信息</span><br><span class="line">os.sep    输出操作系统特定的路径分隔符，win下为&quot;\\&quot;,Linux下为&quot;/&quot;</span><br><span class="line">os.linesep    输出当前平台使用的行终止符，win下为&quot;\t\n&quot;,Linux下为&quot;\n&quot;</span><br><span class="line">os.pathsep    输出用于分割文件路径的字符串 win下为;,Linux下为:</span><br><span class="line">os.name    输出字符串指示当前使用平台。win-&gt;&apos;nt&apos;; Linux-&gt;&apos;posix&apos;</span><br><span class="line">os.system(&quot;bash command&quot;)  运行shell命令，直接显示</span><br><span class="line">os.environ  获取系统环境变量</span><br><span class="line">os.path.abspath(path)  返回path规范化的绝对路径</span><br><span class="line">os.path.split(path)  将path分割成目录和文件名二元组返回</span><br><span class="line">os.path.dirname(path)  返回path的目录。其实就是os.path.split(path)的第一个元素</span><br><span class="line">os.path.basename(path)  返回path最后的文件名。如何path以／或\结尾，那么就会返回空值。即os.path.split(path)的第二个元素</span><br><span class="line">os.path.exists(path)  如果path存在，返回True；如果path不存在，返回False</span><br><span class="line">os.path.isabs(path)  如果path是绝对路径，返回True</span><br><span class="line">os.path.isfile(path)  如果path是一个存在的文件，返回True。否则返回False</span><br><span class="line">os.path.isdir(path)  如果path是一个存在的目录，则返回True。否则返回False</span><br><span class="line">os.path.join(path1[, path2[, ...]])  将多个路径组合后返回，第一个绝对路径之前的参数将被忽略</span><br><span class="line">print(os.path.join(&quot;D:\\python\\wwww&quot;,&quot;aaa&quot;))   #做路径拼接用的 #D:\python\wwww\aaa</span><br><span class="line">print(os.path.join(r&quot;D:\python\wwww&quot;,&quot;aaa&quot;))   #做路径拼接用的 #D:\python\wwww\aaa</span><br><span class="line">os.path.getatime(path)  返回path所指向的文件或者目录的最后存取时间</span><br><span class="line">os.path.getmtime(path)  返回path所指向的文件或者目录的最后修改时间</span><br><span class="line">os.path.getsize(path) 返回path的大小</span><br><span class="line">在Linux和Mac平台上，该函数会原样返回path，在windows平台上会将路径中所有字符转换为小写，并将所有斜杠转换为饭斜杠。</span><br><span class="line">&gt;&gt;&gt; os.path.normcase(&apos;c:/windows\\system32\\&apos;)  </span><br><span class="line">&apos;c:\\windows\\system32\\&apos;  </span><br><span class="line">    </span><br><span class="line"> </span><br><span class="line">规范化路径，如..和/</span><br><span class="line">&gt;&gt;&gt; os.path.normpath(&apos;c://windows\\System32\\../Temp/&apos;)  </span><br><span class="line">&apos;c:\\windows\\Temp&apos;  </span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; a=&apos;/Users/jieli/test1/\\\a1/\\\\aa.py/../..&apos;</span><br><span class="line">&gt;&gt;&gt; print(os.path.normpath(a))</span><br><span class="line">/Users/jieli/test1</span><br><span class="line">os路径处理</span><br><span class="line">#方式一：推荐使用</span><br><span class="line">import os</span><br><span class="line">#具体应用</span><br><span class="line">import os,sys</span><br><span class="line">possible_topdir = os.path.normpath(os.path.join(</span><br><span class="line">    os.path.abspath(__file__),</span><br><span class="line">    os.pardir, #上一级</span><br><span class="line">    os.pardir,</span><br><span class="line">    os.pardir</span><br><span class="line">))</span><br><span class="line">sys.path.insert(0,possible_topdir)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">#方式二：不推荐使用</span><br><span class="line">os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))</span><br></pre></td></tr></table></figure></p><h1 id="sys模块"><a href="#sys模块" class="headerlink" title="sys模块"></a>sys模块</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">sys.version</span><br><span class="line">sys.maxsize</span><br><span class="line">sys.path</span><br><span class="line">sys.platform</span><br><span class="line">sys.stdout.write(&apos;hey world&apos;)</span><br><span class="line">val = sys.stdin.readline()[:-1]</span><br><span class="line">sys.getrecursionlimit()</span><br><span class="line">sys.setrecursionlimit(2000)</span><br><span class="line">sys.getdefaultencoding()</span><br><span class="line">sys.getfilesystemencoding() #文件的默认编码</span><br></pre></td></tr></table></figure><h1 id="shutil模块"><a href="#shutil模块" class="headerlink" title="shutil模块"></a>shutil模块</h1><p>高级的 文件、文件夹、压缩包 处理模块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import shutil</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">高级的 文件、文件夹、压缩包 处理模块</span><br><span class="line">shutil.copyfileobj(fsrc, fdst[, length])</span><br><span class="line">将文件内容拷贝到另一个文件中,可以指定部分长度内容copy,直到结束</span><br></pre></td></tr></table></figure></p><p>import shutil<br>f1 = open(“source.py”,’r’)<br>f2 = open(“new.py”,’w’)<br>shutil.copyfileobj(f1,f2)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">shutil.copyfile(src, dst)</span><br><span class="line">拷贝文件,</span><br><span class="line"> </span><br><span class="line">shutil.copymode(src, dst)</span><br><span class="line">仅拷贝权限。内容、组、用户均不变</span><br><span class="line"> </span><br><span class="line">shutil.copystat(src, dst)</span><br><span class="line">仅拷贝状态的信息，包括：mode bits, atime创建时间, mtime修改时间, flags</span><br><span class="line"> </span><br><span class="line">shutil.copy(src, dst)</span><br><span class="line">拷贝文件和权限</span><br><span class="line"> </span><br><span class="line">shutil.copy2(src, dst)</span><br><span class="line">拷贝文件和状态信息</span><br><span class="line"> </span><br><span class="line">shutil.ignore_patterns(*patterns)</span><br><span class="line">shutil.copytree(src, dst, symlinks=False, ignore=None)</span><br><span class="line">递归的去拷贝文件夹</span><br><span class="line"> </span><br><span class="line">shutil.move(src, dst)</span><br><span class="line">递归的去移动文件，它类似mv命令，其实就是重命名。</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"> </span><br><span class="line">shutil.copyfileobj(open(&apos;xmltest.xml&apos;,&apos;r&apos;), open(&apos;new.xml&apos;, &apos;w&apos;))</span><br><span class="line">shutil.copyfile(&apos;b.txt&apos;, &apos;bnew.txt&apos;)#目标文件无需存在</span><br><span class="line">shutil.copymode(&apos;f1.log&apos;, &apos;f2.log&apos;) #目标文件必须存在</span><br><span class="line">shutil.copystat(&apos;f1.log&apos;, &apos;f2.log&apos;) #目标文件必须存在</span><br><span class="line">shutil.copy(&apos;f1.log&apos;, &apos;f2.log&apos;)</span><br><span class="line">shutil.copy2(&apos;f1.log&apos;, &apos;f2.log&apos;)</span><br><span class="line">shutil.copytree(&apos;folder1&apos;, &apos;folder2&apos;, ignore=shutil.ignore_patterns(&apos;*.pyc&apos;, &apos;tmp*&apos;)) #目标目录不能存在，注意对folder2目录父级目录要有可写权限，ignore的意思是排除</span><br><span class="line"> </span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">通常的拷贝都把软连接拷贝成硬链接，即对待软连接来说，创建新的文件</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">#拷贝软连接</span><br><span class="line">shutil.copytree(&apos;f1&apos;, &apos;f2&apos;, symlinks=True, ignore=shutil.ignore_patterns(&apos;*.pyc&apos;, &apos;tmp*&apos;))</span><br><span class="line"> </span><br><span class="line">shutil.move(&apos;folder1&apos;, &apos;folder3&apos;)</span><br><span class="line"> </span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">shutil.make_archive(base_name, format,...)</span><br><span class="line">创建压缩包并返回文件路径，例如：zip、tar</span><br><span class="line">base_name： 压缩包的文件名，也可以是压缩包的路径。只是文件名时，则保存至当前目录，否则保存至指定路径，</span><br><span class="line">如 data_bak                       =&gt;保存至当前路径</span><br><span class="line">如：/tmp/data_bak =&gt;保存至/tmp/</span><br><span class="line">format： 压缩包种类，“zip”, “tar”, “bztar”，“gztar”</span><br><span class="line">root_dir：   要压缩的文件夹路径（默认当前目录）</span><br><span class="line">owner：  用户，默认当前用户</span><br><span class="line">group：  组，默认当前组</span><br><span class="line">logger： 用于记录日志，通常是logging.Logger对象</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"> </span><br><span class="line"># 将 /data 下的文件打包放置当前程序目录</span><br><span class="line">import shutil</span><br><span class="line">ret = shutil.make_archive(&quot;data_bak&quot;, &apos;gztar&apos;, root_dir=&apos;/data&apos;)</span><br><span class="line"># 将 /data下的文件打包放置 /tmp/目录</span><br><span class="line">import shutil</span><br><span class="line">ret = shutil.make_archive(&quot;/tmp/data_bak&quot;, &apos;gztar&apos;, root_dir=&apos;/data&apos;)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">#shutil 对压缩包的处理是调用 ZipFile 和 TarFile 两个模块来进行的，详细：</span><br><span class="line"> </span><br><span class="line">#zipfile压缩解压缩</span><br><span class="line">import zipfile</span><br><span class="line"># 压缩</span><br><span class="line">z = zipfile.ZipFile(&apos;laxi.zip&apos;, &apos;w&apos;)</span><br><span class="line">z.write(&apos;a.log&apos;)</span><br><span class="line">z.write(&apos;data.data&apos;)</span><br><span class="line">z.close()</span><br><span class="line"> </span><br><span class="line"># 解压</span><br><span class="line">z = zipfile.ZipFile(&apos;laxi.zip&apos;, &apos;r&apos;)</span><br><span class="line">z.extractall(path=&apos;.&apos;)</span><br><span class="line">z.close()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">#tarfile压缩解压缩</span><br><span class="line">import tarfile</span><br><span class="line"> </span><br><span class="line"># 压缩</span><br><span class="line">t=tarfile.open(&apos;/tmp/egon.tar&apos;,&apos;w&apos;)</span><br><span class="line">t.add(&apos;/test1/a.py&apos;,arcname=&apos;a.bak&apos;)</span><br><span class="line">t.add(&apos;/test1/b.py&apos;,arcname=&apos;b.bak&apos;)</span><br><span class="line">t.close()</span><br><span class="line"> </span><br><span class="line"># 解压</span><br><span class="line">t=tarfile.open(&apos;/tmp/egon.tar&apos;,&apos;r&apos;)</span><br><span class="line">t.extractall(&apos;/egon&apos;)</span><br><span class="line">t.close()</span><br></pre></td></tr></table></figure></p><h1 id="序列化模块"><a href="#序列化模块" class="headerlink" title="序列化模块"></a>序列化模块</h1><ul><li>什么是序列化<br>  内存里的数据转成字符串，存到硬盘或者网络传输。我们把对象(变量)从内存中变成可存储或传输的过程称之为序列化，在Python中叫pickling，在其他语言中也被称之为serialization，marshalling，flattening等等，都是一个意思。</li><li><p>为什么要序列化<br>  dict等对象无法保存到硬盘上<br>  持久保持状态<br>  跨平台数据交互</p></li><li><p>什么是反序列化<br>把变量字符内容从序列化的对象重新读到内存里称之为反序列化</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">data = &#123;&apos;students&apos;:[</span><br><span class="line">&#123;&apos;name&apos;:&apos;zhangsan,&apos;age&apos;:20&#125;</span><br><span class="line">&#123;&apos;name&apos;:&apos;lisi&apos;,&apos;age&apos;:25&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">f = open(&quot;school&quot;,&quot;w&quot;)</span><br><span class="line">f.write(str(data))</span><br><span class="line">f.close()</span><br><span class="line">f = open(&quot;school&quot;,&apos;r&apos;)</span><br><span class="line">d = f.read()</span><br><span class="line">d = eval(d)</span><br><span class="line">print(d[&apos;roles&apos;])</span><br></pre></td></tr></table></figure><p>eval内置方法可以将一个字符串转成python对象，不过，eval方法是有局限性的，对于普通的数据类型，json.loads和eval都能用，但遇到特殊类型的时候，eval就不管用了,所以eval的重点还是通常用来执行一个字符串表达式，并返回表达式的值。<br>    如果我们要在不同的编程语言之间传递对象，就必须把对象序列化为标准格式，比如XML，但更好的方法是序列化为JSON，因为JSON表示出来就是一个字符串，可以被所有语言读取，也可以方便地存储到磁盘或者通过网络传输。<br>    JSON不仅是标准格式，并且比XML更快，而且可以直接在Web页面中读取，非常方便。</p><h2 id="json模块"><a href="#json模块" class="headerlink" title="json模块"></a>json模块</h2><ul><li>JSON表示的对象就是标准的JavaScript语言的对象，JSON和Python内置的数据类型对应如下：</li></ul><table><thead><tr><th>json类型</th><th>python类型</th></tr></thead><tbody><tr><td>{}</td><td>dict</td></tr><tr><td>[]</td><td>list</td></tr><tr><td>()</td><td>tuple</td></tr><tr><td>“string”</td><td>str</td></tr><tr><td>1234.56</td><td>int or float</td></tr><tr><td>true/false</td><td>True/False</td></tr><tr><td>null</td><td>None</td></tr></tbody></table><ul><li>json.dumps(data) json.loads#转换成字符串到内存中<blockquote><p>把你的内存数据 通过网络 共享给远程其它人<br>跨平台、跨语言共享数据</p></blockquote></li><li><p>转换成字符存储到文件中</p><blockquote><p>f = file.open(“data.json”,”w”)<br>json.dump(data,f)</p></blockquote></li><li><p>读取文件的数据</p><blockquote><p>f = open(“data.json”,”r”)<br>data = json.load(f)</p></blockquote></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">dumps,loads</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">import json</span><br><span class="line"> </span><br><span class="line">dic = &#123;&apos;name&apos;: &apos;tom&apos;, &apos;age&apos;: 18, &apos;sex&apos;: &apos;male&apos;&#125;</span><br><span class="line">print(type(dic))  # &lt;class &apos;dict&apos;&gt;</span><br><span class="line"> </span><br><span class="line">j = json.dumps(dic)</span><br><span class="line">print(type(j))  # &lt;class &apos;str&apos;&gt;</span><br><span class="line"> </span><br><span class="line">f = open(&apos;序列化对象&apos;, &apos;w&apos;)</span><br><span class="line">f.write(j)  #等价于json.dump(dic,f)</span><br><span class="line">f.close()</span><br><span class="line">#反序列化</span><br><span class="line">import json</span><br><span class="line">f = open(&apos;序列化对象&apos;)</span><br><span class="line">data = json.loads(f.read())  # 等价于data=json.load(f)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">无论数据是怎样创建的，只要满足json格式，就可以json.loads出来,不一定非要dumps的数据才能loads</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">import json</span><br><span class="line">dct=&quot;&#123;&apos;1&apos;:111&#125;&quot;#报错,json 不认单引号</span><br><span class="line">dct=str(&#123;&quot;1&quot;:&quot;111&quot;&#125;)#报错,因为生成的数据还是单引号:&#123;&apos;1&apos;: &apos;111&apos;&#125;</span><br><span class="line">print(dct)  #&#123;&apos;1&apos;: &apos;111&apos;&#125;</span><br><span class="line"> </span><br><span class="line">dct=str(&apos;&#123;&quot;1&quot;:&quot;111&quot;&#125;&apos;)#正确写法</span><br><span class="line">dct=&apos;&#123;&quot;1&quot;:&quot;111&quot;&#125;&apos;#正确写法</span><br><span class="line">print(json.loads(dct))</span><br></pre></td></tr></table></figure><pre><code>json模块只能序列化int,str,list,dict,tuple五种类型ensure_ascii参数还是比较常用的，当该参数的值 为True（默认值）时，输出中的所有非ASCII字符（比如中文）都会被转义成&apos;\uXXXX&apos;组成的序 列，所以设置为Flase就可以保留中文字符。sort_keys参数表示序列化时是否对dict的key进行排序indent参数可以设置数据存储的格式separators参数也可以优化数据存储格式，重新指定分隔符，从而去除无用的空白字符</code></pre><h2 id="pickle"><a href="#pickle" class="headerlink" title="pickle"></a>pickle</h2><p>Pickle的问题和所有其他编程语言特有的序列化问题一样，就是它只能用于Python，支持python所有的数据类型，有可能不同版本的Python彼此都不兼容，因此，只能用Pickle保存那些不重要的数据，不能成功地反序列化也没关系。<br>可序列化所有类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import pickle</span><br><span class="line">dic = &#123;&apos;name&apos;: &apos;tom&apos;, &apos;age&apos;: 23, &apos;sex&apos;: &apos;male&apos;&#125;</span><br><span class="line">print(type(dic))  # &lt;class &apos;dict&apos;&gt;</span><br><span class="line"> </span><br><span class="line">j = pickle.dumps(dic)</span><br><span class="line">print(type(j))  # &lt;class &apos;bytes&apos;&gt;</span><br><span class="line"> </span><br><span class="line">f = open(&apos;序列化对象_pickle&apos;, &apos;wb&apos;)  # 注意是w是写入str,wb是写入bytes,j是&apos;bytes&apos;</span><br><span class="line">f.write(j)  #-等价于pickle.dump(dic,f)</span><br><span class="line"> </span><br><span class="line">f.close()</span><br><span class="line"> </span><br><span class="line"># 反序列化</span><br><span class="line">import pickle</span><br><span class="line">f = open(&apos;序列化对象_pickle&apos;, &apos;rb&apos;)</span><br><span class="line">data = pickle.loads(f.read())  # 等价于data=pickle.load(f)</span><br><span class="line">print(data[&apos;age&apos;])</span><br></pre></td></tr></table></figure></p><h2 id="shelve模块"><a href="#shelve模块" class="headerlink" title="shelve模块"></a>shelve模块</h2><p>shelve模块比pickle模块简单，只有一个open函数，返回类似字典的对象，可读可写;key必须为字符串，而值可以是python所支持的数据类型<br>支持多次序列化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import shelve</span><br><span class="line">f=shelve.open(r&apos;sheve.txt&apos;)</span><br><span class="line">#存</span><br><span class="line"># f[&apos;stu1_info&apos;]=&#123;&apos;name&apos;:&apos;rose&apos;,&apos;age&apos;:18,&apos;hobby&apos;:[&apos;sing&apos;,&apos;talk&apos;,&apos;swim&apos;]&#125;</span><br><span class="line"># f[&apos;stu2_info&apos;]=&#123;&apos;name&apos;:&apos;tom&apos;,&apos;age&apos;:53&#125;</span><br><span class="line">#取</span><br><span class="line">print(f[&apos;stu1_info&apos;][&apos;hobby&apos;])</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure></p><h2 id="xml模块"><a href="#xml模块" class="headerlink" title="xml模块"></a>xml模块</h2><p>xml是实现不同语言或程序之间进行数据交换的协议，跟json差不多，但json使用起来更简单，不过，古时候，在json还没诞生的黑暗年代，大家只能选择用xml呀，至今很多传统公司如金融行业的很多系统的接口还主要是xml。<br>    &lt;?xml version=”1.0”?&gt;<br>    <data><br>        <country name="Liechtenstein"><br>            <rank updated="yes">2</rank><br>            <year>2008</year><br>            <gdppc>141100</gdppc><br>            <neighbor name="Austria" direction="E"><br>            <neighbor name="Switzerland" direction="W"><br>        </neighbor></neighbor></country><br>        <country name="Singapore"><br>            <rank updated="yes">5</rank><br>            <year>2011</year><br>            <gdppc>59900</gdppc><br>            <neighbor name="Malaysia" direction="N"><br>        </neighbor></country><br>        <country name="Panama"><br>            <rank updated="yes">69</rank><br>            <year>2011</year><br>            <gdppc>13600</gdppc><br>            <neighbor name="Costa Rica" direction="W"><br>            <neighbor name="Colombia" direction="E"><br>        </neighbor></neighbor></country><br>    </data></p><h3 id="解析方式"><a href="#解析方式" class="headerlink" title="解析方式"></a>解析方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"> </span><br><span class="line">import xml.etree.ElementTree as ET</span><br><span class="line"> </span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">############ 解析方式一 ############</span><br><span class="line">str_xml = open(&apos;xmltest.xml&apos;, &apos;r&apos;).read()# 打开文件，读取XML内容</span><br><span class="line">root = ET.XML(str_xml)# 将字符串解析成xml特殊对象，root代指xml文件的根节点</span><br><span class="line">print(root.tag)#获取根节点的标签名</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">############ 解析方式二 ############</span><br><span class="line">tree = ET.parse(&quot;xmltest.xml&quot;)# 直接解析xml文件</span><br><span class="line">root = tree.getroot()# 获取xml文件的根节点</span><br><span class="line">print(root.tag)#获取根节点的标签名</span><br><span class="line"> </span><br><span class="line"># 遍历xml文档</span><br><span class="line">for child in root:</span><br><span class="line">    print(&apos;========&gt;&apos;, child.tag, child.attrib, child.attrib[&apos;name&apos;])</span><br><span class="line">    for i in child:</span><br><span class="line">        print(i.tag, i.attrib, i.text)   #标签 属性 文本</span><br><span class="line"> </span><br><span class="line"># 只遍历year 节点</span><br><span class="line">for node in root.iter(&apos;year&apos;):</span><br><span class="line">    print(node.tag, node.text)</span><br><span class="line"># ---------------------------------------</span><br><span class="line"> </span><br><span class="line">import xml.etree.ElementTree as ET</span><br><span class="line"> </span><br><span class="line">tree = ET.parse(&quot;xmltest.xml&quot;)</span><br><span class="line">root = tree.getroot()</span><br><span class="line"> </span><br><span class="line"># 修改</span><br><span class="line">for node in root.iter(&apos;year&apos;):</span><br><span class="line">    new_year = int(node.text) + 1</span><br><span class="line">    node.text = str(new_year)</span><br><span class="line">    node.set(&apos;updated&apos;, &apos;yes&apos;)</span><br><span class="line">    node.set(&apos;version&apos;, &apos;1.0&apos;)</span><br><span class="line">tree.write(&apos;test.xml&apos;)</span><br><span class="line"> </span><br><span class="line"># 删除node</span><br><span class="line">for country in root.findall(&apos;country&apos;):</span><br><span class="line">    rank = int(country.find(&apos;rank&apos;).text)</span><br><span class="line">    if rank &gt; 50:</span><br><span class="line">        root.remove(country)</span><br><span class="line"> </span><br><span class="line">tree.write(&apos;output.xml&apos;)</span><br><span class="line"> </span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">#在country内添加（append）节点year2</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"> </span><br><span class="line">import xml.etree.ElementTree as ET</span><br><span class="line">tree = ET.parse(&quot;xmltest.xml&quot;)</span><br><span class="line">root=tree.getroot()</span><br><span class="line">for country in root.findall(&apos;country&apos;):</span><br><span class="line">    for year in country.findall(&apos;year&apos;):</span><br><span class="line">        if int(year.text) &gt; 2000:</span><br><span class="line">            year2=ET.Element(&apos;year2&apos;)</span><br><span class="line">            year2.text=&apos;新年&apos;</span><br><span class="line">            year2.attrib=&#123;&apos;update&apos;:&apos;yes&apos;&#125;</span><br><span class="line">            country.append(year2) #往country节点下添加子节点</span><br><span class="line"> </span><br><span class="line">tree.write(&apos;a.xml.swap&apos;)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">#自己创建xml文档</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"> </span><br><span class="line">import xml.etree.ElementTree as ET</span><br><span class="line"> </span><br><span class="line">new_xml = ET.Element(&quot;namelist&quot;)</span><br><span class="line">name = ET.SubElement(new_xml, &quot;name&quot;, attrib=&#123;&quot;enrolled&quot;: &quot;yes&quot;&#125;)</span><br><span class="line">age = ET.SubElement(name, &quot;age&quot;, attrib=&#123;&quot;checked&quot;: &quot;no&quot;&#125;)</span><br><span class="line">sex = ET.SubElement(name, &quot;sex&quot;)</span><br><span class="line">sex.text = &apos;33&apos;</span><br><span class="line">name2 = ET.SubElement(new_xml, &quot;name&quot;, attrib=&#123;&quot;enrolled&quot;: &quot;no&quot;&#125;)</span><br><span class="line">age = ET.SubElement(name2, &quot;age&quot;)</span><br><span class="line">age.text = &apos;19&apos;</span><br><span class="line"> </span><br><span class="line">et = ET.ElementTree(new_xml)  # 生成文档对象</span><br><span class="line">et.write(&quot;test.xml&quot;, encoding=&quot;utf-8&quot;, xml_declaration=True)</span><br><span class="line"> </span><br><span class="line">ET.dump(new_xml)  # 打印生成的格式</span><br></pre></td></tr></table></figure><h3 id="xml的语法功能"><a href="#xml的语法功能" class="headerlink" title="xml的语法功能"></a>xml的语法功能</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br></pre></td><td class="code"><pre><span class="line">class Element:</span><br><span class="line">    &quot;&quot;&quot;An XML element.</span><br><span class="line"></span><br><span class="line">    This class is the reference implementation of the Element interface.</span><br><span class="line"></span><br><span class="line">    An element&apos;s length is its number of subelements.  That means if you</span><br><span class="line">    want to check if an element is truly empty, you should check BOTH</span><br><span class="line">    its length AND its text attribute.</span><br><span class="line"></span><br><span class="line">    The element tag, attribute names, and attribute values can be either</span><br><span class="line">    bytes or strings.</span><br><span class="line"></span><br><span class="line">    *tag* is the element name.  *attrib* is an optional dictionary containing</span><br><span class="line">    element attributes. *extra* are additional element attributes given as</span><br><span class="line">    keyword arguments.</span><br><span class="line"></span><br><span class="line">    Example form:</span><br><span class="line">        &lt;tag attrib&gt;text&lt;child/&gt;...&lt;/tag&gt;tail</span><br><span class="line"></span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    当前节点的标签名</span><br><span class="line">    tag = None</span><br><span class="line">    &quot;&quot;&quot;The element&apos;s name.&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    当前节点的属性</span><br><span class="line"></span><br><span class="line">    attrib = None</span><br><span class="line">    &quot;&quot;&quot;Dictionary of the element&apos;s attributes.&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    当前节点的内容</span><br><span class="line">    text = None</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    Text before first subelement. This is either a string or the value None.</span><br><span class="line">    Note that if there is no text, this attribute may be either</span><br><span class="line">    None or the empty string, depending on the parser.</span><br><span class="line"></span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    tail = None</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    Text after this element&apos;s end tag, but before the next sibling element&apos;s</span><br><span class="line">    start tag.  This is either a string or the value None.  Note that if there</span><br><span class="line">    was no text, this attribute may be either None or an empty string,</span><br><span class="line">    depending on the parser.</span><br><span class="line"></span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def __init__(self, tag, attrib=&#123;&#125;, **extra):</span><br><span class="line">        if not isinstance(attrib, dict):</span><br><span class="line">            raise TypeError(&quot;attrib must be dict, not %s&quot; % (</span><br><span class="line">                attrib.__class__.__name__,))</span><br><span class="line">        attrib = attrib.copy()</span><br><span class="line">        attrib.update(extra)</span><br><span class="line">        self.tag = tag</span><br><span class="line">        self.attrib = attrib</span><br><span class="line">        self._children = []</span><br><span class="line"></span><br><span class="line">    def __repr__(self):</span><br><span class="line">        return &quot;&lt;%s %r at %#x&gt;&quot; % (self.__class__.__name__, self.tag, id(self))</span><br><span class="line"></span><br><span class="line">    def makeelement(self, tag, attrib):</span><br><span class="line">        创建一个新节点</span><br><span class="line">        &quot;&quot;&quot;Create a new element with the same type.</span><br><span class="line"></span><br><span class="line">        *tag* is a string containing the element name.</span><br><span class="line">        *attrib* is a dictionary containing the element attributes.</span><br><span class="line"></span><br><span class="line">        Do not call this method, use the SubElement factory function instead.</span><br><span class="line"></span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        return self.__class__(tag, attrib)</span><br><span class="line"></span><br><span class="line">    def copy(self):</span><br><span class="line">        &quot;&quot;&quot;Return copy of current element.</span><br><span class="line"></span><br><span class="line">        This creates a shallow copy. Subelements will be shared with the</span><br><span class="line">        original tree.</span><br><span class="line"></span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        elem = self.makeelement(self.tag, self.attrib)</span><br><span class="line">        elem.text = self.text</span><br><span class="line">        elem.tail = self.tail</span><br><span class="line">        elem[:] = self</span><br><span class="line">        return elem</span><br><span class="line"></span><br><span class="line">    def __len__(self):</span><br><span class="line">        return len(self._children)</span><br><span class="line"></span><br><span class="line">    def __bool__(self):</span><br><span class="line">        warnings.warn(</span><br><span class="line">            &quot;The behavior of this method will change in future versions.  &quot;</span><br><span class="line">            &quot;Use specific &apos;len(elem)&apos; or &apos;elem is not None&apos; test instead.&quot;,</span><br><span class="line">            FutureWarning, stacklevel=2</span><br><span class="line">            )</span><br><span class="line">        return len(self._children) != 0 # emulate old behaviour, for now</span><br><span class="line"></span><br><span class="line">    def __getitem__(self, index):</span><br><span class="line">        return self._children[index]</span><br><span class="line"></span><br><span class="line">    def __setitem__(self, index, element):</span><br><span class="line">        # if isinstance(index, slice):</span><br><span class="line">        #     for elt in element:</span><br><span class="line">        #         assert iselement(elt)</span><br><span class="line">        # else:</span><br><span class="line">        #     assert iselement(element)</span><br><span class="line">        self._children[index] = element</span><br><span class="line"></span><br><span class="line">    def __delitem__(self, index):</span><br><span class="line">        del self._children[index]</span><br><span class="line"></span><br><span class="line">    def append(self, subelement):</span><br><span class="line">        为当前节点追加一个子节点</span><br><span class="line">        &quot;&quot;&quot;Add *subelement* to the end of this element.</span><br><span class="line"></span><br><span class="line">        The new element will appear in document order after the last existing</span><br><span class="line">        subelement (or directly after the text, if it&apos;s the first subelement),</span><br><span class="line">        but before the end tag for this element.</span><br><span class="line"></span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        self._assert_is_element(subelement)</span><br><span class="line">        self._children.append(subelement)</span><br><span class="line"></span><br><span class="line">    def extend(self, elements):</span><br><span class="line">        为当前节点扩展 n 个子节点</span><br><span class="line">        &quot;&quot;&quot;Append subelements from a sequence.</span><br><span class="line"></span><br><span class="line">        *elements* is a sequence with zero or more elements.</span><br><span class="line"></span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        for element in elements:</span><br><span class="line">            self._assert_is_element(element)</span><br><span class="line">        self._children.extend(elements)</span><br><span class="line"></span><br><span class="line">    def insert(self, index, subelement):</span><br><span class="line">        在当前节点的子节点中插入某个节点，即：为当前节点创建子节点，然后插入指定位置</span><br><span class="line">        &quot;&quot;&quot;Insert *subelement* at position *index*.&quot;&quot;&quot;</span><br><span class="line">        self._assert_is_element(subelement)</span><br><span class="line">        self._children.insert(index, subelement)</span><br><span class="line"></span><br><span class="line">    def _assert_is_element(self, e):</span><br><span class="line">        # Need to refer to the actual Python implementation, not the</span><br><span class="line">        # shadowing C implementation.</span><br><span class="line">        if not isinstance(e, _Element_Py):</span><br><span class="line">            raise TypeError(&apos;expected an Element, not %s&apos; % type(e).__name__)</span><br><span class="line"></span><br><span class="line">    def remove(self, subelement):</span><br><span class="line">        在当前节点在子节点中删除某个节点</span><br><span class="line">        &quot;&quot;&quot;Remove matching subelement.</span><br><span class="line"></span><br><span class="line">        Unlike the find methods, this method compares elements based on</span><br><span class="line">        identity, NOT ON tag value or contents.  To remove subelements by</span><br><span class="line">        other means, the easiest way is to use a list comprehension to</span><br><span class="line">        select what elements to keep, and then use slice assignment to update</span><br><span class="line">        the parent element.</span><br><span class="line"></span><br><span class="line">        ValueError is raised if a matching element could not be found.</span><br><span class="line"></span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # assert iselement(element)</span><br><span class="line">        self._children.remove(subelement)</span><br><span class="line"></span><br><span class="line">    def getchildren(self):</span><br><span class="line">        获取所有的子节点（废弃）</span><br><span class="line">        &quot;&quot;&quot;(Deprecated) Return all subelements.</span><br><span class="line"></span><br><span class="line">        Elements are returned in document order.</span><br><span class="line"></span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        warnings.warn(</span><br><span class="line">            &quot;This method will be removed in future versions.  &quot;</span><br><span class="line">            &quot;Use &apos;list(elem)&apos; or iteration over elem instead.&quot;,</span><br><span class="line">            DeprecationWarning, stacklevel=2</span><br><span class="line">            )</span><br><span class="line">        return self._children</span><br><span class="line"></span><br><span class="line">    def find(self, path, namespaces=None):</span><br><span class="line">        获取第一个寻找到的子节点</span><br><span class="line">        &quot;&quot;&quot;Find first matching element by tag name or path.</span><br><span class="line"></span><br><span class="line">        *path* is a string having either an element tag or an XPath,</span><br><span class="line">        *namespaces* is an optional mapping from namespace prefix to full name.</span><br><span class="line"></span><br><span class="line">        Return the first matching element, or None if no element was found.</span><br><span class="line"></span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        return ElementPath.find(self, path, namespaces)</span><br><span class="line"></span><br><span class="line">    def findtext(self, path, default=None, namespaces=None):</span><br><span class="line">        获取第一个寻找到的子节点的内容</span><br><span class="line">        &quot;&quot;&quot;Find text for first matching element by tag name or path.</span><br><span class="line"></span><br><span class="line">        *path* is a string having either an element tag or an XPath,</span><br><span class="line">        *default* is the value to return if the element was not found,</span><br><span class="line">        *namespaces* is an optional mapping from namespace prefix to full name.</span><br><span class="line"></span><br><span class="line">        Return text content of first matching element, or default value if</span><br><span class="line">        none was found.  Note that if an element is found having no text</span><br><span class="line">        content, the empty string is returned.</span><br><span class="line"></span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        return ElementPath.findtext(self, path, default, namespaces)</span><br><span class="line"></span><br><span class="line">    def findall(self, path, namespaces=None):</span><br><span class="line">        获取所有的子节点</span><br><span class="line">        &quot;&quot;&quot;Find all matching subelements by tag name or path.</span><br><span class="line"></span><br><span class="line">        *path* is a string having either an element tag or an XPath,</span><br><span class="line">        *namespaces* is an optional mapping from namespace prefix to full name.</span><br><span class="line"></span><br><span class="line">        Returns list containing all matching elements in document order.</span><br><span class="line"></span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        return ElementPath.findall(self, path, namespaces)</span><br><span class="line"></span><br><span class="line">    def iterfind(self, path, namespaces=None):</span><br><span class="line">        获取所有指定的节点，并创建一个迭代器（可以被for循环）</span><br><span class="line">        &quot;&quot;&quot;Find all matching subelements by tag name or path.</span><br><span class="line"></span><br><span class="line">        *path* is a string having either an element tag or an XPath,</span><br><span class="line">        *namespaces* is an optional mapping from namespace prefix to full name.</span><br><span class="line"></span><br><span class="line">        Return an iterable yielding all matching elements in document order.</span><br><span class="line"></span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        return ElementPath.iterfind(self, path, namespaces)</span><br><span class="line"></span><br><span class="line">    def clear(self):</span><br><span class="line">        清空节点</span><br><span class="line">        &quot;&quot;&quot;Reset element.</span><br><span class="line"></span><br><span class="line">        This function removes all subelements, clears all attributes, and sets</span><br><span class="line">        the text and tail attributes to None.</span><br><span class="line"></span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        self.attrib.clear()</span><br><span class="line">        self._children = []</span><br><span class="line">        self.text = self.tail = None</span><br><span class="line"></span><br><span class="line">    def get(self, key, default=None):</span><br><span class="line">        获取当前节点的属性值</span><br><span class="line">        &quot;&quot;&quot;Get element attribute.</span><br><span class="line"></span><br><span class="line">        Equivalent to attrib.get, but some implementations may handle this a</span><br><span class="line">        bit more efficiently.  *key* is what attribute to look for, and</span><br><span class="line">        *default* is what to return if the attribute was not found.</span><br><span class="line"></span><br><span class="line">        Returns a string containing the attribute value, or the default if</span><br><span class="line">        attribute was not found.</span><br><span class="line"></span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        return self.attrib.get(key, default)</span><br><span class="line"></span><br><span class="line">    def set(self, key, value):</span><br><span class="line">        为当前节点设置属性值</span><br><span class="line">        &quot;&quot;&quot;Set element attribute.</span><br><span class="line"></span><br><span class="line">        Equivalent to attrib[key] = value, but some implementations may handle</span><br><span class="line">        this a bit more efficiently.  *key* is what attribute to set, and</span><br><span class="line">        *value* is the attribute value to set it to.</span><br><span class="line"></span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        self.attrib[key] = value</span><br><span class="line"></span><br><span class="line">    def keys(self):</span><br><span class="line">        获取当前节点的所有属性的 key</span><br><span class="line"></span><br><span class="line">        &quot;&quot;&quot;Get list of attribute names.</span><br><span class="line"></span><br><span class="line">        Names are returned in an arbitrary order, just like an ordinary</span><br><span class="line">        Python dict.  Equivalent to attrib.keys()</span><br><span class="line"></span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        return self.attrib.keys()</span><br><span class="line"></span><br><span class="line">    def items(self):</span><br><span class="line">        获取当前节点的所有属性值，每个属性都是一个键值对</span><br><span class="line">        &quot;&quot;&quot;Get element attributes as a sequence.</span><br><span class="line"></span><br><span class="line">        The attributes are returned in arbitrary order.  Equivalent to</span><br><span class="line">        attrib.items().</span><br><span class="line"></span><br><span class="line">        Return a list of (name, value) tuples.</span><br><span class="line"></span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        return self.attrib.items()</span><br><span class="line"></span><br><span class="line">    def iter(self, tag=None):</span><br><span class="line">        在当前节点的子孙中根据节点名称寻找所有指定的节点，并返回一个迭代器（可以被for循环）。</span><br><span class="line">        &quot;&quot;&quot;Create tree iterator.</span><br><span class="line"></span><br><span class="line">        The iterator loops over the element and all subelements in document</span><br><span class="line">        order, returning all elements with a matching tag.</span><br><span class="line"></span><br><span class="line">        If the tree structure is modified during iteration, new or removed</span><br><span class="line">        elements may or may not be included.  To get a stable set, use the</span><br><span class="line">        list() function on the iterator, and loop over the resulting list.</span><br><span class="line"></span><br><span class="line">        *tag* is what tags to look for (default is to return all elements)</span><br><span class="line"></span><br><span class="line">        Return an iterator containing all the matching elements.</span><br><span class="line"></span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if tag == &quot;*&quot;:</span><br><span class="line">            tag = None</span><br><span class="line">        if tag is None or self.tag == tag:</span><br><span class="line">            yield self</span><br><span class="line">        for e in self._children:</span><br><span class="line">            yield from e.iter(tag)</span><br><span class="line"></span><br><span class="line">    # compatibility</span><br><span class="line">    def getiterator(self, tag=None):</span><br><span class="line">        # Change for a DeprecationWarning in 1.4</span><br><span class="line">        warnings.warn(</span><br><span class="line">            &quot;This method will be removed in future versions.  &quot;</span><br><span class="line">            &quot;Use &apos;elem.iter()&apos; or &apos;list(elem.iter())&apos; instead.&quot;,</span><br><span class="line">            PendingDeprecationWarning, stacklevel=2</span><br><span class="line">        )</span><br><span class="line">        return list(self.iter(tag))</span><br><span class="line"></span><br><span class="line">    def itertext(self):</span><br><span class="line">        在当前节点的子孙中根据节点名称寻找所有指定的节点的内容，并返回一个迭代器（可以被for循环）。</span><br><span class="line">        &quot;&quot;&quot;Create text iterator.</span><br><span class="line"></span><br><span class="line">        The iterator loops over the element and all subelements in document</span><br><span class="line">        order, returning all inner text.</span><br><span class="line"></span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        tag = self.tag</span><br><span class="line">        if not isinstance(tag, str) and tag is not None:</span><br><span class="line">            return</span><br><span class="line">        if self.text:</span><br><span class="line">            yield self.text</span><br><span class="line">        for e in self:</span><br><span class="line">            yield from e.itertext()</span><br><span class="line">            if e.tail:</span><br><span class="line">                yield e.tail</span><br></pre></td></tr></table></figure><p>#configparser模块<br>configparser用于处理特定格式的文件，本质上是利用open来操作文件,主要用于配置文件分析用的</p><blockquote><p>配置文件如下</p></blockquote><pre><code># 注释1; 注释2[section1]k1 = v1k2:v2user=egonage=18is_admin=truesalary=31[section2]k1 = v1</code></pre><h2 id="读-写-改-查"><a href="#读-写-改-查" class="headerlink" title="读 写 改 查"></a>读 写 改 查</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">读取</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">import configparser</span><br><span class="line"> </span><br><span class="line">config=configparser.ConfigParser()</span><br><span class="line">config.read(&apos;a.cfg&apos;)</span><br><span class="line"> </span><br><span class="line">#查看所有的标题</span><br><span class="line">res=config.sections() #[&apos;section1&apos;, &apos;section2&apos;]</span><br><span class="line">print(res)</span><br><span class="line"> </span><br><span class="line">#查看标题section1下所有key=value的key</span><br><span class="line">options=config.options(&apos;section1&apos;)</span><br><span class="line">print(options) #[&apos;k1&apos;, &apos;k2&apos;, &apos;user&apos;, &apos;age&apos;, &apos;is_admin&apos;, &apos;salary&apos;]</span><br><span class="line"> </span><br><span class="line">#查看标题section1下所有key=value的(key,value)格式</span><br><span class="line">item_list=config.items(&apos;section1&apos;)</span><br><span class="line">print(item_list) #[(&apos;k1&apos;, &apos;v1&apos;), (&apos;k2&apos;, &apos;v2&apos;), (&apos;user&apos;, &apos;egon&apos;), (&apos;age&apos;, &apos;18&apos;), (&apos;is_admin&apos;, &apos;true&apos;), (&apos;salary&apos;, &apos;31&apos;)]</span><br><span class="line"> </span><br><span class="line">#查看标题section1下user的值=&gt;字符串格式</span><br><span class="line">val=config.get(&apos;section1&apos;,&apos;user&apos;)</span><br><span class="line">print(val) #egon</span><br><span class="line"> </span><br><span class="line">#查看标题section1下age的值=&gt;整数格式</span><br><span class="line">val1=config.getint(&apos;section1&apos;,&apos;age&apos;)</span><br><span class="line">print(val1) #18</span><br><span class="line"> </span><br><span class="line">#查看标题section1下is_admin的值=&gt;布尔值格式</span><br><span class="line">val2=config.getboolean(&apos;section1&apos;,&apos;is_admin&apos;)</span><br><span class="line">print(val2) #True</span><br><span class="line"> </span><br><span class="line">#查看标题section1下salary的值=&gt;浮点型格式</span><br><span class="line">val3=config.getfloat(&apos;section1&apos;,&apos;salary&apos;)</span><br><span class="line">print(val3) #31.0</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">改写</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">import configparser</span><br><span class="line"> </span><br><span class="line">config=configparser.ConfigParser()</span><br><span class="line">config.read(&apos;a.cfg&apos;,encoding=&apos;utf-8&apos;)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">#删除整个标题section2</span><br><span class="line">config.remove_section(&apos;section2&apos;)</span><br><span class="line"> </span><br><span class="line">#删除标题section1下的某个k1和k2</span><br><span class="line">config.remove_option(&apos;section1&apos;,&apos;k1&apos;)</span><br><span class="line">config.remove_option(&apos;section1&apos;,&apos;k2&apos;)</span><br><span class="line"> </span><br><span class="line">#判断是否存在某个标题</span><br><span class="line">print(config.has_section(&apos;section1&apos;))</span><br><span class="line"> </span><br><span class="line">#判断标题section1下是否有user</span><br><span class="line">print(config.has_option(&apos;section1&apos;,&apos;&apos;))</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">#添加一个标题</span><br><span class="line">config.add_section(&apos;egon&apos;)</span><br><span class="line"> </span><br><span class="line">#在标题egon下添加name=egon,age=18的配置</span><br><span class="line">config.set(&apos;egon&apos;,&apos;name&apos;,&apos;egon&apos;)</span><br><span class="line"># config.set(&apos;egon&apos;,&apos;age&apos;,18) #报错,必须是字符串</span><br><span class="line"> </span><br><span class="line">#最后将修改的内容写入文件,完成最终的修改</span><br><span class="line">config.write(open(&apos;a.cfg&apos;,&apos;w&apos;))</span><br></pre></td></tr></table></figure><h1 id="hashlib"><a href="#hashlib" class="headerlink" title="hashlib"></a>hashlib</h1><p>hash是一种算法（3.x里代替了md5模块和sha模块，主要提供 SHA1, SHA224, SHA256, SHA384, SHA512 ，MD5 算法），该算法接受传入的内容，经过运算得到一串hash值</p><h2 id="hash值的特点是"><a href="#hash值的特点是" class="headerlink" title="hash值的特点是"></a>hash值的特点是</h2><pre><code>只要传入的内容一样，得到的hash值必然一样不能由hash值返解成内容，不应该在网络传输明文密码只要使用的hash算法不变，无论校验的内容有多大，得到的hash值长度是固定</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&apos;&apos;&apos;</span><br><span class="line">注意：把一段很长的数据update多次，与一次update这段长数据，得到的结果一样</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">import hashlib</span><br><span class="line">m = hashlib.md5()  # m=hashlib.sha256()</span><br><span class="line">m.update(&apos;hello&apos;.encode(&apos;utf8&apos;))</span><br><span class="line">print(m.hexdigest())  # 5d41402abc4b2a76b9719d911017c592</span><br><span class="line">m.update(&apos;world&apos;.encode(&apos;utf8&apos;))</span><br><span class="line">print(m.hexdigest())  # fc5e038d38a57032085441e7fe7010b0</span><br><span class="line">m2 = hashlib.md5()</span><br><span class="line">m2.update(&apos;helloworld&apos;.encode(&apos;utf8&apos;))</span><br><span class="line">print(m2.hexdigest())  # fc5e038d38a57032085441e7fe7010b0</span><br></pre></td></tr></table></figure><h2 id="添加自定义key-加盐"><a href="#添加自定义key-加盐" class="headerlink" title="添加自定义key(加盐)"></a>添加自定义key(加盐)</h2><p>以上加密算法虽然依然非常厉害，但时候存在缺陷，即：通过撞库可以反解。所以，有必要对加密算法中添加自定义key再来做加密。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">对加密算法中添加自定义key再来做加密</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">import hashlib</span><br><span class="line">hash = hashlib.sha256(&apos;898oaFs09f&apos;.encode(&apos;utf8&apos;))</span><br><span class="line">hash.update(&apos;alvin&apos;.encode(&apos;utf8&apos;))</span><br><span class="line">print(hash.hexdigest())  # e79e68f070cdedcfe63eaf1a2e92c83b4cfb1b5c6bc452d214c1b7e77cdfd1c7</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">模拟撞库破解密码</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">import hashlib</span><br><span class="line">passwds=[</span><br><span class="line">    &apos;tom3714&apos;,</span><br><span class="line">    &apos;tom1313&apos;,</span><br><span class="line">    &apos;tom94139413&apos;,</span><br><span class="line">    &apos;tom123456&apos;,</span><br><span class="line">    &apos;1234567890&apos;,</span><br><span class="line">    &apos;a123sdsdsa&apos;,</span><br><span class="line">    ]</span><br><span class="line">def make_passwd_dic(passwds):</span><br><span class="line">    dic=&#123;&#125;</span><br><span class="line">    for passwd in passwds:</span><br><span class="line">        m=hashlib.md5()</span><br><span class="line">        m.update(passwd.encode(&apos;utf-8&apos;))</span><br><span class="line">        dic[passwd]=m.hexdigest()</span><br><span class="line">    return dic</span><br><span class="line"> </span><br><span class="line">def break_code(cryptograph,passwd_dic):</span><br><span class="line">    for k,v in passwd_dic.items():</span><br><span class="line">        if v == cryptograph:</span><br><span class="line">            print(&apos;密码是===&gt;\033[46m%s\033[0m&apos; %k)</span><br><span class="line"> </span><br><span class="line">cryptograph=&apos;f19b50d5e3433e65e6879d0e66632664&apos;</span><br><span class="line">break_code(cryptograph,make_passwd_dic(passwds))</span><br></pre></td></tr></table></figure><p>suprocess模块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import  subprocess</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">Linux下:</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"># obj = subprocess.Popen(&apos;ls&apos;, shell=True,</span><br><span class="line">#                        stdout=subprocess.PIPE,</span><br><span class="line">#                        stderr=subprocess.PIPE)</span><br><span class="line"># stdout = obj.stdout.read()</span><br><span class="line"># stderr = obj.stderr.read()</span><br><span class="line">#</span><br><span class="line"># #=========================</span><br><span class="line"># res1=subprocess.Popen(&apos;ls&apos;,shell=True,stdout=subprocess.PIPE)</span><br><span class="line"># res=subprocess.Popen(&apos;grep txt$&apos;,shell=True,stdin=res1.stdout,</span><br><span class="line">#                  stdout=subprocess.PIPE)</span><br><span class="line"># print(res.stdout.read().decode(&apos;utf-8&apos;))</span><br><span class="line">#</span><br><span class="line"># #等同于上面,但是上面的优势在于,一个数据流可以和另外一个数据流交互,可以通过爬虫得到结果然后交给grep</span><br><span class="line"># res1=subprocess.Popen(&apos;ls |grep txt$&apos;,shell=True,stdout=subprocess.PIPE)</span><br><span class="line"># print(res1.stdout.read().decode(&apos;utf-8&apos;))</span><br><span class="line">a = subprocess.Popen(&apos;for i in $(seq 1 100);do sleep 1;echo $i &gt;&gt;/tmp/sleep.log;done&apos;,shell=True,stdout=subprocess.</span><br><span class="line">a.pid</span><br><span class="line">a.terminate()</span><br><span class="line">a.kill()</span><br><span class="line">a.communicate(b&apos;5&apos;)</span><br><span class="line">a.stdout</span><br><span class="line">a.stdout.read()</span><br><span class="line">a.send_signal(signal.SIGKILL)</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">windows下:</span><br><span class="line"># dir | findstr &apos;App*&apos;</span><br><span class="line"># dir | findstr &apos;App$&apos;</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">#Popen发起一个新进程</span><br><span class="line">import subprocess</span><br><span class="line">res1=subprocess.Popen(r&apos;dir C:\Windows&apos;,shell=True,stdout=subprocess.PIPE)</span><br><span class="line">res=subprocess.Popen(&apos;findstr App*&apos;,shell=True,stdin=res1.stdout,</span><br><span class="line">                 stdout=subprocess.PIPE)</span><br><span class="line"> </span><br><span class="line">print(res.stdout.read().decode(&apos;gbk&apos;)) #subprocess使用当前系统默认编码，得到结果为bytes类型，在windows下需要用gbk解码</span><br></pre></td></tr></table></figure></p><h1 id="logging模块"><a href="#logging模块" class="headerlink" title="logging模块"></a>logging模块</h1><p>Python的logging模块提供了通用的日志系统，可以方便第三方模块或者是应用使用。这个模块提供不同的日志级别，并可以采用不同的方式记录日志，比如文件，HTTP GET/POST，SMTP，Socket等，甚至可以自己实现具体的日志记录方式<br>logging模块可帮助更容易的记录日志。logging的日志可以分为debug(),info(),warning(),error()和crictical()5个级别。</p><h2 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h2><table><thead><tr><th>级别</th><th>数值</th><th>使用</th></tr></thead><tbody><tr><td>CRITICAL</td><td>50</td><td>严重错误，表示程序不能继续运行 FATAL=CRITICAL</td></tr><tr><td>ERROR</td><td>40</td><td>错误，表示程序不能运行某一个功能</td></tr><tr><td>WARNING</td><td>30</td><td>报警，表示程序出现意外情况，或者未来的问题。 软件仍然继续正常运行,WARN = WARNING</td></tr><tr><td>INFO</td><td>20</td><td>表示程序正常运行</td></tr><tr><td>DEBUG</td><td>10</td><td>详细信息，主要用于诊断问题</td></tr><tr><td>NOTSET</td><td>0</td></tr></tbody></table><ul><li>简单用法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import logging</span><br><span class="line">logging.basicConfig(filename=&apos;log_test.log&apos;,</span><br><span class="line">level=logging.DEBUG,</span><br><span class="line">format=&apos;%(asctime)s %(message)s&apos;,</span><br><span class="line">datefmt=&apos;%m/%d/%Y %I:%M:%S %p&apos;)</span><br><span class="line">logging.debug(&apos;DEBUG: This message should go to the log file&apos;)</span><br><span class="line">logging.warning(&quot;WARNING: user [david] tried to log in&quot;)</span><br><span class="line">logging.critical(&quot;CRITICAL: server is down&quot;)</span><br></pre></td></tr></table></figure></li></ul><h2 id="logging模块定义的格式字符串字段"><a href="#logging模块定义的格式字符串字段" class="headerlink" title="logging模块定义的格式字符串字段"></a>logging模块定义的格式字符串字段</h2><table><thead><tr><th>字段/属性名称</th><th>使用格式</th><th>描述</th></tr></thead><tbody><tr><td>asctime</td><td>%(asctime)s</td><td>日志事件发生的时间–人类可读时间，如：2003-07-08 16:49:45,896</td></tr><tr><td>created</td><td>%(created)f</td><td>日志事件发生的时间–时间戳，就是当时调用time.time()函数返回的值</td></tr><tr><td>relativeCreated</td><td>%(relativeCreated)d</td><td>日志事件发生的时间相对于logging模块加载时间的相对毫秒数</td></tr><tr><td>msecs</td><td>%(msecs)d</td><td>日志事件发生事件的毫秒部分</td></tr><tr><td>levelname</td><td>%(levelname)s</td><td>该日志记录的文字形式的日志级别（’DEBUG’, ‘INFO’, ‘WARNING’, ‘ERROR’, ‘CRITICAL’）</td></tr><tr><td>levelno</td><td>%(levelno)s</td><td>志记录的数字形式的日志级别（10, 20, 30, 40, 50）</td></tr><tr><td>name</td><td>%(name)s</td><td>所使用的日志器名称，默认是’root’，因为默认使用的是 rootLogger</td></tr><tr><td>message</td><td>%(message)s</td><td>日志记录的文本内容，通过 msg % args计算得到的</td></tr><tr><td>pathname</td><td>%(pathname)s</td><td>调用日志记录函数的源码文件的全路径</td></tr><tr><td>filename</td><td>%(filename)s</td><td>pathname的文件名部分，包含文件后缀</td></tr><tr><td>module</td><td>%(module)s</td><td>filename的名称部分，不包含后缀</td></tr><tr><td>lineno</td><td>%(lineno)d</td><td>调用日志记录函数的源代码所在的行号</td></tr><tr><td>funcName</td><td>%(funcName)s</td><td>调用日志记录函数的函数名</td></tr><tr><td>process</td><td>%(process)d</td><td>进程ID</td></tr><tr><td>processName</td><td>%(processName)s</td><td>进程名称，Python 3.1新增</td></tr><tr><td>thread</td><td>%(thread)d</td><td>线程ID</td></tr><tr><td>threadName</td><td>%(thread)s</td><td>线程名称</td></tr></tbody></table><p>#日志同时输出到屏幕和文件<br>如果同时把log打印在屏幕和文件，Python使用logging模块记录日志设计四个主要类，使用官方文档中的概括：</p><blockquote><p>logger提供了应用程序可以直接调用的接口。与调用logging是相同的<br>handler将（logger创建的）日志记录发送到合适的目的输出.一个handler对象只能绑定一个formatter对象，若执行多次setFormatter方法，则之前的 绑定都会被覆盖。<br>filter输出哪条日志记录，哪条不输出<br>formater决定了日志的记录的最终输出格式<br>logger对象可以绑定handler和filter，也可以进行添加和删除操作。</p></blockquote><img src="/2019/03/21/python-常用模块/logging.png"><h2 id="每个组件的主要功能"><a href="#每个组件的主要功能" class="headerlink" title="每个组件的主要功能"></a>每个组件的主要功能</h2><h3 id="logger"><a href="#logger" class="headerlink" title="logger"></a>logger</h3><p>可以绑定handler和filters<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Logger.setLevel(lev) #指定最低的日志级别</span><br><span class="line">Logger.addFilter(filt)、Logger.removeFilter(filt) #添加或删除指定的filter</span><br><span class="line">Logger.addHandler(hdlr)、Logger.removeHandler(hdlr) #添加或删除指定的handler</span><br></pre></td></tr></table></figure></p><blockquote><p>Logger.debug()、Logger.info()、Logger.warning()、Logger.error()、Logger.critical()可设置日志级别</p></blockquote><h3 id="handler"><a href="#handler" class="headerlink" title="handler"></a>handler</h3><p>handler负责发送相关的信息到指定的目的。如控制台、文件或网络上。还可以编写自己的Handler，通过addHandler()添加多个handler<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Handler.setLevel(lev) #低于lev级别的信息将被忽略</span><br><span class="line">Handler.setFormatter() #屏幕输出格式</span><br><span class="line">Handler.addFilter(filt)、Handler.remove(filt)</span><br></pre></td></tr></table></figure></p><ul><li>logging.StreamHandler</li><li>logging.handlers.RotatingFileHandler</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import logging</span><br><span class="line"># 1.生成 logger 对象</span><br><span class="line">logger = logging.getLogger（&quot;mylog&quot;)</span><br><span class="line"># 2.生成 handler 对象</span><br><span class="line">ch = logging.StreamHandler()</span><br><span class="line">fh = logging.FileHandler()</span><br><span class="line"># 3.把handler对象绑定到logger</span><br><span class="line">logger.addHandler(ch)</span><br><span class="line">logger.addHandler(fh)</span><br><span class="line"># 4. 生成formatter对象</span><br><span class="line">file_f = logging.Formatter(&apos;%(ascctime)s - %(name)s&apos;)</span><br><span class="line">console_f = logging.Formatter(&apos;%(asctime)s - %(levelname)s&apos;)</span><br><span class="line">ch.setFormater(console_f)</span><br><span class="line">fh.setFormater(file_f)</span><br><span class="line">logger.debug(&quot;test log&quot;) #不设置日志级别，默认为warning</span><br><span class="line">logger.info(&quot;test log&quot;)</span><br><span class="line"></span><br><span class="line"># 2.</span><br></pre></td></tr></table></figure><h3 id="为logging模块指定全局配置，针对所有logger有效，控制打印到文件中"><a href="#为logging模块指定全局配置，针对所有logger有效，控制打印到文件中" class="headerlink" title="为logging模块指定全局配置，针对所有logger有效，控制打印到文件中"></a>为logging模块指定全局配置，针对所有logger有效，控制打印到文件中</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import logging</span><br><span class="line">logging.basicConfig(filename=&apos;access.log&apos;,</span><br><span class="line">                    format=&apos;%(asctime)s - %(name)s - %(levelname)s -%(module)s:  %(message)s&apos;,</span><br><span class="line">                    datefmt=&apos;%Y-%m-%d %H:%M:%S %p&apos;,</span><br><span class="line">                    level=10)</span><br><span class="line"> </span><br><span class="line">logging.debug(&apos;调试debug&apos;)</span><br><span class="line">logging.info(&apos;消息info&apos;)</span><br><span class="line">logging.warning(&apos;警告warn&apos;)</span><br><span class="line">logging.error(&apos;错误error&apos;)</span><br><span class="line">logging.critical(&apos;严重critical&apos;)</span><br></pre></td></tr></table></figure><h3 id="Logger与Handler的级别-logger是第一级过滤，然后才能到handler"><a href="#Logger与Handler的级别-logger是第一级过滤，然后才能到handler" class="headerlink" title="Logger与Handler的级别(logger是第一级过滤，然后才能到handler)"></a>Logger与Handler的级别(logger是第一级过滤，然后才能到handler)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import logging</span><br><span class="line">form=logging.Formatter(&apos;%(asctime)s - %(name)s - %(levelname)s -%(module)s:  %(message)s&apos;,</span><br><span class="line">                    datefmt=&apos;%Y-%m-%d %H:%M:%S %p&apos;,)</span><br><span class="line"> </span><br><span class="line">ch=logging.StreamHandler()</span><br><span class="line">ch.setFormatter(form)</span><br><span class="line"># ch.setLevel(10)</span><br><span class="line">ch.setLevel(20)</span><br><span class="line"> </span><br><span class="line">log1=logging.getLogger(&apos;root&apos;)</span><br><span class="line"># log1.setLevel(20)</span><br><span class="line">log1.setLevel(40)</span><br><span class="line">log1.addHandler(ch)</span><br><span class="line"> </span><br><span class="line">log1.debug(&apos;log1 debug&apos;)</span><br><span class="line">log1.info(&apos;log1 info&apos;)</span><br><span class="line">log1.warning(&apos;log1 warning&apos;)</span><br><span class="line">log1.error(&apos;log1 error&apos;)</span><br><span class="line">log1.critical(&apos;log1 critical&apos;)</span><br></pre></td></tr></table></figure><h3 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#core/logger.py</span><br><span class="line">import os</span><br><span class="line">import logging</span><br><span class="line">from conf import settings</span><br><span class="line"> </span><br><span class="line">def logger(log_type):</span><br><span class="line"> </span><br><span class="line">    logger = logging.getLogger(log_type)</span><br><span class="line">    logger.setLevel(settings.LOG_LEVEL)</span><br><span class="line"> </span><br><span class="line">    ch = logging.StreamHandler()  #屏幕</span><br><span class="line">    ch.setLevel(settings.LOG_LEVEL)</span><br><span class="line"> </span><br><span class="line">    log_dir = &quot;%s/log&quot; % (settings.BASE_DIR)</span><br><span class="line">    if not os.path.exists(log_dir):</span><br><span class="line">        os.makedirs(log_dir)</span><br><span class="line">    log_file = &quot;%s/log/%s&quot; %(settings.BASE_DIR, settings.LOG_TYPES[log_type])</span><br><span class="line">    fh = logging.FileHandler(log_file)  #文件</span><br><span class="line">    fh.setLevel(settings.LOG_LEVEL)</span><br><span class="line"> </span><br><span class="line">    formatter = logging.Formatter(&apos;%(asctime)s - %(name)s - %(levelname)s - %(message)s&apos;)</span><br><span class="line"> </span><br><span class="line">    ch.setFormatter(formatter)</span><br><span class="line">    fh.setFormatter(formatter)</span><br><span class="line"> </span><br><span class="line">    logger.addHandler(ch)</span><br><span class="line">    logger.addHandler(fh)</span><br><span class="line"> </span><br><span class="line">    return logger</span><br><span class="line"> </span><br><span class="line">#core/main.py  调用</span><br><span class="line">from core import logger</span><br><span class="line">trans_logger = logger.logger(&apos;transaction&apos;)</span><br><span class="line">access_logger = logger.logger(&apos;access&apos;)</span><br><span class="line"> </span><br><span class="line">def run():</span><br><span class="line">    trans_logger.debug(&apos;trans_logger debug&apos;)</span><br><span class="line">    trans_logger.info(&apos;trans_logger info&apos;)</span><br><span class="line">    trans_logger.warning(&apos;trans_logger warning&apos;)</span><br><span class="line">    trans_logger.error(&apos;trans_logger error&apos;)</span><br><span class="line">    trans_logger.critical(&apos;trans_logger critical&apos;)</span><br><span class="line"> </span><br><span class="line">    access_logger.debug(&apos;access_logger debug&apos;)</span><br><span class="line">    access_logger.info(&apos;access_logger info&apos;)</span><br><span class="line">    access_logger.warning(&apos;access_logger warning&apos;)</span><br><span class="line">    access_logger.error(&apos;access_logger error&apos;)</span><br><span class="line">    access_logger.critical(&apos;access_logger critical&apos;)</span><br><span class="line">run()</span><br><span class="line"> </span><br><span class="line">#conf/setting.py</span><br><span class="line">import os</span><br><span class="line">import logging</span><br><span class="line">BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))</span><br><span class="line"> </span><br><span class="line">LOG_LEVEL = logging.INFO</span><br><span class="line">LOG_TYPES = &#123;</span><br><span class="line">    &apos;transaction&apos;: &apos;transactions.log&apos;,</span><br><span class="line">    &apos;access&apos;: &apos;access.log&apos;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>全局级别默认为warning，全局设置为漏斗，其它handler级别高于全局设置将不生效 </p></blockquote><h3 id="filter-组件"><a href="#filter-组件" class="headerlink" title="filter 组件"></a>filter 组件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import logging</span><br><span class="line">class BacFilter(logging.Filter):</span><br><span class="line">##忽略带db的日志</span><br><span class="line">def filter(self, record):</span><br><span class="line">return &quot;db&quot; not in record.getMessage()</span><br><span class="line">logger.addFilter(BacFilter())</span><br><span class="line">logger.debug(&quot;test log db&quot;)</span><br></pre></td></tr></table></figure><h3 id="日志的截断"><a href="#日志的截断" class="headerlink" title="日志的截断"></a>日志的截断</h3><blockquote><p>logging.handlers.RotatingFileHandler<br>    管理文件大小，达到一定大小后，另存文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from logging import handlers</span><br><span class="line">f = handlers.RotatingFileHandler(&quot;test.log&quot;, maxBytes=10, backupCount=3)</span><br><span class="line">&gt; logging.handlers.TimeRotatingFileHandler(filename [,when [,interval [,backupCount]]])</span><br><span class="line">管理文件大小，达到一定大小后，另存文件</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>logging.handlers.TimeRotatingFileHandler</p></blockquote><h1 id="re模块"><a href="#re模块" class="headerlink" title="re模块"></a>re模块</h1><h2 id="re的匹配函数"><a href="#re的匹配函数" class="headerlink" title="re的匹配函数"></a>re的匹配函数</h2><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>re.match</td><td>从字符传开头匹配</td></tr><tr><td>re.search</td><td>全局查找，找到第一个返回</td></tr><tr><td>re.findall</td><td>查找所有的匹配，当做列表返回</td></tr><tr><td>re.split</td><td>按数字分割（把数字去掉），[maxsplit = 0]当做列表返回</td></tr><tr><td>re.sub</td><td>匹配字符并替换</td></tr><tr><td>re.fullmatch</td><td>全部匹配 re.fullmatch(‘\w+@\w+.(com&#124;cn&#124;edu)’,<a href="mailto:&#39;david@163.com" target="_blank" rel="noopener">&#39;david@163.com</a>‘)</td></tr><tr><td>re.compile</td><td>匹配字符并替换 pattern = re.compile(‘\w+@\w+.(com&#124;cn&#124;edu)’),pattern.fullmatch(<a href="mailto:&#39;david@163.com" target="_blank" rel="noopener">&#39;david@163.com</a>‘)</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">match_res = re.search(&apos;[0]&apos;,s)</span><br><span class="line">if match_res:</span><br><span class="line">match_res.group()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line">ss = &apos;abcdei23aa45&apos;</span><br><span class="line">re.match(&apos;[0-9]&apos;,ss)</span><br><span class="line">#返回None</span><br><span class="line">re.match(&apos;[0-9]&apos;,ss)</span><br><span class="line">#全局查找，找到就返回</span><br><span class="line">re.search(&apos;[0-9]&apos;,ss)</span><br></pre></td></tr></table></figure><h2 id="常用的匹配"><a href="#常用的匹配" class="headerlink" title="常用的匹配"></a>常用的匹配</h2><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>‘.’</td><td>匹配任意字符</td></tr><tr><td>‘^’</td><td>匹配开头</td></tr><tr><td>‘$’</td><td>匹配结尾</td></tr><tr><td>‘*’</td><td>匹配*前面的字符0次或多次</td></tr><tr><td>‘+’</td><td>匹配+前面的字符1次或多次</td></tr><tr><td>‘?’</td><td>匹配？前面的字符0次或1次</td></tr><tr><td>‘{m}’</td><td>匹配前面的字符m次</td></tr><tr><td>‘{n,m}’</td><td>匹配前面的字符n-m次</td></tr><tr><td>‘[0-9a-z]’</td><td>任意一个字符</td></tr><tr><td>‘&#124;’</td><td>匹配左或右的字符</td></tr><tr><td>‘(…)’</td><td>分组匹配re.search(“(abc){2}a(123</td><td>45).group</td></tr><tr><td>‘\A’</td><td>从字符串开头字符,同^</td></tr><tr><td>‘\Z’</td><td>从字符串开头字符,同$</td></tr><tr><td>‘\d’</td><td>匹配数字0-9</td></tr><tr><td>‘\D’</td><td>匹配非数字</td></tr><tr><td>‘\w’</td><td>匹配[A-Za-z0-9]</td></tr><tr><td>‘\W’</td><td>匹配非[A-Za-z0-9],即特殊字符</td></tr><tr><td>‘\s’</td><td>匹配空白字符，\t,\r,\n</td></tr><tr><td>‘(?P<name>…’</name></td><td>分组匹配，re.search(“(?P<province>[0-9]{4}))</province></td></tr></tbody></table><h2 id="分组匹配"><a href="#分组匹配" class="headerlink" title="分组匹配"></a>分组匹配</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line">re.search(&apos;([a-z]+)([[0-9]+])&apos;,&apos;alex123&apos;).groups</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = &apos;130704200005250613&apos;</span><br><span class="line">res = re.search(&apos;(?P&lt;province&gt;\d&#123;3&#125;)(?P&lt;city&gt;\d&#123;3&#125;)&apos;)</span><br><span class="line">res.groupdict()</span><br></pre></td></tr></table></figure><h3 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h3><p>特殊字符需要转义<br>匹配|, ‘|‘<br>匹配\, ‘\\‘</p><h3 id="Flags标识符"><a href="#Flags标识符" class="headerlink" title="Flags标识符"></a>Flags标识符</h3><blockquote><p>re.I 忽略大小写<br>re.M 多行模式<br>re.S 使用re.S参数以后，正则表达式会将这个字符串作为一个整体，在整体中进行匹配<br>re.X 可以在表达式中写注释<br><code>`re.search(&#39;foo.$&#39;,&#39;foo1\nfoo2\n&#39;,re.M)</code></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;模块&quot;&gt;&lt;a href=&quot;#模块&quot; class=&quot;headerlink&quot; title=&quot;模块&quot;&gt;&lt;/a&gt;模块&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;python中，一个py文件就是一个模块
避免函数名和变量名冲突。提高代码可维护性，可重用
&lt;/code&gt;&lt;/pre&gt;&lt;h1
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
      <category term="模块" scheme="http://yoursite.com/categories/Python/%E6%A8%A1%E5%9D%97/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Ch2" scheme="http://yoursite.com/tags/Ch2/"/>
    
      <category term="常用模块" scheme="http://yoursite.com/tags/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>你的问题</title>
    <link href="http://yoursite.com/2019/03/21/%E4%BD%A0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/03/21/你的问题/</id>
    <published>2019-03-21T10:32:36.000Z</published>
    <updated>2019-04-24T03:17:34.813Z</updated>
    
    <content type="html"><![CDATA[<h1 id="你的问题是想法太多读书太少"><a href="#你的问题是想法太多读书太少" class="headerlink" title="你的问题是想法太多读书太少"></a>你的问题是想法太多读书太少</h1><h1 id="战术上的勤奋掩盖不了战略上的错误"><a href="#战术上的勤奋掩盖不了战略上的错误" class="headerlink" title="战术上的勤奋掩盖不了战略上的错误"></a>战术上的勤奋掩盖不了战略上的错误</h1><ul><li><p>个人的成长</p></li><li><p>公司的成长</p></li><li><p>反思</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;你的问题是想法太多读书太少&quot;&gt;&lt;a href=&quot;#你的问题是想法太多读书太少&quot; class=&quot;headerlink&quot; title=&quot;你的问题是想法太多读书太少&quot;&gt;&lt;/a&gt;你的问题是想法太多读书太少&lt;/h1&gt;&lt;h1 id=&quot;战术上的勤奋掩盖不了战略上的错误&quot;&gt;&lt;a 
      
    
    </summary>
    
      <category term="人生" scheme="http://yoursite.com/categories/%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="杂谈" scheme="http://yoursite.com/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>python 字典函数</title>
    <link href="http://yoursite.com/2019/03/20/python%E5%AD%97%E5%85%B8/"/>
    <id>http://yoursite.com/2019/03/20/python字典/</id>
    <published>2019-03-20T10:32:36.000Z</published>
    <updated>2019-04-19T03:08:12.368Z</updated>
    
    <content type="html"><![CDATA[<pre><code>字典是键值对的数据类型,key不可以重复，必须是不可变类型，可hash， 字典是无序的。</code></pre><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">info = &#123;</span><br><span class="line">‘name1’:&apos;tt&apos;,</span><br><span class="line">‘nmae2’:&apos;ttt&apos;</span><br><span class="line">‘david’：[24,&apos;beijing&apos;],</span><br><span class="line">&#125;</span><br><span class="line">info[&apos;david&apos;]</span><br></pre></td></tr></table></figure><h1 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info[&apos;stu1&apos;]=&apos;cat&apos;</span><br></pre></td></tr></table></figure><h1 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#没有返回None</span><br><span class="line">info.get(&apos;stu1&apos;)</span><br><span class="line">#没有报错</span><br><span class="line">info[&apos;stu1&apos;]</span><br></pre></td></tr></table></figure><h1 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">info.pop(&apos;stu1&apos;)</span><br><span class="line">#随机删除</span><br><span class="line">info.popitem()</span><br></pre></td></tr></table></figure><h1 id="多级字典嵌套"><a href="#多级字典嵌套" class="headerlink" title="多级字典嵌套"></a>多级字典嵌套</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zoo = &#123;</span><br><span class="line">&quot;爬行馆&quot;:&#123;&quot;a1&quot;:&quot;lizard&quot;&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="获取键"><a href="#获取键" class="headerlink" title="获取键"></a>获取键</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">info.keys()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="获取值"><a href="#获取值" class="headerlink" title="获取值"></a>获取值</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info.values()</span><br></pre></td></tr></table></figure><h1 id="获取items"><a href="#获取items" class="headerlink" title="获取items"></a>获取items</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info.items()</span><br></pre></td></tr></table></figure><h1 id="创建字典fromkeys"><a href="#创建字典fromkeys" class="headerlink" title="创建字典fromkeys"></a>创建字典fromkeys</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info.fromkeys([&apos;A&apos;,&apos;B&apos;,&apos;C&apos;])</span><br></pre></td></tr></table></figure><h1 id="更新字典"><a href="#更新字典" class="headerlink" title="更新字典"></a>更新字典</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dic2 = &#123;&quot;k1&quot;: &quot;v1111&quot;, &quot;a&quot;: &quot;b&quot;&#125;</span><br><span class="line">dic2.update(&#123;&quot;k1&quot;: &quot;v1111&quot;, &quot;a&quot;: &quot;b&quot;, &quot;k3&quot;: &quot;v3&quot;&#125;)</span><br><span class="line">print(&quot;Value : %s&quot; % dic2)</span><br></pre></td></tr></table></figure><h1 id="字典循环"><a href="#字典循环" class="headerlink" title="字典循环"></a>字典循环</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#高效</span><br><span class="line">for k in info:</span><br><span class="line">print(k,info[k])</span><br><span class="line">#低效</span><br><span class="line">for k,v in info.items():</span><br><span class="line">print(k,v)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;字典是键值对的数据类型,key不可以重复，必须是不可变类型，可hash， 字典是无序的。
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;语法&quot;&gt;&lt;a href=&quot;#语法&quot; class=&quot;headerlink&quot; title=&quot;语法&quot;&gt;&lt;/a&gt;语法&lt;/h1&gt;&lt;fig
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python 字典" scheme="http://yoursite.com/tags/Python-%E5%AD%97%E5%85%B8/"/>
    
  </entry>
  
  <entry>
    <title>python 常用模块函数</title>
    <link href="http://yoursite.com/2019/03/20/python%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    <id>http://yoursite.com/2019/03/20/python常用模块/</id>
    <published>2019-03-20T10:32:36.000Z</published>
    <updated>2019-04-18T22:36:21.228Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数值计算："><a href="#数值计算：" class="headerlink" title="数值计算："></a>数值计算：</h1><ul><li>浮点数高精度<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from decimal import *</span><br><span class="line">getcontext()</span><br><span class="line">getcontext().prec = 50</span><br><span class="line">a = &apos;3.141592688999999999999&apos;</span><br><span class="line">Decimal(a)</span><br></pre></td></tr></table></figure></li></ul><h1 id="id"><a href="#id" class="headerlink" title="id"></a>id</h1><p>获取对象的内存地址</p><h1 id="type"><a href="#type" class="headerlink" title="type"></a>type</h1><p>获取对象的类型</p><h1 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h1><p>不可变类型数字、字符串、元组可以用hash, 可变类型列表不可用</p><h1 id="enumerate"><a href="#enumerate" class="headerlink" title="enumerate"></a>enumerate</h1><p>用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数值计算：&quot;&gt;&lt;a href=&quot;#数值计算：&quot; class=&quot;headerlink&quot; title=&quot;数值计算：&quot;&gt;&lt;/a&gt;数值计算：&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;浮点数高精度&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python 常用模块函数" scheme="http://yoursite.com/tags/Python-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>python 字典列表字符串转换</title>
    <link href="http://yoursite.com/2019/03/20/python%E5%AD%97%E5%85%B8%E5%88%97%E8%A1%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2/"/>
    <id>http://yoursite.com/2019/03/20/python字典列表字符串转换/</id>
    <published>2019-03-20T10:32:36.000Z</published>
    <updated>2019-04-19T03:08:12.384Z</updated>
    
    <content type="html"><![CDATA[<h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><pre><code>dic = {&apos;name&apos;: &apos;Zara&apos;, &apos;age&apos;: 7, &apos;class&apos;: &apos;First&apos;}</code></pre><h2 id="字典转为字符串"><a href="#字典转为字符串" class="headerlink" title="字典转为字符串"></a>字典转为字符串</h2><pre><code>str(dic)返回：&lt;type &apos;str&apos;&gt; {&apos;age&apos;: 7, &apos;name&apos;: &apos;Zara&apos;, &apos;class&apos;: &apos;First&apos;}</code></pre><h2 id="字典可以转为元组"><a href="#字典可以转为元组" class="headerlink" title="字典可以转为元组"></a>字典可以转为元组</h2><pre><code>tuple(dict)返回：(&apos;age&apos;, &apos;name&apos;, &apos;class&apos;)tuple(dict.values())返回：(7, &apos;Zara&apos;, &apos;First&apos;)</code></pre><h2 id="字典转为列表"><a href="#字典转为列表" class="headerlink" title="字典转为列表"></a>字典转为列表</h2><pre><code>list(dict)返回：[&apos;age&apos;, &apos;name&apos;, &apos;class&apos;]dict.values</code></pre><hr><h1 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h1><pre><code>tup=(1, 2, 3, 4, 5)</code></pre><h2 id="元组转为字符串"><a href="#元组转为字符串" class="headerlink" title="元组转为字符串"></a>元组转为字符串</h2><pre><code>str(tup)返回：&apos;(1, 2, 3, 4, 5)&apos;</code></pre><h2 id="元组转为列表"><a href="#元组转为列表" class="headerlink" title="元组转为列表"></a>元组转为列表</h2><pre><code>list(tup)返回：[1, 2, 3, 4, 5]</code></pre><h2 id="嵌套元组转为字典"><a href="#嵌套元组转为字典" class="headerlink" title="嵌套元组转为字典"></a>嵌套元组转为字典</h2><pre><code>dict((1,2),(2,3))</code></pre><hr><h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><p>nums=[1, 3, 5, 7, 8, 13, 20];</p><h2 id="列表转为字符串"><a href="#列表转为字符串" class="headerlink" title="列表转为字符串"></a>列表转为字符串</h2><pre><code>str(nums)返回：&apos;[1, 3, 5, 7, 8, 13, 20]&apos;</code></pre><h2 id="列表转为元组"><a href="#列表转为元组" class="headerlink" title="列表转为元组"></a>列表转为元组</h2><pre><code>print tuple(nums)返回：(1, 3, 5, 7, 8, 13, 20)</code></pre><h2 id="嵌套列表转为字典"><a href="#嵌套列表转为字典" class="headerlink" title="嵌套列表转为字典"></a>嵌套列表转为字典</h2><pre><code>dict[[1,2],[2,3]]</code></pre><hr><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>#字符串转为元组<br>    tuple(eval(“(1,2,3)”))<br>    返回：(1, 2, 3)</p><p>#字符串转为列表<br>    list(eval(“(1,2,3)”))<br>    返回：[1, 2, 3]</p><p>#字符串转为字典</p><pre><code>eval(&quot;{&apos;name&apos;:&apos;ljq&apos;, &apos;age&apos;:24}&quot;))</code></pre><hr><h1 id="enumerate"><a href="#enumerate" class="headerlink" title="enumerate"></a>enumerate</h1><pre><code>enumerate(&apos;abcde&apos;)enumerate([1,2,3,4])</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;字典&quot;&gt;&lt;a href=&quot;#字典&quot; class=&quot;headerlink&quot; title=&quot;字典&quot;&gt;&lt;/a&gt;字典&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;dic = {&amp;apos;name&amp;apos;: &amp;apos;Zara&amp;apos;, &amp;apos;age&amp;apos;: 7,
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python 字典列表字符串转换" scheme="http://yoursite.com/tags/Python-%E5%AD%97%E5%85%B8%E5%88%97%E8%A1%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>编译型语言和解释型语言</title>
    <link href="http://yoursite.com/2019/03/20/%E7%BC%96%E8%AF%91%E5%9E%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80/"/>
    <id>http://yoursite.com/2019/03/20/编译型语言和解释型语言/</id>
    <published>2019-03-20T10:32:36.000Z</published>
    <updated>2019-04-17T04:30:46.063Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，计算机底层只能识别（并执行）0、1序列的机器码，这表示所有的高级编程语言所编写的代码，最终都要以某种方式被转换成能被计算机识别的0、1序列机器码，方可被计算机接受并执行。这种将代码转换为机器码的方式可分为编译型和解释型这2类：</p><h1 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h1><h2 id="编译型语言"><a href="#编译型语言" class="headerlink" title="编译型语言"></a>编译型语言</h2><p>把做好的源程序全部编译成二进制代码的可运行程序。然后，可直接运行这个程序。编译是指在应用源程序执行之前，就将程序源代码“翻译”成目标代码(机器语言)，因此其目标程序可以脱离其语言环境独立执行，使用比较方便、效率 较高。但应用程序一旦需要修改，必须先修改源代码，再重新编译生成新的目标文件(＊ .OBJ)才能执行，只有目标文件而没有源代码，修改很不方便。现在大多数的编程语言都是编译型的。编译程序将源程序翻译成目标程序后保存在另一个文件中，该目标程序可脱离编译程序直接在计算机上多次运行。大多数软件产品都是以目标程序形式发行给用户的，不仅便于直接运行，同时又使他人难于盗用其中的技术C、C++、Fortran、Visual Foxpro、Pascal、Delphi、Ada都是编译实现的。</p><h2 id="解释型语言"><a href="#解释型语言" class="headerlink" title="解释型语言"></a>解释型语言</h2><p>把做好的源程序翻译一句，然后执行一句，直至结束！解释型语言的实现中，翻译器并不产生目标机器代码，而是产生易于执行的中间代码，这种中间代码与机器代码是不同的，中间代码的解释是由软件支持的，不能直接使用硬件，软件解释器通常会导致执行效率较低。用解释型语言编写的程序是由另一个可以理解中间代码的解释程序执行的。与编译程序不同的是，解释程序的任务是逐一将源程序的语句解释成可执行的机器指令，不需要将源程序翻译成目标代码后再执行。释程序的优点是当语句出现语法错误时，可以立即引起程序员注意，而程序员在程序开发期间就能进行校正。对于解释型Basic语言，需要一个专门的解释器解释执行 Basic程序，每条语言只有在执行才被翻译。这种解释型语言每执行一次就翻译一次，因而效率低下。一般地，动态语言都是解释型的，如python、Tcl、Perl、Ruby、VBScript、 JavaScript等。</p><h2 id="混合型语言"><a href="#混合型语言" class="headerlink" title="混合型语言"></a>混合型语言</h2><p>Java很特殊，Java程序也需要编译，但是没有直接编译称为机器语言，而是编译称为字节码，然后在Java虚拟机上用解释方式执行字节码。Python 的也采用了类似Java的编译模式，先将Python程序编译成Python字节码，然后由一个专门的Python字节码解释器负责解释执行字节码。(Java虚拟机对字节码的执行相当于模拟一个cpu，而ruby1.8–在虚拟机还未出现前–是通过解释成语法树执行。)</p><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><h2 id="编译型语言-1"><a href="#编译型语言-1" class="headerlink" title="编译型语言"></a>编译型语言</h2><ol><li>编译型语言最大的优势之一就是其执行速度。用C/C++编写的程序运行速度要比用Java编写的相同程序快30%-70%。</li><li>编译型程序比解释型程序消耗的内存更少。</li><li>不利的一面——编译器比解释器要难写得多。</li><li>编译器在调试程序时提供不了多少帮助——有多少次在你的C语言代码中遇到一个“空指针异常”时，需要花费好几个小时来明确错误到底在代码中的什么位置。</li><li>可执行的编译型代码要比相同的解释型代码大许多。例如，C/C++的.exe文件要比同样功能的Java的.class文件大很多。</li><li>编译型程序是面向特定平台的因而是平台依赖的。</li><li>编译型程序不支持代码中实现安全性——例如，一个编译型的程序可以访问内存的任何区域，并且可以对你的PC做它想做的任何事情（大部分病毒是使用编译型语言编写的</li><li>由于松散的安全性和平台依赖性，编译型语言不太适合开发因特网或者基于Web的应用。</li></ol><h2 id="解释型语言-1"><a href="#解释型语言-1" class="headerlink" title="解释型语言"></a>解释型语言</h2><ol><li>解释型语言提供了极佳的调试支持。一名Java程序员只需要几分钟就可以定位并修复一个“空指针异常”，因为Java运行环境不仅指明了异常的性质，而且给出了异常发生位置具体的行号和函数调用顺序（著名的堆栈跟踪信息）。这样的便利是编译型语言所无法提供的。</li><li>另一个优势是解释器比编译器容易实现</li><li>解释型语言最大的优势之一是其平台独立性</li><li>解释型语言也可以保证高度的安全性——这是互联网应用迫切需要的</li><li>中间语言代码的大小比编译型可执行代码小很多</li><li>平台独立性，以及严密的安全性是使解释型语言成为适合互联网和Web应用的理想语言的2个最重要的因素。</li><li>解释型语言存在一些严重的缺点。解释型应用占用更多的内存和CPU资源。这是由于，为了运行解释型语言编写的程序，相关的解释器必须首先运行。解释器是复杂的，智能的，大量消耗资源的程序并且它们会占用很多CPU周期和内存。</li><li>由于解释型应用的decode-fetch-execute（解码-抓取-执行）的周期，它们比编译型程序慢很多。</li><li>解释器也会做很多代码优化，运行时安全性检查；这些额外的步骤占用了更多的资源并进一步降低了应用的运行速度。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;众所周知，计算机底层只能识别（并执行）0、1序列的机器码，这表示所有的高级编程语言所编写的代码，最终都要以某种方式被转换成能被计算机识别的0、1序列机器码，方可被计算机接受并执行。这种将代码转换为机器码的方式可分为编译型和解释型这2类：&lt;/p&gt;
&lt;h1 id=&quot;概念：&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="语言" scheme="http://yoursite.com/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
</feed>
